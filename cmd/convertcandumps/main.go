/*
Convertcandumps reads, converts, and writes NMEA 2000 dump files.
Supports accessing input through a URL (with local caching) or local file.
Writes to a local file.

The flags are:

	-url specifies the URL for the remote input, OR
	-inputPath specifies the local file system path to the input file
	-inputFormat specifies the input format (one of raw, n2k, CAN, ydr)
	-outputFormat specifies the output format (one of raw, n2k)
	-outputPath specifies the local file system output path. ".<fileTypeOut>" will be appended
	-groupByPGN sorts the output logs, grouped by PGN, which can be useful for testing

Overview:

	read input into contents of struct inputType
	convert input type to canonical packets type
	initialize a struct of outputType with packets from inputType struct
	write the (transformed) contents to filePathOut
	grouped by PGN if groupByPgns option specified
*/
package main

import (
	_ "embed"
	"flag"
	"fmt"
	"io"
	"net/http"

	//	"math"

	"strconv"

	//	"math"
	"os"
	"strings"
	"time"

	"github.com/brutella/can"
	//	"github.com/Masterminds/sprig/v3"
	"github.com/schollz/progressbar/v3"
	"github.com/sirupsen/logrus"
)

// log provides access to logging functionality.
var log = logrus.StandardLogger()

// seqId is used as the sequence ID when breaking up a logged packet with data length > 8.
// See the documentation of makeFastPackets for more detail.
var seqId uint8

// packet is an unpacked representation of NMEA 2000 frame with context
type packet struct {
	// time is the logged or calculated time stamp for frame receipt.
	// Allows replay of logs to simulate the timing of frame transmission/reception.
	time time.Time
	// pgn numeric ID as documented in Canboat project
	pgn uint32
	// source is the sender of the frame
	source uint8
	// destination is the intended recipient, or 255 for broadcast
	destination uint8
	// priority indicates the sender's frame priority
	priority uint8
	// timeDelta is the time lapse from receipt of the previous frame, either calculated or logged
	timeDelta float32
	// canDead specifies the Canbus channel, either calculated or logged
	canDead string
	// frame is the encoded repesention of a frame, calculated or logged
	frame can.Frame
}

// genericFmt defines the interface for types repesenting log file formats.
type genericFmt interface {
	//
	setContents(in []byte)
	setPackets(in []packet)
	getContents() []byte
	getPackets() []packet
	setGrouping(on bool)
	processContents()
	processPackets()
}

// rawFmt handles the raw format.
// The plain and fast raw formats are described at https://github.com/canboat/canboat/wiki/analyzer
// It reads both plain and fast formats but always writes the plain format.
type rawFmt struct {
	contents []byte
	packets  []packet
	grouping bool
}

// ydrFmt handles logs generated by various yachtd devices.
// Described in Appendix E of https://www.yachtd.com/downloads/ydwg02.pdf
// It both reads and writes this format.
type ydrFmt struct {
	contents []byte
	packets  []packet
	grouping bool
}

// canFmt handles a binary file format used by yachtd's canviewer software and elsewhere.
// Described in https://www.yachtd.com/downloads/CANVIEW.zip/CANView.pdf.
// It reads but doesn't write this format.
type canFmt struct {
	contents []byte
	packets  []packet
	grouping bool
}

// n2kFmt handles logs generated by a private (for now) boatkit.io project
// it can both read and write the n2k format
type n2kFmt struct {
	contents []byte
	packets  []packet
	grouping bool
}

func main() {
	fmt.Println("Entered Main")
	// Command-line parsing, largely for local testing
	var url string
	var inputFormat string
	var outputFormat string
	var inputPath string
	var outputPath string
	var groupPGNs bool
	flag.StringVar(&url, "url", "", "url of can messages to convert")
	flag.StringVar(&inputPath, "inputPath", "", "path of local file to convert")
	flag.StringVar(&outputPath, "outputPath", "", "output path")
	flag.StringVar(&inputFormat, "inputFormat", "", "Format of input file (n2k, raw, CAN)")
	flag.StringVar(&outputFormat, "outputFormat", "", "Format of output file (raw, n2k)")
	flag.BoolVar(&groupPGNs, "groupPGNs", false, "Group messages by PGN (raw output only")
	flag.Parse()

	var content []byte = make([]byte, 0)
	var inVar genericFmt
	var outVar genericFmt
	var err error
	switch inputFormat {
	case "raw":
		inVar = &rawFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
	case "ydr":
		inVar = &ydrFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
	case "CAN":
		inVar = &canFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
	case "n2k":
		inVar = &n2kFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
	default:
		panic("don't recognize dump file of type: " + inputFormat)
	}
	switch outputFormat {
	case "raw":
		outVar = &rawFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
		//	case "CAN":
		//		outVar = &canFmt{}
	case "n2k":
		outVar = &n2kFmt{
			contents: make([]byte, 0),
			packets:  make([]packet, 0),
		}
	default:
		panic("don't recognize dump file of type: " + outputFormat)
	}
	if len(url) > 0 {
		if len(inputPath) > 0 {
			panic("Choose one of: url or inputPath")
		}
		content, err = loadCachedWebContent("dump.cache", url)
		if err != nil {
			panic(err)
		}
	} else if len(inputPath) > 0 {
		content, err = loadLocalFile(inputPath)
		if err != nil {
			panic(err)
		}
	}
	inVar.setGrouping(groupPGNs)
	inVar.setContents(content)
	inVar.processContents()
	outVar.setPackets(inVar.getPackets())
	outVar.processPackets()
	writeDumpFile(outVar.getContents(), outputPath, outputFormat)
}

// setContents sets the contents field
func (y *ydrFmt) setContents(in []byte) {
	y.contents = in
}

// getContents returns the contents field
func (y *ydrFmt) getContents() []byte {
	return y.contents
}

// setPackets sets the packets field
func (y *ydrFmt) setPackets(in []packet) {
	y.packets = in
}

// getPackets returns the packets field
func (y *ydrFmt) getPackets() []packet {
	return y.packets
}

// setGrouping sets the grouping flag
func (y *ydrFmt) setGrouping(on bool) {
	y.grouping = on
}

// processContents generates a packet for each line of content
func (y *ydrFmt) processContents() {
	var result []packet
	var baseTime time.Time
	today := time.Now()
	content := string(y.contents)
	lines := strings.Split(content, "\r\n")
	for _, line := range lines {
		pkt := packet{canDead: "can1"}
		if (len(line) == 0) || strings.HasPrefix(line, "#") || strings.Compare(line, "\n") == 0 {
			continue
		}
		// 14:44:58.309 R 15FD0C2C 44 00 0E C1 76 04 FF FF
		elems := strings.Split(line, " ")
		if len(elems) != 11 {
			continue
		}
		messageTime, err := time.Parse("15:04:05", elems[0])
		if err != nil {
			continue
		}
		if baseTime.IsZero() {
			baseTime = messageTime
		}
		pkt.timeDelta = float32(messageTime.Sub(baseTime))
		if pkt.timeDelta < 0 {
			pkt.timeDelta = 0.003
		} else if pkt.timeDelta > 1.0 {
			pkt.timeDelta = 0.03
		}
		pkt.time = today.Add(time.Duration(pkt.timeDelta))
		if frame, err := strconv.ParseUint(elems[2], 16, 32); err == nil {
			pkt.frame.ID = uint32(frame)
		} else {
			continue
		}

		pkt.frame.Length = 8
		for i := 0; i < 8; i++ {
			if b, err := strconv.ParseUint(elems[i+3], 16, 8); err == nil {
				pkt.frame.Data[i] = uint8(b)
			} else {
				continue
			}
		}
		pkt.decodeCanFrameID()
		result = append(result, pkt)
	}
	if y.grouping {
		result = group(result)
	}
	y.packets = result
}

// processPackets generates a line of content for each packet
func (y *ydrFmt) processPackets() {
	for _, paket := range y.packets {
		line := fmt.Sprintf("%s,%d,%d,%d,%d,%d,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x\n", paket.time.Format("2006-01-02T15:04:05Z"), paket.priority, paket.pgn, paket.source, paket.destination, paket.frame.Length, paket.frame.Data[0], paket.frame.Data[1], paket.frame.Data[2], paket.frame.Data[3], paket.frame.Data[4], paket.frame.Data[5], paket.frame.Data[6], paket.frame.Data[7])
		y.contents = append(y.contents, line...)
	}
}

// setContents sets the contents field
func (r *rawFmt) setContents(in []byte) {
	r.contents = in
}

// getContents returns the contents field
func (r *rawFmt) getContents() []byte {
	return r.contents
}

// setPackets sets the packets field
func (r *rawFmt) setPackets(in []packet) {
	r.packets = in
}

// getPackets returns the packets field
func (r *rawFmt) getPackets() []packet {
	return r.packets
}

// setGrouping sets the grouping flag
func (r *rawFmt) setGrouping(on bool) {
	r.grouping = on
}

// processContents generates a packet for each input line.
// If the line has >8 bytes of data it generates a sequence of packets.
func (r *rawFmt) processContents() {
	var result []packet
	var baseTime time.Time
	content := string(r.contents)
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		pkt := packet{canDead: "can1"}
		if (len(line) == 0) || strings.HasPrefix(line, "#") || strings.Compare(line, "\n") == 0 {
			continue
		}
		elems := strings.Split(line, ",")
		messageTime, err := time.Parse("2006-01-02-15:04:05", elems[0])
		if err != nil {
			messageTime, err = time.Parse("2006-01-02T15:04:05Z", elems[0])
			if err != nil {
				messageTime, err = time.Parse("2006-01-02T15:04:05", elems[0])
				if err != nil {
					break
				}
			}
		}
		pkt.time = messageTime
		if baseTime.IsZero() {
			baseTime = messageTime
		}
		pkt.timeDelta = float32(messageTime.Sub(baseTime))
		if pkt.timeDelta < 0 {
			pkt.timeDelta = 0.003
		} else if pkt.timeDelta > 1.0 {
			pkt.timeDelta = 0.03
		}
		priority, _ := strconv.ParseUint(elems[1], 10, 8)
		pgn, _ := strconv.ParseUint(elems[2], 10, 32)
		source, _ := strconv.ParseUint(elems[3], 10, 8)
		destination, _ := strconv.ParseUint(elems[4], 10, 8)
		pkt.frame.ID = uint32(endcodeCanFrameID(uint64(pgn), uint64(priority), uint64(source), uint64(destination)))
		length, _ := strconv.ParseUint(elems[5], 10, 8)
		if length > 8 {
			result = append(result, makeFastPackets(pkt, elems[6:])...)
		} else {
			pkt.frame.Length = uint8(length)
			for i := 0; i < int(length); i++ {
				b, _ := strconv.ParseUint(elems[i+6], 16, 8)
				pkt.frame.Data[i] = uint8(b)
			}
			result = append(result, pkt)
		}
	}
	if r.grouping {
		result = group(result)
	}
	r.packets = result
}

// processPackets generates a line of content for each packet.
func (r *rawFmt) processPackets() {
	for _, paket := range r.packets {
		line := fmt.Sprintf("%s,%d,%d,%d,%d,%d,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x\n", paket.time.Format("2006-01-02T15:04:05Z"), paket.priority, paket.pgn, paket.source, paket.destination, paket.frame.Length, paket.frame.Data[0], paket.frame.Data[1], paket.frame.Data[2], paket.frame.Data[3], paket.frame.Data[4], paket.frame.Data[5], paket.frame.Data[6], paket.frame.Data[7])
		r.contents = append(r.contents, line...)
	}
}

// setContents sets the contents field
func (n *n2kFmt) setContents(in []byte) {
	n.contents = in
}

// getContents returns the contents field
func (n *n2kFmt) getContents() []byte {
	return n.contents
}

// setPackets sets the packets field
func (n *n2kFmt) setPackets(in []packet) {
	n.packets = in
}

// getPackets returns the packets field
func (n *n2kFmt) getPackets() []packet {
	return n.packets
}

// setGrouping sets the grouping flag
func (n *n2kFmt) setGrouping(on bool) {
	n.grouping = on
}

// processContents generates a packet for each line of content
func (n *n2kFmt) processContents() {
	result := packet{}
	n.packets = make([]packet, 0)
	baseTime := time.Now()
	content := string(n.contents)
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		fmt.Sscanf(line, " (%f)  %s  %8X   [%d]  %X %X %X %X %X %X %X %X", &result.timeDelta, &result.canDead, &result.frame.ID, &result.frame.Length, &result.frame.Data[0], &result.frame.Data[1], &result.frame.Data[2], &result.frame.Data[3], &result.frame.Data[4], &result.frame.Data[5], &result.frame.Data[6], &result.frame.Data[7])
		baseTime = baseTime.Add(time.Duration(result.timeDelta))
		result.time = baseTime
		result.decodeCanFrameID()
		n.packets = append(n.packets, result)
	}
	if n.grouping {
		n.packets = group(n.packets)
	}

}

// processPackets generates a line of content for each packet
func (n *n2kFmt) processPackets() {
	for _, paket := range n.packets {
		line := fmt.Sprintf(" (%f)	%s	%08X	[%d]  %02x %02x %02x %02x %02x %02x %02x %02x\n", paket.timeDelta, paket.canDead, paket.frame.ID, paket.frame.Length, paket.frame.Data[0], paket.frame.Data[1], paket.frame.Data[2], paket.frame.Data[3], paket.frame.Data[4], paket.frame.Data[5], paket.frame.Data[6], paket.frame.Data[7])
		n.contents = append(n.contents, line...)
	}
}

// setContents sets the contents field
func (c *canFmt) setContents(in []byte) {
	c.contents = in
}

// getContents returns the contents field
func (c *canFmt) getContents() []byte {
	return c.contents
}

// setPackets sets the packets field
func (c *canFmt) setPackets(in []packet) {
	c.packets = in
}

// getPackets returns the packets field
func (c *canFmt) getPackets() []packet {
	return c.packets
}

// setGrouping sets the grouping flag
func (c *canFmt) setGrouping(on bool) {
	c.grouping = on
}

// processContents converts its contents to packets.
func (c *canFmt) processContents() {
	c.packets = make([]packet, 0)
	baseTime := time.Now()
	var baseMinutes, baseMillis uint16
	content := c.contents
	for {
		if len(content) < 16 { // invariant is len(content) MOD 16 == 0
			break
		} else {
			buf := content[:16]
			content = content[16:]
			paket, err := toPacket(buf, &baseMinutes, &baseMillis)
			if err != nil {
				continue // probably a service record
			}
			paket.decodeCanFrameID()
			baseTime = baseTime.Add(time.Duration(paket.timeDelta))
			paket.time = baseTime
			c.packets = append(c.packets, paket)
		}
	}
	if c.grouping {
		c.packets = group(c.packets)
	}
}

// processPackets aborts the program, since we read but don't write CAN files.
func (c *canFmt) processPackets() {
	panic("we don't write .CAN files, sorry")
}

// toPacket generates a packet from a CAN format byte slice.
func toPacket(line []byte, baseMinutes *uint16, baseMillis *uint16) (packet, error) {
	result := packet{}
	header := getuint16(line)
	if header&0x8000 != 0 {
		panic("require 29 bit ID")
	}
	if header&0x4000 != 0 {
		return result, fmt.Errorf("service record") // service record
	}
	result.frame.Length = uint8(header&0x3800>>11) + 1
	if header&0x0400 == 0 {
		result.canDead = "can1"
	} else {
		result.canDead = "can2"
	}

	minutes := header & 0x03ff
	if *baseMinutes == uint16(0) {
		*baseMinutes = minutes
	}
	deltaMinutes := minutes - *baseMinutes
	*baseMinutes = minutes

	millis := getuint16(line[2:])
	if *baseMillis == 0 {
		*baseMillis = millis
	}
	deltaMillis := millis - *baseMillis
	*baseMillis = millis
	tDelta := float32(deltaMinutes) * 60
	tDelta += float32(deltaMillis) / 60000
	result.timeDelta = tDelta
	result.frame.ID = getuint32(line[4:])
	copy(result.frame.Data[:], line[8:])

	return result, nil
}

// getuint16 returns a 16 bit unsigned integer from an LSB encoded byte array.
func getuint16(buf []byte) uint16 {
	return uint16(buf[0]) + (uint16(buf[1]) << 8)
}

// getuint32 returns a 32 bit unsigned integer from an LSB encoded byte array.
func getuint32(buf []byte) uint32 {
	return uint32(getuint16(buf[0:])) + (uint32(getuint16(buf[2:])) << 16)
}

// makeFastPackets generates a series of packets containing data for Fast packets with > 8 bytes.
// Some log formats write all of the data for such packets on a single line.
// The NMEA 2000 wire protocol transmits such data as a series of frames.
// This function returns an equivalent series of packets.
// Described at https://canboat.github.io/canboat/canboat.html, heading "Packet Framing"
func makeFastPackets(paket packet, data []string) []packet {

	result := []packet{}
	seqFrameNum := uint8(seqId << 5)
	length := len(data)
	next := paket
	next.frame.Length = 8
	next.frame.Data[0] = seqFrameNum
	next.frame.Data[1] = uint8(length)
	for i := 0; i < 6; i++ {
		b, _ := strconv.ParseUint(data[i], 16, 8)
		next.frame.Data[i+2] = uint8(b)
	}
	data = data[6:]
	result = append(result, next)
	for {
		seqFrameNum++
		next.frame.Data[0] = seqFrameNum
		limit := 7
		if len(data) < limit {
			limit = len(data)
		}
		for i := 0; i < limit; i++ {
			b, _ := strconv.ParseUint(data[i], 16, 8)
			next.frame.Data[i+1] = uint8(b)
		}
		result = append(result, next)
		data = data[limit:]
		if len(data) == 0 {
			break
		}
	}
	seqId++        // so we'll use a different sequence ID for the next set of continuation packets
	if seqId > 7 { // sequence ID range is 0-7
		seqId = 0
	}
	return result
}

// group sorts a slice of packets, grouping by PGN.
func group(in []packet) []packet {
	group := make(map[uint32][]packet)
	for _, pkt := range in {
		if group[pkt.pgn] == nil {
			group[pkt.pgn] = make([]packet, 0)
		}
		group[pkt.pgn] = append(group[pkt.pgn], pkt)
	}
	out := make([]packet, len(in))
	for _, pkts := range group {
		out = append(out, pkts...)
	}
	return out
}

// loadLocalFile returns a byte slice containing the contents of the specified file.
func loadLocalFile(path string) ([]byte, error) {
	f, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	content, err := io.ReadAll(f)
	if err != nil {
		panic(err)
	}
	return content, nil
}

// writeDumpFile writes the specified byte slice into the specified file.
func writeDumpFile(out []byte, path, fType string) {
	if f, err := os.Create(path + "." + fType); err != nil {
		panic(err)
	} else {
		defer f.Close()
		_, err := f.Write(out)
		if err != nil {
			panic(err)
		}
	}

}

// cacheFromWeb returns the name of a cached file containing data returned from a URL.
// It creates or renews the cache contents if not accessed within the last hour.
func cacheFromWeb(name, url string) (string, error) {
	// get stats on cached file (name+cache)
	// if not exist or expired, get contents from web and save in cached file
	var cacheDuration = 1 * time.Hour
	var cachedName = name + ".cache"
	fstat, err := os.Stat(cachedName)
	if err != nil || time.Since(fstat.ModTime()) > cacheDuration {
		log.Infof("Downloading source data...")

		req, _ := http.NewRequest("GET", url, nil)
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			return cachedName, err
		}
		defer resp.Body.Close()

		f, _ := os.OpenFile(cachedName, os.O_CREATE|os.O_WRONLY, 0644)

		bar := progressbar.DefaultBytes(
			resp.ContentLength,
			fmt.Sprintf("Downloading %s\n", name),
		)
		_, _ = io.Copy(io.MultiWriter(f, bar), resp.Body)

		f.Close()
	} else {
		log.Infof(fmt.Sprintf("Using cached file %s\n", name))
	}
	return cachedName, nil
}

// loadCachedWebContent returns the contents of a URL.
// The contents are cached in a local file.
func loadCachedWebContent(name, url string) ([]byte, error) {
	cachedName, err := cacheFromWeb(name, url)
	if err != nil {
		panic(err)
	}
	cacheContent, err := loadLocalFile(cachedName)
	if err != nil {
		panic(err)
	}
	return cacheContent, nil
}

// decodeCanFrameID sets the relevant packet fields to the values encoded in the frame's ID
// Described at https://canboat.github.io/canboat/canboat.html.
func (p *packet) decodeCanFrameID() {
	p.source = uint8(p.frame.ID & 0xFF)
	p.pgn = (p.frame.ID & 0x3FFFF00) >> 8
	p.priority = uint8((p.frame.ID & 0x1C000000) >> 26)
	pduFormat := uint8((p.pgn & 0xFF00) >> 8)
	if pduFormat < 240 {
		// This is a targeted packet, and the lower PS has the address
		p.destination = uint8(p.pgn & 0xFF)
		p.pgn &= 0xFFF00
	}
}

// endcodeCanFrameID encodes its arguments into the canbus/NMEA 2000 wire format.
// Described at https://canboat.github.io/canboat/canboat.html.
func endcodeCanFrameID(pgn, priority, source, destination uint64) uint64 {

	if destination != 255 {
		// This is a targeted packet, and the lower PS has the address
		pgn |= destination
	}
	result := pgn << 8
	result |= source
	result |= (priority << 26)
	return result
}
