// Code generated by "cmd/pgngen"; DO NOT EDIT.

package pgn

import (
	"fmt"
	
	"github.com/boatkit-io/tugboat/pkg/units"
)

func nullableUnit[T any, U any, V float32|uint16|int16|uint32](u U, v *V, newer func(u U, v float32) T) *T {
	if v == nil {
		return nil
	}
	ov := newer(u, float32(*v))
	return &ov
}

// Spit out global consts
{{- range .PGNDoc.Enums }}
{{- $name := .Name  }}

type {{ $name }} {{ constSize .MaxValue }}
const (
{{- range .Values }}
	{{ toVarName .Text }}	{{ $name }} = {{ .Value }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .Values }}
		case {{ .Value }}:
			return "{{ .Text }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

{{ range .PGNDoc.IndirectEnums }}
type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]map[int]string{
{{- range $key, $value := makeIndirectMap . -}}
	{{- $key }}: {
	{{- range $k, $v := $value -}}
		{{- $k }}: " {{- $v }}",
	{{ end }} },
{{ end }}
}

{{ end }}



{{ range .PGNDoc.FieldTypeEnums }}


type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]FieldDescriptor{
{{- range .EnumFieldTypeValues -}}
	{{- .Value }}: {
		Name: "{{ .Name }}",
		CanboatType: "{{ .FieldType }}",
		Resolution: {{ .Resolution }},
		Unit: "{{ .Unit }}",
		BitLength: {{ .BitLength }},
		BitLookupName: "{{ .BitLookupName }}",
		},
	{{ end }} 
}
{{ end }}

{{- range .PGNDoc.BitEnums }}
{{- $name := .Name  }}

type {{ $name }} uint16
const (
{{- range .EnumBitValues }}
	{{ toVarName .Label }}	{{ $name }} = {{ .Bit }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .EnumBitValues }}
		case {{ .Bit }}:
			return "{{ .Label }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

var unseenList = []PgnInfo{
{{- range .PGNDoc.NeverSeenPGNs }}
	{
		PGN: {{ .PGN }},
		Description: {{ quote .Description }},
		Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
		ManId: {{ matchManufacturer . }},
	},
{{- end }}
}
		
var pgnList = []PgnInfo{
{{- range .PGNDoc.PGNs }}
	{
		Id: "{{ .Id }}",
		PGN: {{ .PGN }},
		Description: {{ quote .Description }},
		Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
		ManId: {{ matchManufacturer . }},
		Decoder: Decode{{ .Id }},
		Fields: map[int]*FieldDescriptor{
		{{- range .AllFields }}
		{{ .Order }}: { 
			Id: "{{ .Id }}",
			Name: "{{ .Name }}",
			BitLength: {{ .BitLength }},
			BitOffset: {{ .BitOffset }},
			BitLengthVariable: {{ .BitLengthVariable }},
			CanboatType: "{{ .FieldType }}",
			GolangType: {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") -}}
			"{{- convertFieldType . }}",
			{{- else -}}	
				"",
			{{- end }}
			Resolution: {{- if .Resolution -}}
			{{ .Resolution }}
			{{- else -}}
			1
			{{- end }},
			Signed: {{ .Signed }},
			},
		{{- end }}
		},
	},
{{- end }}
}
// Build structs for each PGN
{{- range .PGNDoc.PGNs }}
{{- $pgn := . }}
type {{ .Id }} struct {
	Info MessageInfo
	{{- range .Fields }}
	{{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
	{{- if  $pgn.RepeatingFieldSet1Size }}
	Repeating1 []{{ $pgn.Id }}Repeating1
	{{- end }}
	{{- if $pgn.RepeatingFieldSet2Size  }}
	Repeating2 []{{ $pgn.Id }}Repeating2
	{{- end }}
}
{{- if $pgn.RepeatingFieldSet1Size }}
type {{ $pgn.Id }}Repeating1 struct {
	{{- range $pgn.FieldsRepeating1 }}
	{{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
}
func (p *{{- .Id }} ) encode{{- .Id }}Repeating1(stream *DataStream) error {
	var err error
	{{- $substruct := "Repeating1[index]." }}
	for index := range p.Repeating1 {
	{{- range $idx, $field := $pgn.FieldsRepeating1 }}
	{{- $func := getFieldSerializer $field $substruct  }}
	{{- if ne $func "" }}
	{{ $func }}
	if err != nil {
		return err
	}
	{{- end }}
	{{- end }}
	}
	return nil
}

{{- end }}
{{- if $pgn.RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
	{{- range $pgn.FieldsRepeating2 }}
	{{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
}

func (p *{{- .Id }} ) encode{{- .Id }}Repeating2(stream *DataStream) error {
	var err error
	{{- $substruct := "Repeating2[index]." }}
	for index := range p.Repeating2 {
	{{- range $idx, $field := $pgn.FieldsRepeating2 }}
	{{- $func := getFieldSerializer $field $substruct  }}
	{{- if ne $func "" }}
	{{ $func }}
	if err != nil {
		return err
	}
	{{- end }}
	{{- end }}
	}
	return nil
}
{{- end }}
func (p *{{- .Id }} ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	{{- $repeat1CountIndex :=  $pgn.RepeatingFieldSet1CountField }}
	{{- $repeat2CountIndex :=  $pgn.RepeatingFieldSet2CountField }}
	{{- $repeat1StartIndex := $pgn.RepeatingFieldSet1StartField}}
	{{- $repeat2StartIndex := $pgn.RepeatingFieldSet2StartField }}
	{{- if (gt $repeat1CountIndex 0) }}
	repeat1Count := uint8(len(p.Repeating1))
	{{- end }}
	{{- if (gt $repeat2CountIndex 0) }}
	repeat2Count := uint8(len(p.Repeating2))
	{{- end }}
	{{- range $idx, $field := $pgn.Fields }}
	{{- if and (gt $repeat2CountIndex 0) (eq $field.Id "Pgn") }}
	{{- $func := getFieldSerializer $field "" }}
	{{- if ne $func "" }}
	{{ $func }}
	if err != nil {
		return nil, err
	}	
	if IsProprietaryPGN(*p.Pgn) {
	{{- continue }}
	{{- end }}
	{{- end }}
	{{- if and (gt $repeat2CountIndex 0) (eq $idx 5) }}
	}
	{{- end }}
	{{- if and (gt $repeat1CountIndex 0) (eq $repeat1CountIndex $field.Order) }}
	err = stream.writeUint8(&repeat1Count, {{- $field.BitLength }}, 0)
	if err != nil {
		return nil, err
		}
	{{- continue }}
	{{- end }}
	{{- if and (gt $repeat2CountIndex 0) (eq $repeat2CountIndex $field.Order) }}
	err = stream.writeUint8(&repeat2Count, {{- $field.BitLength }}, 0)
	if err != nil {
		return nil, err
		}
	{{- continue }}		
	{{- end }}
	{{- if and (gt $repeat1StartIndex 0) (eq $repeat1StartIndex $field.Order) }}
	err = p.encode{{- $pgn.Id }}Repeating1(stream)
	if err != nil {
		return nil, err
		}
	{{- continue }}
	{{- end }}
	{{- if and (gt $repeat2StartIndex 0) (eq $repeat2StartIndex $field.Order) }}
	err = p.encode{{- $pgn.Id }}Repeating2(stream)
	if err != nil {
		return nil, err
		}
	{{- continue }}
	{{- end }}
	{{- $func := getFieldSerializer $field "" }}
	{{- if ne $func "" }}
	{{ $func }}
	if err != nil {
		return nil, err
	}
	{{- end }}
	{{- end }}
	return &p.Info, err
}

{{- $funcName := concat "Decode" .Id }}
func {{ $funcName }}(Info MessageInfo, stream *DataStream) (any, error) {
	var val {{ .Id }}
	val.Info = Info

	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16 = 0
	{{- end }}
	{{- $repeat1 :=  $pgn.RepeatingFieldSet1Size }}
	{{- if  $repeat1 }}
		var repeat1Count uint16 = 0
	{{- end }}
	{{- $repeat2 :=  $pgn.RepeatingFieldSet2Size }}
	{{- if $repeat2 }}
		var repeat2Count uint16
	{{- end }}
	{{- $isKeyValue := or (eq .Id "SimnetParameterSet") (eq .Id "SimnetKeyValue" ) (eq .Id "BGKeyValueData" ) }}
	{{- if $isKeyValue }}
		var valueLength uint16
	{{ end }}
	{{- $hasVariableData := and (eq .PGN 126208) (gt $repeat1 1) }}
	{{- if $hasVariableData }}
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	{{- end }}

	{{- range $idx, $field := $pgn.Fields }}
	{{- if or (eq $field.FieldType "RESERVED") (eq $field.FieldType "SPARE") }}
	stream.skipBits({{ $field.BitLength }})
	if stream.isEOF() {
		return val, nil
		}
	{{- else }}	
	{{- if and $repeat2 (eq $idx 2) }}
	if IsProprietaryPGN( *val.Pgn) {
	{{- end }}
	{{- if and $repeat2 (eq $idx 5) }}
	} 
	{{- end }}
	{{- $funcs := getFieldDeserializer $pgn . }}
	if v, err := {{ index $funcs 0 }}; err != nil {
		return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
	} else {
	{{- if not (isNil .Match) }}
	{{- if isPointerFieldType  . }}
		if v != nil && *v != {{ derefInt .Match }} {
			return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ .Id }}: Expected %d != %d", {{ .Match }}, *v)
		} 
	{{- else }}
		if v != {{ .Match }} {
			return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ .Id }}: Expected %d != %d", {{ .Match }}, v)
		} 
	{{- end }}
	{{- end }}
		val.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}{{ else }}v{{ end }}
	{{- if and $repeat1 (eq $idx (subtract $pgn.RepeatingFieldSet1CountField 1)) }}
		if v != nil {
			repeat1Count = uint16(*v)
		}
	{{- end }}
	{{- if and $repeat2 (eq $idx (subtract $pgn.RepeatingFieldSet2CountField 1)) }}
		if v != nil {
			repeat2Count = uint16(*v)
		}
	{{- end }}
	{{- if and $binaryLengthField (eq $idx (subtract $pgn.BitLengthField 1)) }}
		if v != nil {
			binaryLength = uint16(*v)
		}
	{{- end }}
	{{- if and $hasVariableData (eq .Id "ManufacturerCodeConst") }}
		if v != nil {
			manufacturer = ManufacturerCodeConst(*v)
		}
	{{- end }}
	{{- if and $isKeyValue (eq $field.Name "MinLength") }}
		if v != nil {
			valueLength = uint16(*v) * 8
		}
	{{ end }}

		if stream.isEOF() {
			return val, nil
		} 
	} 
	{{- end }}
{{- end }}
	{{- if $repeat1 }}
	{{- if gt $pgn.RepeatingFieldSet1CountField 0 }}
		if repeat1Count == 0 {
			return val, nil
		}
	{{- end }}
	val.Repeating1 = make([]{{ $pgn.Id }}Repeating1, 0)
	i := 0 
	for {
		var rep {{ $pgn.Id }}Repeating1
		{{- range $pgn.FieldsRepeating1 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}{{ else }}v{{ end }}
		{{- if eq .FieldType "FIELD_INDEX" }}
			if v != nil {
				fieldIndex = *v
			}
		{{- end }}
		{{- if and $isKeyValue (eq .Name "Length") }}
			if v != nil {
				valueLength = uint16(*v) * 8
			}
		{{ end }}
		} 
		{{- end }}
		{{- end }}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	} 
	{{- end }}
	{{- if $repeat2 }}
	{{- if gt $pgn.RepeatingFieldSet2CountField 0 }}
		if repeat2Count == 0 {
			return val, nil
		}
	{{- end }}	
	val.Repeating2 = make([]{{ $pgn.Id }}Repeating2, 0)
	i = 0
	for {
		var rep {{ $pgn.Id }}Repeating2
		{{- range $pgn.FieldsRepeating2 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{- .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}{{ else }}v{{ end }}
		{{- if and (eq $pgn.RepeatingFieldSet2CountField 2) (eq .FieldType "FIELD_INDEX") }}
			if v != nil {
				fieldIndex = *v
			}
		{{- end }}
		}  
		{{- end }}
	{{- end }}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	} 
	{{- end }}	
	return val, nil
}
{{- end }}
