// Code generated by "cmd/pgngen"; DO NOT EDIT.

package pgn

import "fmt"



// Spit out global consts

type LightingCommandConst uint8
const (
	Idle	LightingCommandConst = 0
	DetectDevices	LightingCommandConst = 1
	Reboot	LightingCommandConst = 2
	FactoryReset	LightingCommandConst = 3
	PoweringUp	LightingCommandConst = 4
)

func (e LightingCommandConst) GoString() string {return e.String() }
func (e LightingCommandConst) String() string {
	switch e {
		case 0:
			return "Idle"
		case 1:
			return "Detect Devices"
		case 2:
			return "Reboot"
		case 3:
			return "Factory Reset"
		case 4:
			return "Powering Up"
	default:
		return fmt.Sprintf("%s(%d)", "LightingCommandConst", int(e))
	}
}

type IndustryCodeConst uint8
const (
	Global	IndustryCodeConst = 0
	Highway	IndustryCodeConst = 1
	Agriculture	IndustryCodeConst = 2
	Construction	IndustryCodeConst = 3
	Marine	IndustryCodeConst = 4
	Industrial	IndustryCodeConst = 5
)

func (e IndustryCodeConst) GoString() string {return e.String() }
func (e IndustryCodeConst) String() string {
	switch e {
		case 0:
			return "Global"
		case 1:
			return "Highway"
		case 2:
			return "Agriculture"
		case 3:
			return "Construction"
		case 4:
			return "Marine"
		case 5:
			return "Industrial"
	default:
		return fmt.Sprintf("%s(%d)", "IndustryCodeConst", int(e))
	}
}

type ManufacturerCodeConst uint16
const (
	ARKSEnterprisesInc	ManufacturerCodeConst = 69
	FWMurphyEnovationControls	ManufacturerCodeConst = 78
	TwinDisc	ManufacturerCodeConst = 80
	KohlerPowerSystems	ManufacturerCodeConst = 85
	HemisphereGPSInc	ManufacturerCodeConst = 88
	BEPMarine	ManufacturerCodeConst = 116
	Airmar	ManufacturerCodeConst = 135
	Maretron	ManufacturerCodeConst = 137
	Lowrance	ManufacturerCodeConst = 140
	MercuryMarine	ManufacturerCodeConst = 144
	NautibusElectronicGmbH	ManufacturerCodeConst = 147
	BlueWaterData	ManufacturerCodeConst = 148
	Westerbeke	ManufacturerCodeConst = 154
	OffshoreSystemsUKLtd	ManufacturerCodeConst = 161
	EvinrudeBRP	ManufacturerCodeConst = 163
	CPACSystemsAB	ManufacturerCodeConst = 165
	XantrexTechnologyInc	ManufacturerCodeConst = 168
	YanmarMarine	ManufacturerCodeConst = 172
	VolvoPenta	ManufacturerCodeConst = 174
	HondaMarine	ManufacturerCodeConst = 175
	CarlingTechnologiesIncMoritzAerospace	ManufacturerCodeConst = 176
	BeedeInstruments	ManufacturerCodeConst = 185
	FloscanInstrumentCoInc	ManufacturerCodeConst = 192
	Nobletec	ManufacturerCodeConst = 193
	MysticValleyCommunications	ManufacturerCodeConst = 198
	Actia	ManufacturerCodeConst = 199
	HondaMarine2	ManufacturerCodeConst = 200
	DisenosYTechnologia	ManufacturerCodeConst = 201
	DigitalSwitchingSystems	ManufacturerCodeConst = 211
	XintexAtena	ManufacturerCodeConst = 215
	EMMINETWORKSL	ManufacturerCodeConst = 224
	HondaMarine3	ManufacturerCodeConst = 225
	ZF	ManufacturerCodeConst = 228
	Garmin	ManufacturerCodeConst = 229
	YachtMonitoringSolutions	ManufacturerCodeConst = 233
	SailormadeMarineTelemetryTetraTechnologyLTD	ManufacturerCodeConst = 235
	Eride	ManufacturerCodeConst = 243
	HondaMarine4	ManufacturerCodeConst = 250
	HondaMotorCompanyLTD	ManufacturerCodeConst = 257
	Groco	ManufacturerCodeConst = 272
	Actisense	ManufacturerCodeConst = 273
	AmphenolLTWTechnology	ManufacturerCodeConst = 274
	Navico	ManufacturerCodeConst = 275
	HamiltonJet	ManufacturerCodeConst = 283
	SeaRecovery	ManufacturerCodeConst = 285
	CoelmoSRLItaly	ManufacturerCodeConst = 286
	BEPMarine2	ManufacturerCodeConst = 295
	EmpirBus	ManufacturerCodeConst = 304
	NovAtel	ManufacturerCodeConst = 305
	SleipnerMotorAS	ManufacturerCodeConst = 306
	MBWTechnologies	ManufacturerCodeConst = 307
	FischerPanda	ManufacturerCodeConst = 311
	ICOM	ManufacturerCodeConst = 315
	Qwerty	ManufacturerCodeConst = 328
	Dief	ManufacturerCodeConst = 329
	BöningAutomationstechnologieGmbHAndCoKG	ManufacturerCodeConst = 341
	KoreanMaritimeUniversity	ManufacturerCodeConst = 345
	ThraneAndThrane	ManufacturerCodeConst = 351
	Mastervolt	ManufacturerCodeConst = 355
	FischerPandaGenerators	ManufacturerCodeConst = 356
	VictronEnergy	ManufacturerCodeConst = 358
	RollsRoyceMarine	ManufacturerCodeConst = 370
	ElectronicDesign	ManufacturerCodeConst = 373
	NorthernLights	ManufacturerCodeConst = 374
	Glendinning	ManufacturerCodeConst = 378
	BAndG	ManufacturerCodeConst = 381
	RosePointNavigationSystems	ManufacturerCodeConst = 384
	JohnsonOutdoorsMarineElectronicsIncGeonav	ManufacturerCodeConst = 385
	Capi2	ManufacturerCodeConst = 394
	BeyondMeasure	ManufacturerCodeConst = 396
	LivorsiMarine	ManufacturerCodeConst = 400
	ComNav	ManufacturerCodeConst = 404
	Chetco	ManufacturerCodeConst = 409
	FusionElectronics	ManufacturerCodeConst = 419
	StandardHorizon	ManufacturerCodeConst = 421
	TrueHeadingAB	ManufacturerCodeConst = 422
	EgersundMarineElectronicsAS	ManufacturerCodeConst = 426
	EmTrakMarineElectronics	ManufacturerCodeConst = 427
	TohatsuCoJP	ManufacturerCodeConst = 431
	DigitalYacht	ManufacturerCodeConst = 437
	ComarSystemsLimited	ManufacturerCodeConst = 438
	Cummins	ManufacturerCodeConst = 440
	VDOAkaContinentalCorporation	ManufacturerCodeConst = 443
	ParkerHannifinAkaVillageMarineTech	ManufacturerCodeConst = 451
	AlltekMarineElectronicsCorp	ManufacturerCodeConst = 459
	SANGIORGIOSEIN	ManufacturerCodeConst = 460
	VeethreeElectronicsAndMarine	ManufacturerCodeConst = 466
	HumminbirdMarineElectronics	ManufacturerCodeConst = 467
	SITEXMarineElectronics	ManufacturerCodeConst = 470
	SeaCrossMarineAB	ManufacturerCodeConst = 471
	GMEAkaStandardCommunicationsPtyLTD	ManufacturerCodeConst = 475
	HumminbirdMarineElectronics2	ManufacturerCodeConst = 476
	OceanSatBV	ManufacturerCodeConst = 478
	ChetcoDigitialInstruments	ManufacturerCodeConst = 481
	Watcheye	ManufacturerCodeConst = 493
	LcjCapteurs	ManufacturerCodeConst = 499
	AttwoodMarine	ManufacturerCodeConst = 502
	NaviopSRL	ManufacturerCodeConst = 503
	VesperMarineLtd	ManufacturerCodeConst = 504
	MarinesoftCoLTD	ManufacturerCodeConst = 510
	NoLandEngineering	ManufacturerCodeConst = 517
	TransasUSA	ManufacturerCodeConst = 518
	NationalInstrumentsKorea	ManufacturerCodeConst = 529
	OnwaMarine	ManufacturerCodeConst = 532
	MarinecraftSouthKorea	ManufacturerCodeConst = 571
	McMurdoGroupAkaOroliaLTD	ManufacturerCodeConst = 573
	Advansea	ManufacturerCodeConst = 578
	KVH	ManufacturerCodeConst = 579
	SanJoseTechnology	ManufacturerCodeConst = 580
	YachtControl	ManufacturerCodeConst = 583
	SuzukiMotorCorporation	ManufacturerCodeConst = 586
	USCoastGuard	ManufacturerCodeConst = 591
	ShipModuleAkaCustomware	ManufacturerCodeConst = 595
	AquaticAV	ManufacturerCodeConst = 600
	AventicsGmbH	ManufacturerCodeConst = 605
	Intellian	ManufacturerCodeConst = 606
	SamwonIT	ManufacturerCodeConst = 612
	ArltTecnologies	ManufacturerCodeConst = 614
	BavariaYacts	ManufacturerCodeConst = 637
	DiverseYachtServices	ManufacturerCodeConst = 641
	WemaUSADbaKUS	ManufacturerCodeConst = 644
	Garmin2	ManufacturerCodeConst = 645
	ShenzhenJiuzhouHimunication	ManufacturerCodeConst = 658
	RockfordCorp	ManufacturerCodeConst = 688
	JLAudio	ManufacturerCodeConst = 704
	Autonnic	ManufacturerCodeConst = 715
	YachtDevices	ManufacturerCodeConst = 717
	REAPSystems	ManufacturerCodeConst = 734
	AuElectronicsGroup	ManufacturerCodeConst = 735
	LxNav	ManufacturerCodeConst = 739
	DaeMyung	ManufacturerCodeConst = 743
	Woosung	ManufacturerCodeConst = 744
	ClarionUS	ManufacturerCodeConst = 773
	HMISystems	ManufacturerCodeConst = 776
	OceanSignal	ManufacturerCodeConst = 777
	Seekeeper	ManufacturerCodeConst = 778
	PolyPlanar	ManufacturerCodeConst = 781
	FischerPandaDE	ManufacturerCodeConst = 785
	BroydaIndustries	ManufacturerCodeConst = 795
	CanadianAutomotive	ManufacturerCodeConst = 796
	TidesMarine	ManufacturerCodeConst = 797
	Lumishore	ManufacturerCodeConst = 798
	StillWaterDesignsAndAudio	ManufacturerCodeConst = 799
	BJTechnologiesBeneteau	ManufacturerCodeConst = 802
	GillSensors	ManufacturerCodeConst = 803
	BlueWaterDesalination	ManufacturerCodeConst = 811
	FLIR	ManufacturerCodeConst = 815
	UndheimSystems	ManufacturerCodeConst = 824
	TeamSurv	ManufacturerCodeConst = 838
	FellMarine	ManufacturerCodeConst = 844
	Oceanvolt	ManufacturerCodeConst = 847
	Prospec	ManufacturerCodeConst = 862
	DataPanelCorp	ManufacturerCodeConst = 868
	L3Technologies	ManufacturerCodeConst = 890
	RhodanMarineSystems	ManufacturerCodeConst = 894
	NexfourSolutions	ManufacturerCodeConst = 896
	ASAElectronics	ManufacturerCodeConst = 905
	MarinesCoSouthKorea	ManufacturerCodeConst = 909
	NauticOn	ManufacturerCodeConst = 911
	Ecotronix	ManufacturerCodeConst = 930
	TimbolierIndustries	ManufacturerCodeConst = 962
	TJCMicro	ManufacturerCodeConst = 963
	CoxPowertrain	ManufacturerCodeConst = 968
	BlueSeas	ManufacturerCodeConst = 969
	TeleflexMarineSeaStarSolutions	ManufacturerCodeConst = 1850
	Raymarine	ManufacturerCodeConst = 1851
	Navionics	ManufacturerCodeConst = 1852
	JapanRadioCo	ManufacturerCodeConst = 1853
	NorthstarTechnologies	ManufacturerCodeConst = 1854
	Furuno	ManufacturerCodeConst = 1855
	Trimble	ManufacturerCodeConst = 1856
	Simrad	ManufacturerCodeConst = 1857
	Litton	ManufacturerCodeConst = 1858
	KvasarAB	ManufacturerCodeConst = 1859
	MMP	ManufacturerCodeConst = 1860
	VectorCantech	ManufacturerCodeConst = 1861
	YamahaMarine	ManufacturerCodeConst = 1862
	FariaInstruments	ManufacturerCodeConst = 1863
)

func (e ManufacturerCodeConst) GoString() string {return e.String() }
func (e ManufacturerCodeConst) String() string {
	switch e {
		case 69:
			return "ARKS Enterprises, Inc."
		case 78:
			return "FW Murphy/Enovation Controls"
		case 80:
			return "Twin Disc"
		case 85:
			return "Kohler Power Systems"
		case 88:
			return "Hemisphere GPS Inc"
		case 116:
			return "BEP Marine"
		case 135:
			return "Airmar"
		case 137:
			return "Maretron"
		case 140:
			return "Lowrance"
		case 144:
			return "Mercury Marine"
		case 147:
			return "Nautibus Electronic GmbH"
		case 148:
			return "Blue Water Data"
		case 154:
			return "Westerbeke"
		case 161:
			return "Offshore Systems (UK) Ltd."
		case 163:
			return "Evinrude/BRP"
		case 165:
			return "CPAC Systems AB"
		case 168:
			return "Xantrex Technology Inc."
		case 172:
			return "Yanmar Marine"
		case 174:
			return "Volvo Penta"
		case 175:
			return "Honda Marine"
		case 176:
			return "Carling Technologies Inc. (Moritz Aerospace)"
		case 185:
			return "Beede Instruments"
		case 192:
			return "Floscan Instrument Co. Inc."
		case 193:
			return "Nobletec"
		case 198:
			return "Mystic Valley Communications"
		case 199:
			return "Actia"
		case 200:
			return "Honda Marine"
		case 201:
			return "Disenos Y Technologia"
		case 211:
			return "Digital Switching Systems"
		case 215:
			return "Xintex/Atena"
		case 224:
			return "EMMI NETWORK S.L."
		case 225:
			return "Honda Marine"
		case 228:
			return "ZF"
		case 229:
			return "Garmin"
		case 233:
			return "Yacht Monitoring Solutions"
		case 235:
			return "Sailormade Marine Telemetry/Tetra Technology LTD"
		case 243:
			return "Eride"
		case 250:
			return "Honda Marine"
		case 257:
			return "Honda Motor Company LTD"
		case 272:
			return "Groco"
		case 273:
			return "Actisense"
		case 274:
			return "Amphenol LTW Technology"
		case 275:
			return "Navico"
		case 283:
			return "Hamilton Jet"
		case 285:
			return "Sea Recovery"
		case 286:
			return "Coelmo SRL Italy"
		case 295:
			return "BEP Marine"
		case 304:
			return "Empir Bus"
		case 305:
			return "NovAtel"
		case 306:
			return "Sleipner Motor AS"
		case 307:
			return "MBW Technologies"
		case 311:
			return "Fischer Panda"
		case 315:
			return "ICOM"
		case 328:
			return "Qwerty"
		case 329:
			return "Dief"
		case 341:
			return "Böning Automationstechnologie GmbH & Co. KG"
		case 345:
			return "Korean Maritime University"
		case 351:
			return "Thrane and Thrane"
		case 355:
			return "Mastervolt"
		case 356:
			return "Fischer Panda Generators"
		case 358:
			return "Victron Energy"
		case 370:
			return "Rolls Royce Marine"
		case 373:
			return "Electronic Design"
		case 374:
			return "Northern Lights"
		case 378:
			return "Glendinning"
		case 381:
			return "B & G"
		case 384:
			return "Rose Point Navigation Systems"
		case 385:
			return "Johnson Outdoors Marine Electronics Inc Geonav"
		case 394:
			return "Capi 2"
		case 396:
			return "Beyond Measure"
		case 400:
			return "Livorsi Marine"
		case 404:
			return "ComNav"
		case 409:
			return "Chetco"
		case 419:
			return "Fusion Electronics"
		case 421:
			return "Standard Horizon"
		case 422:
			return "True Heading AB"
		case 426:
			return "Egersund Marine Electronics AS"
		case 427:
			return "em-trak Marine Electronics"
		case 431:
			return "Tohatsu Co, JP"
		case 437:
			return "Digital Yacht"
		case 438:
			return "Comar Systems Limited"
		case 440:
			return "Cummins"
		case 443:
			return "VDO (aka Continental-Corporation)"
		case 451:
			return "Parker Hannifin aka Village Marine Tech"
		case 459:
			return "Alltek Marine Electronics Corp"
		case 460:
			return "SAN GIORGIO S.E.I.N"
		case 466:
			return "Veethree Electronics & Marine"
		case 467:
			return "Humminbird Marine Electronics"
		case 470:
			return "SI-TEX Marine Electronics"
		case 471:
			return "Sea Cross Marine AB"
		case 475:
			return "GME aka Standard Communications Pty LTD"
		case 476:
			return "Humminbird Marine Electronics"
		case 478:
			return "Ocean Sat BV"
		case 481:
			return "Chetco Digitial Instruments"
		case 493:
			return "Watcheye"
		case 499:
			return "Lcj Capteurs"
		case 502:
			return "Attwood Marine"
		case 503:
			return "Naviop S.R.L."
		case 504:
			return "Vesper Marine Ltd"
		case 510:
			return "Marinesoft Co. LTD"
		case 517:
			return "NoLand Engineering"
		case 518:
			return "Transas USA"
		case 529:
			return "National Instruments Korea"
		case 532:
			return "Onwa Marine"
		case 571:
			return "Marinecraft (South Korea)"
		case 573:
			return "McMurdo Group aka Orolia LTD"
		case 578:
			return "Advansea"
		case 579:
			return "KVH"
		case 580:
			return "San Jose Technology"
		case 583:
			return "Yacht Control"
		case 586:
			return "Suzuki Motor Corporation"
		case 591:
			return "US Coast Guard"
		case 595:
			return "Ship Module aka Customware"
		case 600:
			return "Aquatic AV"
		case 605:
			return "Aventics GmbH"
		case 606:
			return "Intellian"
		case 612:
			return "SamwonIT"
		case 614:
			return "Arlt Tecnologies"
		case 637:
			return "Bavaria Yacts"
		case 641:
			return "Diverse Yacht Services"
		case 644:
			return "Wema U.S.A dba KUS"
		case 645:
			return "Garmin"
		case 658:
			return "Shenzhen Jiuzhou Himunication"
		case 688:
			return "Rockford Corp"
		case 704:
			return "JL Audio"
		case 715:
			return "Autonnic"
		case 717:
			return "Yacht Devices"
		case 734:
			return "REAP Systems"
		case 735:
			return "Au Electronics Group"
		case 739:
			return "LxNav"
		case 743:
			return "DaeMyung"
		case 744:
			return "Woosung"
		case 773:
			return "Clarion US"
		case 776:
			return "HMI Systems"
		case 777:
			return "Ocean Signal"
		case 778:
			return "Seekeeper"
		case 781:
			return "Poly Planar"
		case 785:
			return "Fischer Panda DE"
		case 795:
			return "Broyda Industries"
		case 796:
			return "Canadian Automotive"
		case 797:
			return "Tides Marine"
		case 798:
			return "Lumishore"
		case 799:
			return "Still Water Designs and Audio"
		case 802:
			return "BJ Technologies (Beneteau)"
		case 803:
			return "Gill Sensors"
		case 811:
			return "Blue Water Desalination"
		case 815:
			return "FLIR"
		case 824:
			return "Undheim Systems"
		case 838:
			return "TeamSurv"
		case 844:
			return "Fell Marine"
		case 847:
			return "Oceanvolt"
		case 862:
			return "Prospec"
		case 868:
			return "Data Panel Corp"
		case 890:
			return "L3 Technologies"
		case 894:
			return "Rhodan Marine Systems"
		case 896:
			return "Nexfour Solutions"
		case 905:
			return "ASA Electronics"
		case 909:
			return "Marines Co (South Korea)"
		case 911:
			return "Nautic-on"
		case 930:
			return "Ecotronix"
		case 962:
			return "Timbolier Industries"
		case 963:
			return "TJC Micro"
		case 968:
			return "Cox Powertrain"
		case 969:
			return "Blue Seas"
		case 1850:
			return "Teleflex Marine (SeaStar Solutions)"
		case 1851:
			return "Raymarine"
		case 1852:
			return "Navionics"
		case 1853:
			return "Japan Radio Co"
		case 1854:
			return "Northstar Technologies"
		case 1855:
			return "Furuno"
		case 1856:
			return "Trimble"
		case 1857:
			return "Simrad"
		case 1858:
			return "Litton"
		case 1859:
			return "Kvasar AB"
		case 1860:
			return "MMP"
		case 1861:
			return "Vector Cantech"
		case 1862:
			return "Yamaha Marine"
		case 1863:
			return "Faria Instruments"
	default:
		return fmt.Sprintf("%s(%d)", "ManufacturerCodeConst", int(e))
	}
}

type AisMessageIdConst uint8
const (
	ScheduledClassAPositionReport	AisMessageIdConst = 1
	AssignedScheduledClassAPositionReport	AisMessageIdConst = 2
	InterrogatedClassAPositionReport	AisMessageIdConst = 3
	BaseStationReport	AisMessageIdConst = 4
	StaticAndVoyageRelatedData	AisMessageIdConst = 5
	BinaryAddressedMessage	AisMessageIdConst = 6
	BinaryAcknowledgement	AisMessageIdConst = 7
	BinaryBroadcastMessage	AisMessageIdConst = 8
	StandardSARAircraftPositionReport	AisMessageIdConst = 9
	UTCDateInquiry	AisMessageIdConst = 10
	UTCDateResponse	AisMessageIdConst = 11
	SafetyRelatedAddressedMessage	AisMessageIdConst = 12
	SafetyRelatedAcknowledgement	AisMessageIdConst = 13
	SatetyRelatedBroadcastMessage	AisMessageIdConst = 14
	Interrogation	AisMessageIdConst = 15
	AssignmentModeCommand	AisMessageIdConst = 16
	DGNSSBroadcastBinaryMessage	AisMessageIdConst = 17
	StandardClassBPositionReport	AisMessageIdConst = 18
	ExtendedClassBPositionReport	AisMessageIdConst = 19
	DataLinkManagementMessage	AisMessageIdConst = 20
	ATONReport	AisMessageIdConst = 21
	ChannelManagement	AisMessageIdConst = 22
	GroupAssignmentCommand	AisMessageIdConst = 23
	StaticDataReport	AisMessageIdConst = 24
	SingleSlotBinaryMessage	AisMessageIdConst = 25
	MultipleSlotBinaryMessage	AisMessageIdConst = 26
	PositionReportForLongRangeApplications	AisMessageIdConst = 27
)

func (e AisMessageIdConst) GoString() string {return e.String() }
func (e AisMessageIdConst) String() string {
	switch e {
		case 1:
			return "Scheduled Class A position report"
		case 2:
			return "Assigned scheduled Class A position report"
		case 3:
			return "Interrogated Class A position report"
		case 4:
			return "Base station report"
		case 5:
			return "Static and voyage related data"
		case 6:
			return "Binary addressed message"
		case 7:
			return "Binary acknowledgement"
		case 8:
			return "Binary broadcast message"
		case 9:
			return "Standard SAR aircraft position report"
		case 10:
			return "UTC/date inquiry"
		case 11:
			return "UTC/date response"
		case 12:
			return "Safety related addressed message"
		case 13:
			return "Safety related acknowledgement"
		case 14:
			return "Satety related broadcast message"
		case 15:
			return "Interrogation"
		case 16:
			return "Assignment mode command"
		case 17:
			return "DGNSS broadcast binary message"
		case 18:
			return "Standard Class B position report"
		case 19:
			return "Extended Class B position report"
		case 20:
			return "Data link management message"
		case 21:
			return "ATON report"
		case 22:
			return "Channel management"
		case 23:
			return "Group assignment command"
		case 24:
			return "Static data report"
		case 25:
			return "Single slot binary message"
		case 26:
			return "Multiple slot binary message"
		case 27:
			return "Position report for long range applications"
	default:
		return fmt.Sprintf("%s(%d)", "AisMessageIdConst", int(e))
	}
}

type ShipTypeConst uint8
const (
	Unavailable	ShipTypeConst = 0
	WingInGround	ShipTypeConst = 20
	WingInGroundHazardCatX	ShipTypeConst = 21
	WingInGroundHazardCatY	ShipTypeConst = 22
	WingInGroundHazardCatZ	ShipTypeConst = 23
	WingInGroundHazardCatOS	ShipTypeConst = 24
	WingInGroundNoAdditionalInformation	ShipTypeConst = 29
	Fishing	ShipTypeConst = 30
	Towing	ShipTypeConst = 31
	TowingExceeds200mOrWiderThan25m	ShipTypeConst = 32
	EngagedInDredgingOrUnderwaterOperations	ShipTypeConst = 33
	EngagedInDivingOperations	ShipTypeConst = 34
	EngagedInMilitaryOperations	ShipTypeConst = 35
	Sailing	ShipTypeConst = 36
	Pleasure	ShipTypeConst = 37
	HighSpeedCraft	ShipTypeConst = 40
	HighSpeedCraftHazardCatX	ShipTypeConst = 41
	HighSpeedCraftHazardCatY	ShipTypeConst = 42
	HighSpeedCraftHazardCatZ	ShipTypeConst = 43
	HighSpeedCraftHazardCatOS	ShipTypeConst = 44
	HighSpeedCraftNoAdditionalInformation	ShipTypeConst = 49
	PilotVessel	ShipTypeConst = 50
	SAR	ShipTypeConst = 51
	Tug	ShipTypeConst = 52
	PortTender	ShipTypeConst = 53
	AntiPollution	ShipTypeConst = 54
	LawEnforcement	ShipTypeConst = 55
	Spare	ShipTypeConst = 56
	Spare2	ShipTypeConst = 57
	Medical	ShipTypeConst = 58
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict	ShipTypeConst = 59
	PassengerShip	ShipTypeConst = 60
	PassengerShipHazardCatX	ShipTypeConst = 61
	PassengerShipHazardCatY	ShipTypeConst = 62
	PassengerShipHazardCatZ	ShipTypeConst = 63
	PassengerShipHazardCatOS	ShipTypeConst = 64
	PassengerShipNoAdditionalInformation	ShipTypeConst = 69
	CargoShip	ShipTypeConst = 70
	CargoShipHazardCatX	ShipTypeConst = 71
	CargoShipHazardCatY	ShipTypeConst = 72
	CargoShipHazardCatZ	ShipTypeConst = 73
	CargoShipHazardCatOS	ShipTypeConst = 74
	CargoShipNoAdditionalInformation	ShipTypeConst = 79
	Tanker	ShipTypeConst = 80
	TankerHazardCatX	ShipTypeConst = 81
	TankerHazardCatY	ShipTypeConst = 82
	TankerHazardCatZ	ShipTypeConst = 83
	TankerHazardCatOS	ShipTypeConst = 84
	TankerNoAdditionalInformation	ShipTypeConst = 89
	Other	ShipTypeConst = 90
	OtherHazardCatX	ShipTypeConst = 91
	OtherHazardCatY	ShipTypeConst = 92
	OtherHazardCatZ	ShipTypeConst = 93
	OtherHazardCatOS	ShipTypeConst = 94
	OtherNoAdditionalInformation	ShipTypeConst = 99
)

func (e ShipTypeConst) GoString() string {return e.String() }
func (e ShipTypeConst) String() string {
	switch e {
		case 0:
			return "Unavailable"
		case 20:
			return "Wing In Ground"
		case 21:
			return "Wing In Ground (hazard cat X)"
		case 22:
			return "Wing In Ground (hazard cat Y)"
		case 23:
			return "Wing In Ground (hazard cat Z)"
		case 24:
			return "Wing In Ground (hazard cat OS)"
		case 29:
			return "Wing In Ground (no additional information)"
		case 30:
			return "Fishing"
		case 31:
			return "Towing"
		case 32:
			return "Towing exceeds 200m or wider than 25m"
		case 33:
			return "Engaged in dredging or underwater operations"
		case 34:
			return "Engaged in diving operations"
		case 35:
			return "Engaged in military operations"
		case 36:
			return "Sailing"
		case 37:
			return "Pleasure"
		case 40:
			return "High speed craft"
		case 41:
			return "High speed craft (hazard cat X)"
		case 42:
			return "High speed craft (hazard cat Y)"
		case 43:
			return "High speed craft (hazard cat Z)"
		case 44:
			return "High speed craft (hazard cat OS)"
		case 49:
			return "High speed craft (no additional information)"
		case 50:
			return "Pilot vessel"
		case 51:
			return "SAR"
		case 52:
			return "Tug"
		case 53:
			return "Port tender"
		case 54:
			return "Anti-pollution"
		case 55:
			return "Law enforcement"
		case 56:
			return "Spare"
		case 57:
			return "Spare #2"
		case 58:
			return "Medical"
		case 59:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 60:
			return "Passenger ship"
		case 61:
			return "Passenger ship (hazard cat X)"
		case 62:
			return "Passenger ship (hazard cat Y)"
		case 63:
			return "Passenger ship (hazard cat Z)"
		case 64:
			return "Passenger ship (hazard cat OS)"
		case 69:
			return "Passenger ship (no additional information)"
		case 70:
			return "Cargo ship"
		case 71:
			return "Cargo ship (hazard cat X)"
		case 72:
			return "Cargo ship (hazard cat Y)"
		case 73:
			return "Cargo ship (hazard cat Z)"
		case 74:
			return "Cargo ship (hazard cat OS)"
		case 79:
			return "Cargo ship (no additional information)"
		case 80:
			return "Tanker"
		case 81:
			return "Tanker (hazard cat X)"
		case 82:
			return "Tanker (hazard cat Y)"
		case 83:
			return "Tanker (hazard cat Z)"
		case 84:
			return "Tanker (hazard cat OS)"
		case 89:
			return "Tanker (no additional information)"
		case 90:
			return "Other"
		case 91:
			return "Other (hazard cat X)"
		case 92:
			return "Other (hazard cat Y)"
		case 93:
			return "Other (hazard cat Z)"
		case 94:
			return "Other (hazard cat OS)"
		case 99:
			return "Other (no additional information)"
	default:
		return fmt.Sprintf("%s(%d)", "ShipTypeConst", int(e))
	}
}

type DeviceClassConst uint8
const (
	ReservedFor2000Use	DeviceClassConst = 0
	SystemTools	DeviceClassConst = 10
	SafetySystems	DeviceClassConst = 20
	InternetworkDevice	DeviceClassConst = 25
	ElectricalDistribution	DeviceClassConst = 30
	ElectricalGeneration	DeviceClassConst = 35
	SteeringAndControlSurfaces	DeviceClassConst = 40
	Propulsion	DeviceClassConst = 50
	Navigation	DeviceClassConst = 60
	Communication	DeviceClassConst = 70
	SensorCommunicationInterface	DeviceClassConst = 75
	InstrumentationGeneralSystems	DeviceClassConst = 80
	ExternalEnvironment	DeviceClassConst = 85
	InternalEnvironment	DeviceClassConst = 90
	DeckCargoFishingEquipmentSystems	DeviceClassConst = 100
	Display	DeviceClassConst = 120
	Entertainment	DeviceClassConst = 125
)

func (e DeviceClassConst) GoString() string {return e.String() }
func (e DeviceClassConst) String() string {
	switch e {
		case 0:
			return "Reserved for 2000 Use"
		case 10:
			return "System tools"
		case 20:
			return "Safety systems"
		case 25:
			return "Internetwork device"
		case 30:
			return "Electrical Distribution"
		case 35:
			return "Electrical Generation"
		case 40:
			return "Steering and Control surfaces"
		case 50:
			return "Propulsion"
		case 60:
			return "Navigation"
		case 70:
			return "Communication"
		case 75:
			return "Sensor Communication Interface"
		case 80:
			return "Instrumentation/general systems"
		case 85:
			return "External Environment"
		case 90:
			return "Internal Environment"
		case 100:
			return "Deck + cargo + fishing equipment systems"
		case 120:
			return "Display"
		case 125:
			return "Entertainment"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceClassConst", int(e))
	}
}

type RepeatIndicatorConst uint8
const (
	Initial	RepeatIndicatorConst = 0
	FirstRetransmission	RepeatIndicatorConst = 1
	SecondRetransmission	RepeatIndicatorConst = 2
	FinalRetransmission	RepeatIndicatorConst = 3
)

func (e RepeatIndicatorConst) GoString() string {return e.String() }
func (e RepeatIndicatorConst) String() string {
	switch e {
		case 0:
			return "Initial"
		case 1:
			return "First retransmission"
		case 2:
			return "Second retransmission"
		case 3:
			return "Final retransmission"
	default:
		return fmt.Sprintf("%s(%d)", "RepeatIndicatorConst", int(e))
	}
}

type TxRxModeConst uint8
const (
	TxATxBRxARxB	TxRxModeConst = 0
	TxARxARxB	TxRxModeConst = 1
	TxBRxARxB	TxRxModeConst = 2
)

func (e TxRxModeConst) GoString() string {return e.String() }
func (e TxRxModeConst) String() string {
	switch e {
		case 0:
			return "Tx A/Tx B, Rx A/Rx B"
		case 1:
			return "Tx A, Rx A/Rx B"
		case 2:
			return "Tx B, Rx A/Rx B"
	default:
		return fmt.Sprintf("%s(%d)", "TxRxModeConst", int(e))
	}
}

type StationTypeConst uint8
const (
	AllTypesOfMobileStation	StationTypeConst = 0
	AllTypesOfClassBMobileStation	StationTypeConst = 2
	SARAirborneMobileStation	StationTypeConst = 3
	AtoNStation	StationTypeConst = 4
	ClassBCSShipborneMobileStation	StationTypeConst = 5
	InlandWaterways	StationTypeConst = 6
	RegionalUse7	StationTypeConst = 7
	RegionalUse8	StationTypeConst = 8
	RegionalUse9	StationTypeConst = 9
)

func (e StationTypeConst) GoString() string {return e.String() }
func (e StationTypeConst) String() string {
	switch e {
		case 0:
			return "All types of mobile station"
		case 2:
			return "All types of Class B mobile station"
		case 3:
			return "SAR airborne mobile station"
		case 4:
			return "AtoN station"
		case 5:
			return "Class B CS shipborne mobile station"
		case 6:
			return "Inland waterways"
		case 7:
			return "Regional use 7"
		case 8:
			return "Regional use 8"
		case 9:
			return "Regional use 9"
	default:
		return fmt.Sprintf("%s(%d)", "StationTypeConst", int(e))
	}
}

type ReportingIntervalConst uint8
const (
	AsGivenByTheAutonomousMode	ReportingIntervalConst = 0
	A10Min	ReportingIntervalConst = 1
	A6Min	ReportingIntervalConst = 2
	A3Min	ReportingIntervalConst = 3
	A1Min	ReportingIntervalConst = 4
	A30Sec	ReportingIntervalConst = 5
	A15Sec	ReportingIntervalConst = 6
	A10Sec	ReportingIntervalConst = 7
	A5Sec	ReportingIntervalConst = 8
	A2SecNotApplicableToClassBCS	ReportingIntervalConst = 9
	NextShorterReportingInterval	ReportingIntervalConst = 10
	NextLongerReportingInterval	ReportingIntervalConst = 11
)

func (e ReportingIntervalConst) GoString() string {return e.String() }
func (e ReportingIntervalConst) String() string {
	switch e {
		case 0:
			return "As given by the autonomous mode"
		case 1:
			return "A10 min"
		case 2:
			return "A6 min"
		case 3:
			return "A3 min"
		case 4:
			return "A1 min"
		case 5:
			return "A30 sec"
		case 6:
			return "A15 sec"
		case 7:
			return "A10 sec"
		case 8:
			return "A5 sec"
		case 9:
			return "A2 sec (not applicable to Class B CS)"
		case 10:
			return "Next shorter reporting interval"
		case 11:
			return "Next longer reporting interval"
	default:
		return fmt.Sprintf("%s(%d)", "ReportingIntervalConst", int(e))
	}
}

type AisTransceiverConst uint8
const (
	ChannelAVDLReception	AisTransceiverConst = 0
	ChannelBVDLReception	AisTransceiverConst = 1
	ChannelAVDLTransmission	AisTransceiverConst = 2
	ChannelBVDLTransmission	AisTransceiverConst = 3
	OwnInformationNotBroadcast	AisTransceiverConst = 4
	Reserved	AisTransceiverConst = 5
)

func (e AisTransceiverConst) GoString() string {return e.String() }
func (e AisTransceiverConst) String() string {
	switch e {
		case 0:
			return "Channel A VDL reception"
		case 1:
			return "Channel B VDL reception"
		case 2:
			return "Channel A VDL transmission"
		case 3:
			return "Channel B VDL transmission"
		case 4:
			return "Own information not broadcast"
		case 5:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisTransceiverConst", int(e))
	}
}

type AisAssignedModeConst uint8
const (
	AutonomousAndContinuous	AisAssignedModeConst = 0
	AssignedMode	AisAssignedModeConst = 1
)

func (e AisAssignedModeConst) GoString() string {return e.String() }
func (e AisAssignedModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous and continuous"
		case 1:
			return "Assigned mode"
	default:
		return fmt.Sprintf("%s(%d)", "AisAssignedModeConst", int(e))
	}
}

type AtonTypeConst uint8
const (
	DefaultTypeOfAtoNNotSpecified	AtonTypeConst = 0
	ReferencePoint	AtonTypeConst = 1
	RACON	AtonTypeConst = 2
	FixedStructureOffShore	AtonTypeConst = 3
	ReservedForFutureUse	AtonTypeConst = 4
	FixedLightWithoutSectors	AtonTypeConst = 5
	FixedLightWithSectors	AtonTypeConst = 6
	FixedLeadingLightFront	AtonTypeConst = 7
	FixedLeadingLightRear	AtonTypeConst = 8
	FixedBeaconCardinalN	AtonTypeConst = 9
	FixedBeaconCardinalE	AtonTypeConst = 10
	FixedBeaconCardinalS	AtonTypeConst = 11
	FixedBeaconCardinalW	AtonTypeConst = 12
	FixedBeaconPortHand	AtonTypeConst = 13
	FixedBeaconStarboardHand	AtonTypeConst = 14
	FixedBeaconPreferredChannelPortHand	AtonTypeConst = 15
	FixedBeaconPreferredChannelStarboardHand	AtonTypeConst = 16
	FixedBeaconIsolatedDanger	AtonTypeConst = 17
	FixedBeaconSafeWater	AtonTypeConst = 18
	FixedBeaconSpecialMark	AtonTypeConst = 19
	FloatingAtoNCardinalN	AtonTypeConst = 20
	FloatingAtoNCardinalE	AtonTypeConst = 21
	FloatingAtoNCardinalS	AtonTypeConst = 22
	FloatingAtoNCardinalW	AtonTypeConst = 23
	FloatingAtoNPortHandMark	AtonTypeConst = 24
	FloatingAtoNStarboardHandMark	AtonTypeConst = 25
	FloatingAtoNPreferredChannelPortHand	AtonTypeConst = 26
	FloatingAtoNPreferredChannelStarboardHand	AtonTypeConst = 27
	FloatingAtoNIsolatedDanger	AtonTypeConst = 28
	FloatingAtoNSafeWater	AtonTypeConst = 29
	FloatingAtoNSpecialMark	AtonTypeConst = 30
	FloatingAtoNLightVesselLANBYRigs	AtonTypeConst = 31
)

func (e AtonTypeConst) GoString() string {return e.String() }
func (e AtonTypeConst) String() string {
	switch e {
		case 0:
			return "Default: Type of AtoN not specified"
		case 1:
			return "Reference point"
		case 2:
			return "RACON"
		case 3:
			return "Fixed structure off-shore"
		case 4:
			return "Reserved for future use"
		case 5:
			return "Fixed light: without sectors"
		case 6:
			return "Fixed light: with sectors"
		case 7:
			return "Fixed leading light front"
		case 8:
			return "Fixed leading light rear"
		case 9:
			return "Fixed beacon: cardinal N"
		case 10:
			return "Fixed beacon: cardinal E"
		case 11:
			return "Fixed beacon: cardinal S"
		case 12:
			return "Fixed beacon: cardinal W"
		case 13:
			return "Fixed beacon: port hand"
		case 14:
			return "Fixed beacon: starboard hand"
		case 15:
			return "Fixed beacon: preferred channel port hand"
		case 16:
			return "Fixed beacon: preferred channel starboard hand"
		case 17:
			return "Fixed beacon: isolated danger"
		case 18:
			return "Fixed beacon: safe water"
		case 19:
			return "Fixed beacon: special mark"
		case 20:
			return "Floating AtoN: cardinal N"
		case 21:
			return "Floating AtoN: cardinal E"
		case 22:
			return "Floating AtoN: cardinal S"
		case 23:
			return "Floating AtoN: cardinal W"
		case 24:
			return "Floating AtoN: port hand mark"
		case 25:
			return "Floating AtoN: starboard hand mark"
		case 26:
			return "Floating AtoN: preferred channel port hand"
		case 27:
			return "Floating AtoN: preferred channel starboard hand"
		case 28:
			return "Floating AtoN: isolated danger"
		case 29:
			return "Floating AtoN: safe water"
		case 30:
			return "Floating AtoN: special mark"
		case 31:
			return "Floating AtoN: light vessel/LANBY/rigs"
	default:
		return fmt.Sprintf("%s(%d)", "AtonTypeConst", int(e))
	}
}

type AisSpecialManeuverConst uint8
const (
	NotAvailable	AisSpecialManeuverConst = 0
	NotEngagedInSpecialManeuver	AisSpecialManeuverConst = 1
	EngagedInSpecialManeuver	AisSpecialManeuverConst = 2
	Reserved2	AisSpecialManeuverConst = 3
)

func (e AisSpecialManeuverConst) GoString() string {return e.String() }
func (e AisSpecialManeuverConst) String() string {
	switch e {
		case 0:
			return "Not available"
		case 1:
			return "Not engaged in special maneuver"
		case 2:
			return "Engaged in special maneuver"
		case 3:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisSpecialManeuverConst", int(e))
	}
}

type PositionFixDeviceConst uint8
const (
	DefaultUndefined	PositionFixDeviceConst = 0
	GPS	PositionFixDeviceConst = 1
	GLONASS	PositionFixDeviceConst = 2
	CombinedGPSGLONASS	PositionFixDeviceConst = 3
	LoranC	PositionFixDeviceConst = 4
	Chayka	PositionFixDeviceConst = 5
	IntegratedNavigationSystem	PositionFixDeviceConst = 6
	Surveyed	PositionFixDeviceConst = 7
	Galileo	PositionFixDeviceConst = 8
	InternalGNSS	PositionFixDeviceConst = 15
)

func (e PositionFixDeviceConst) GoString() string {return e.String() }
func (e PositionFixDeviceConst) String() string {
	switch e {
		case 0:
			return "Default: undefined"
		case 1:
			return "GPS"
		case 2:
			return "GLONASS"
		case 3:
			return "Combined GPS/GLONASS"
		case 4:
			return "Loran-C"
		case 5:
			return "Chayka"
		case 6:
			return "Integrated navigation system"
		case 7:
			return "Surveyed"
		case 8:
			return "Galileo"
		case 15:
			return "Internal GNSS"
	default:
		return fmt.Sprintf("%s(%d)", "PositionFixDeviceConst", int(e))
	}
}

type GnsConst uint8
const (
	GPS2	GnsConst = 0
	GLONASS2	GnsConst = 1
	GPSGLONASS	GnsConst = 2
	GPSSBASWAAS	GnsConst = 3
	GPSSBASWAASGLONASS	GnsConst = 4
	Chayka2	GnsConst = 5
	Integrated	GnsConst = 6
	Surveyed2	GnsConst = 7
	Galileo2	GnsConst = 8
)

func (e GnsConst) GoString() string {return e.String() }
func (e GnsConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "GPS+GLONASS"
		case 3:
			return "GPS+SBAS/WAAS"
		case 4:
			return "GPS+SBAS/WAAS+GLONASS"
		case 5:
			return "Chayka"
		case 6:
			return "integrated"
		case 7:
			return "surveyed"
		case 8:
			return "Galileo"
	default:
		return fmt.Sprintf("%s(%d)", "GnsConst", int(e))
	}
}

type EngineInstanceConst uint8
const (
	SingleEngineOrDualEnginePort	EngineInstanceConst = 0
	DualEngineStarboard	EngineInstanceConst = 1
)

func (e EngineInstanceConst) GoString() string {return e.String() }
func (e EngineInstanceConst) String() string {
	switch e {
		case 0:
			return "Single Engine or Dual Engine Port"
		case 1:
			return "Dual Engine Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "EngineInstanceConst", int(e))
	}
}

type GearStatusConst uint8
const (
	Forward	GearStatusConst = 0
	Neutral	GearStatusConst = 1
	Reverse	GearStatusConst = 2
)

func (e GearStatusConst) GoString() string {return e.String() }
func (e GearStatusConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Neutral"
		case 2:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "GearStatusConst", int(e))
	}
}

type DirectionConst uint8
const (
	Forward2	DirectionConst = 0
	Reverse2	DirectionConst = 1
)

func (e DirectionConst) GoString() string {return e.String() }
func (e DirectionConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionConst", int(e))
	}
}

type PositionAccuracyConst uint8
const (
	Low	PositionAccuracyConst = 0
	High	PositionAccuracyConst = 1
)

func (e PositionAccuracyConst) GoString() string {return e.String() }
func (e PositionAccuracyConst) String() string {
	switch e {
		case 0:
			return "Low"
		case 1:
			return "High"
	default:
		return fmt.Sprintf("%s(%d)", "PositionAccuracyConst", int(e))
	}
}

type RaimFlagConst uint8
const (
	NotInUse	RaimFlagConst = 0
	InUse	RaimFlagConst = 1
)

func (e RaimFlagConst) GoString() string {return e.String() }
func (e RaimFlagConst) String() string {
	switch e {
		case 0:
			return "not in use"
		case 1:
			return "in use"
	default:
		return fmt.Sprintf("%s(%d)", "RaimFlagConst", int(e))
	}
}

type TimeStampConst uint8
const (
	NotAvailable2	TimeStampConst = 60
	ManualInputMode	TimeStampConst = 61
	DeadReckoningMode	TimeStampConst = 62
	PositioningSystemIsInoperative	TimeStampConst = 63
)

func (e TimeStampConst) GoString() string {return e.String() }
func (e TimeStampConst) String() string {
	switch e {
		case 60:
			return "Not available"
		case 61:
			return "Manual input mode"
		case 62:
			return "Dead reckoning mode"
		case 63:
			return "Positioning system is inoperative"
	default:
		return fmt.Sprintf("%s(%d)", "TimeStampConst", int(e))
	}
}

type GnsMethodConst uint8
const (
	NoGNSS	GnsMethodConst = 0
	GNSSFix	GnsMethodConst = 1
	DGNSSFix	GnsMethodConst = 2
	PreciseGNSS	GnsMethodConst = 3
	RTKFixedInteger	GnsMethodConst = 4
	RTKFloat	GnsMethodConst = 5
	EstimatedDRMode	GnsMethodConst = 6
	ManualInput	GnsMethodConst = 7
	SimulateMode	GnsMethodConst = 8
)

func (e GnsMethodConst) GoString() string {return e.String() }
func (e GnsMethodConst) String() string {
	switch e {
		case 0:
			return "no GNSS"
		case 1:
			return "GNSS fix"
		case 2:
			return "DGNSS fix"
		case 3:
			return "Precise GNSS"
		case 4:
			return "RTK Fixed Integer"
		case 5:
			return "RTK float"
		case 6:
			return "Estimated (DR) mode"
		case 7:
			return "Manual Input"
		case 8:
			return "Simulate mode"
	default:
		return fmt.Sprintf("%s(%d)", "GnsMethodConst", int(e))
	}
}

type GnsIntegrityConst uint8
const (
	NoIntegrityChecking	GnsIntegrityConst = 0
	Safe	GnsIntegrityConst = 1
	Caution	GnsIntegrityConst = 2
)

func (e GnsIntegrityConst) GoString() string {return e.String() }
func (e GnsIntegrityConst) String() string {
	switch e {
		case 0:
			return "No integrity checking"
		case 1:
			return "Safe"
		case 2:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "GnsIntegrityConst", int(e))
	}
}

type SystemTimeConst uint8
const (
	GPS3	SystemTimeConst = 0
	GLONASS3	SystemTimeConst = 1
	RadioStation	SystemTimeConst = 2
	LocalCesiumClock	SystemTimeConst = 3
	LocalRubidiumClock	SystemTimeConst = 4
	LocalCrystalClock	SystemTimeConst = 5
)

func (e SystemTimeConst) GoString() string {return e.String() }
func (e SystemTimeConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "Radio Station"
		case 3:
			return "Local Cesium clock"
		case 4:
			return "Local Rubidium clock"
		case 5:
			return "Local Crystal clock"
	default:
		return fmt.Sprintf("%s(%d)", "SystemTimeConst", int(e))
	}
}

type MagneticVariationConst uint8
const (
	Manual	MagneticVariationConst = 0
	AutomaticChart	MagneticVariationConst = 1
	AutomaticTable	MagneticVariationConst = 2
	AutomaticCalculation	MagneticVariationConst = 3
	WMM2000	MagneticVariationConst = 4
	WMM2005	MagneticVariationConst = 5
	WMM2010	MagneticVariationConst = 6
	WMM2015	MagneticVariationConst = 7
	WMM2020	MagneticVariationConst = 8
)

func (e MagneticVariationConst) GoString() string {return e.String() }
func (e MagneticVariationConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic Chart"
		case 2:
			return "Automatic Table"
		case 3:
			return "Automatic Calculation"
		case 4:
			return "WMM 2000"
		case 5:
			return "WMM 2005"
		case 6:
			return "WMM 2010"
		case 7:
			return "WMM 2015"
		case 8:
			return "WMM 2020"
	default:
		return fmt.Sprintf("%s(%d)", "MagneticVariationConst", int(e))
	}
}

type ResidualModeConst uint8
const (
	Autonomous	ResidualModeConst = 0
	DifferentialEnhanced	ResidualModeConst = 1
	Estimated	ResidualModeConst = 2
	Simulator	ResidualModeConst = 3
	Manual2	ResidualModeConst = 4
)

func (e ResidualModeConst) GoString() string {return e.String() }
func (e ResidualModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Differential enhanced"
		case 2:
			return "Estimated"
		case 3:
			return "Simulator"
		case 4:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "ResidualModeConst", int(e))
	}
}

type WindReferenceConst uint8
const (
	TrueGroundReferencedToNorth	WindReferenceConst = 0
	MagneticGroundReferencedToMagneticNorth	WindReferenceConst = 1
	Apparent	WindReferenceConst = 2
	TrueBoatReferenced	WindReferenceConst = 3
	TrueWaterReferenced	WindReferenceConst = 4
)

func (e WindReferenceConst) GoString() string {return e.String() }
func (e WindReferenceConst) String() string {
	switch e {
		case 0:
			return "True (ground referenced to North)"
		case 1:
			return "Magnetic (ground referenced to Magnetic North)"
		case 2:
			return "Apparent"
		case 3:
			return "True (boat referenced)"
		case 4:
			return "True (water referenced)"
	default:
		return fmt.Sprintf("%s(%d)", "WindReferenceConst", int(e))
	}
}

type WaterReferenceConst uint8
const (
	PaddleWheel	WaterReferenceConst = 0
	PitotTube	WaterReferenceConst = 1
	Doppler	WaterReferenceConst = 2
	CorrelationUltraSound	WaterReferenceConst = 3
	ElectroMagnetic	WaterReferenceConst = 4
)

func (e WaterReferenceConst) GoString() string {return e.String() }
func (e WaterReferenceConst) String() string {
	switch e {
		case 0:
			return "Paddle wheel"
		case 1:
			return "Pitot tube"
		case 2:
			return "Doppler"
		case 3:
			return "Correlation (ultra sound)"
		case 4:
			return "Electro Magnetic"
	default:
		return fmt.Sprintf("%s(%d)", "WaterReferenceConst", int(e))
	}
}

type YesNoConst uint8
const (
	No	YesNoConst = 0
	Yes	YesNoConst = 1
)

func (e YesNoConst) GoString() string {return e.String() }
func (e YesNoConst) String() string {
	switch e {
		case 0:
			return "No"
		case 1:
			return "Yes"
	default:
		return fmt.Sprintf("%s(%d)", "YesNoConst", int(e))
	}
}

type OkWarningConst uint8
const (
	OK	OkWarningConst = 0
	Warning	OkWarningConst = 1
)

func (e OkWarningConst) GoString() string {return e.String() }
func (e OkWarningConst) String() string {
	switch e {
		case 0:
			return "OK"
		case 1:
			return "Warning"
	default:
		return fmt.Sprintf("%s(%d)", "OkWarningConst", int(e))
	}
}

type OffOnConst uint8
const (
	Off	OffOnConst = 0
	On	OffOnConst = 1
)

func (e OffOnConst) GoString() string {return e.String() }
func (e OffOnConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "On"
	default:
		return fmt.Sprintf("%s(%d)", "OffOnConst", int(e))
	}
}

type DirectionReferenceConst uint8
const (
	True	DirectionReferenceConst = 0
	Magnetic	DirectionReferenceConst = 1
	Error	DirectionReferenceConst = 2
)

func (e DirectionReferenceConst) GoString() string {return e.String() }
func (e DirectionReferenceConst) String() string {
	switch e {
		case 0:
			return "True"
		case 1:
			return "Magnetic"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionReferenceConst", int(e))
	}
}

type DirectionRudderConst uint8
const (
	NoOrder	DirectionRudderConst = 0
	MoveToStarboard	DirectionRudderConst = 1
	MoveToPort	DirectionRudderConst = 2
)

func (e DirectionRudderConst) GoString() string {return e.String() }
func (e DirectionRudderConst) String() string {
	switch e {
		case 0:
			return "No Order"
		case 1:
			return "Move to starboard"
		case 2:
			return "Move to port"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionRudderConst", int(e))
	}
}

type NavStatusConst uint8
const (
	UnderWayUsingEngine	NavStatusConst = 0
	AtAnchor	NavStatusConst = 1
	NotUnderCommand	NavStatusConst = 2
	RestrictedManeuverability	NavStatusConst = 3
	ConstrainedByHerDraught	NavStatusConst = 4
	Moored	NavStatusConst = 5
	Aground	NavStatusConst = 6
	EngagedInFishing	NavStatusConst = 7
	UnderWaySailing	NavStatusConst = 8
	HazardousMaterialHighSpeed	NavStatusConst = 9
	HazardousMaterialWingInGround	NavStatusConst = 10
	PowerDrivenVesslTowingAstern	NavStatusConst = 11
	PowerDrivenVesslPushingAheadOrTowingAlongside	NavStatusConst = 12
	AISSART	NavStatusConst = 14
)

func (e NavStatusConst) GoString() string {return e.String() }
func (e NavStatusConst) String() string {
	switch e {
		case 0:
			return "Under way using engine"
		case 1:
			return "At anchor"
		case 2:
			return "Not under command"
		case 3:
			return "Restricted maneuverability"
		case 4:
			return "Constrained by her draught"
		case 5:
			return "Moored"
		case 6:
			return "Aground"
		case 7:
			return "Engaged in Fishing"
		case 8:
			return "Under way sailing"
		case 9:
			return "Hazardous material - High Speed"
		case 10:
			return "Hazardous material - Wing in Ground"
		case 11:
			return "Power-driven vessl towing astern"
		case 12:
			return "Power-driven vessl pushing ahead or towing alongside"
		case 14:
			return "AIS-SART"
	default:
		return fmt.Sprintf("%s(%d)", "NavStatusConst", int(e))
	}
}

type PowerFactorConst uint8
const (
	Leading	PowerFactorConst = 0
	Lagging	PowerFactorConst = 1
	Error2	PowerFactorConst = 2
)

func (e PowerFactorConst) GoString() string {return e.String() }
func (e PowerFactorConst) String() string {
	switch e {
		case 0:
			return "Leading"
		case 1:
			return "Lagging"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "PowerFactorConst", int(e))
	}
}

type TemperatureSourceConst uint8
const (
	SeaTemperature	TemperatureSourceConst = 0
	OutsideTemperature	TemperatureSourceConst = 1
	InsideTemperature	TemperatureSourceConst = 2
	EngineRoomTemperature	TemperatureSourceConst = 3
	MainCabinTemperature	TemperatureSourceConst = 4
	LiveWellTemperature	TemperatureSourceConst = 5
	BaitWellTemperature	TemperatureSourceConst = 6
	RefrigerationTemperature	TemperatureSourceConst = 7
	HeatingSystemTemperature	TemperatureSourceConst = 8
	DewPointTemperature	TemperatureSourceConst = 9
	ApparentWindChillTemperature	TemperatureSourceConst = 10
	TheoreticalWindChillTemperature	TemperatureSourceConst = 11
	HeatIndexTemperature	TemperatureSourceConst = 12
	FreezerTemperature	TemperatureSourceConst = 13
	ExhaustGasTemperature	TemperatureSourceConst = 14
	ShaftSealTemperature	TemperatureSourceConst = 15
)

func (e TemperatureSourceConst) GoString() string {return e.String() }
func (e TemperatureSourceConst) String() string {
	switch e {
		case 0:
			return "Sea Temperature"
		case 1:
			return "Outside Temperature"
		case 2:
			return "Inside Temperature"
		case 3:
			return "Engine Room Temperature"
		case 4:
			return "Main Cabin Temperature"
		case 5:
			return "Live Well Temperature"
		case 6:
			return "Bait Well Temperature"
		case 7:
			return "Refrigeration Temperature"
		case 8:
			return "Heating System Temperature"
		case 9:
			return "Dew Point Temperature"
		case 10:
			return "Apparent Wind Chill Temperature"
		case 11:
			return "Theoretical Wind Chill Temperature"
		case 12:
			return "Heat Index Temperature"
		case 13:
			return "Freezer Temperature"
		case 14:
			return "Exhaust Gas Temperature"
		case 15:
			return "Shaft Seal Temperature"
	default:
		return fmt.Sprintf("%s(%d)", "TemperatureSourceConst", int(e))
	}
}

type HumiditySourceConst uint8
const (
	Inside	HumiditySourceConst = 0
	Outside	HumiditySourceConst = 1
)

func (e HumiditySourceConst) GoString() string {return e.String() }
func (e HumiditySourceConst) String() string {
	switch e {
		case 0:
			return "Inside"
		case 1:
			return "Outside"
	default:
		return fmt.Sprintf("%s(%d)", "HumiditySourceConst", int(e))
	}
}

type PressureSourceConst uint8
const (
	Atmospheric	PressureSourceConst = 0
	Water	PressureSourceConst = 1
	Steam	PressureSourceConst = 2
	CompressedAir	PressureSourceConst = 3
	Hydraulic	PressureSourceConst = 4
	Filter	PressureSourceConst = 5
	AltimeterSetting	PressureSourceConst = 6
	Oil	PressureSourceConst = 7
	Fuel	PressureSourceConst = 8
)

func (e PressureSourceConst) GoString() string {return e.String() }
func (e PressureSourceConst) String() string {
	switch e {
		case 0:
			return "Atmospheric"
		case 1:
			return "Water"
		case 2:
			return "Steam"
		case 3:
			return "Compressed Air"
		case 4:
			return "Hydraulic"
		case 5:
			return "Filter"
		case 6:
			return "AltimeterSetting"
		case 7:
			return "Oil"
		case 8:
			return "Fuel"
	default:
		return fmt.Sprintf("%s(%d)", "PressureSourceConst", int(e))
	}
}

type DscFormatConst uint8
const (
	GeographicalArea	DscFormatConst = 102
	Distress	DscFormatConst = 112
	CommonInterest	DscFormatConst = 114
	AllShips	DscFormatConst = 116
	IndividualStations	DscFormatConst = 120
	NonCallingPurpose	DscFormatConst = 121
	IndividualStationAutomatic	DscFormatConst = 123
)

func (e DscFormatConst) GoString() string {return e.String() }
func (e DscFormatConst) String() string {
	switch e {
		case 102:
			return "Geographical area"
		case 112:
			return "Distress"
		case 114:
			return "Common interest"
		case 116:
			return "All ships"
		case 120:
			return "Individual stations"
		case 121:
			return "Non-calling purpose"
		case 123:
			return "Individual station automatic"
	default:
		return fmt.Sprintf("%s(%d)", "DscFormatConst", int(e))
	}
}

type DscCategoryConst uint8
const (
	Routine	DscCategoryConst = 100
	Safety	DscCategoryConst = 108
	Urgency	DscCategoryConst = 110
	Distress2	DscCategoryConst = 112
)

func (e DscCategoryConst) GoString() string {return e.String() }
func (e DscCategoryConst) String() string {
	switch e {
		case 100:
			return "Routine"
		case 108:
			return "Safety"
		case 110:
			return "Urgency"
		case 112:
			return "Distress"
	default:
		return fmt.Sprintf("%s(%d)", "DscCategoryConst", int(e))
	}
}

type DscNatureConst uint8
const (
	Fire	DscNatureConst = 100
	Flooding	DscNatureConst = 101
	Collision	DscNatureConst = 102
	Grounding	DscNatureConst = 103
	Listing	DscNatureConst = 104
	Sinking	DscNatureConst = 105
	DisabledAndAdrift	DscNatureConst = 106
	Undesignated	DscNatureConst = 107
	AbandoningShip	DscNatureConst = 108
	Piracy	DscNatureConst = 109
	ManOverboard	DscNatureConst = 110
	EPIRBEmission	DscNatureConst = 112
)

func (e DscNatureConst) GoString() string {return e.String() }
func (e DscNatureConst) String() string {
	switch e {
		case 100:
			return "Fire"
		case 101:
			return "Flooding"
		case 102:
			return "Collision"
		case 103:
			return "Grounding"
		case 104:
			return "Listing"
		case 105:
			return "Sinking"
		case 106:
			return "Disabled and adrift"
		case 107:
			return "Undesignated"
		case 108:
			return "Abandoning ship"
		case 109:
			return "Piracy"
		case 110:
			return "Man overboard"
		case 112:
			return "EPIRB emission"
	default:
		return fmt.Sprintf("%s(%d)", "DscNatureConst", int(e))
	}
}

type DscFirstTelecommandConst uint8
const (
	F3EG3EAllModesTP	DscFirstTelecommandConst = 100
	F3EG3EDuplexTP	DscFirstTelecommandConst = 101
	Polling	DscFirstTelecommandConst = 103
	UnableToComply	DscFirstTelecommandConst = 104
	EndOfCall	DscFirstTelecommandConst = 105
	Data	DscFirstTelecommandConst = 106
	J3ETP	DscFirstTelecommandConst = 109
	DistressAcknowledgement	DscFirstTelecommandConst = 110
	DistressRelay	DscFirstTelecommandConst = 112
	F1BJ2BTTYFEC	DscFirstTelecommandConst = 113
	F1BJ2BTTYARQ	DscFirstTelecommandConst = 115
	Test	DscFirstTelecommandConst = 118
	ShipPositionOrLocationRegistrationUpdating	DscFirstTelecommandConst = 121
	NoInformation	DscFirstTelecommandConst = 126
)

func (e DscFirstTelecommandConst) GoString() string {return e.String() }
func (e DscFirstTelecommandConst) String() string {
	switch e {
		case 100:
			return "F3E/G3E All modes TP"
		case 101:
			return "F3E/G3E duplex TP"
		case 103:
			return "Polling"
		case 104:
			return "Unable to comply"
		case 105:
			return "End of call"
		case 106:
			return "Data"
		case 109:
			return "J3E TP"
		case 110:
			return "Distress acknowledgement"
		case 112:
			return "Distress relay"
		case 113:
			return "F1B/J2B TTY-FEC"
		case 115:
			return "F1B/J2B TTY-ARQ"
		case 118:
			return "Test"
		case 121:
			return "Ship position or location registration updating"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscFirstTelecommandConst", int(e))
	}
}

type DscSecondTelecommandConst uint8
const (
	NoReasonGiven	DscSecondTelecommandConst = 100
	CongestionAtMSC	DscSecondTelecommandConst = 101
	Busy	DscSecondTelecommandConst = 102
	QueueIndication	DscSecondTelecommandConst = 103
	StationBarred	DscSecondTelecommandConst = 104
	NoOperatorAvailable	DscSecondTelecommandConst = 105
	OperatorTemporarilyUnavailable	DscSecondTelecommandConst = 106
	EquipmentDisabled	DscSecondTelecommandConst = 107
	UnableToUseProposedChannel	DscSecondTelecommandConst = 108
	UnableToUseProposedMode	DscSecondTelecommandConst = 109
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict2	DscSecondTelecommandConst = 110
	MedicalTransports	DscSecondTelecommandConst = 111
	PayPhonePublicCallOffice	DscSecondTelecommandConst = 112
	FaxData	DscSecondTelecommandConst = 113
	NoInformation2	DscSecondTelecommandConst = 126
)

func (e DscSecondTelecommandConst) GoString() string {return e.String() }
func (e DscSecondTelecommandConst) String() string {
	switch e {
		case 100:
			return "No reason given"
		case 101:
			return "Congestion at MSC"
		case 102:
			return "Busy"
		case 103:
			return "Queue indication"
		case 104:
			return "Station barred"
		case 105:
			return "No operator available"
		case 106:
			return "Operator temporarily unavailable"
		case 107:
			return "Equipment disabled"
		case 108:
			return "Unable to use proposed channel"
		case 109:
			return "Unable to use proposed mode"
		case 110:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 111:
			return "Medical transports"
		case 112:
			return "Pay phone/public call office"
		case 113:
			return "Fax/data"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscSecondTelecommandConst", int(e))
	}
}

type DscExpansionDataConst uint8
const (
	EnhancedPosition	DscExpansionDataConst = 100
	SourceAndDatumOfPosition	DscExpansionDataConst = 101
	SOG	DscExpansionDataConst = 102
	COG	DscExpansionDataConst = 103
	AdditionalStationIdentification	DscExpansionDataConst = 104
	EnhancedGeographicArea	DscExpansionDataConst = 105
	NumberOfPersonsOnBoard	DscExpansionDataConst = 106
)

func (e DscExpansionDataConst) GoString() string {return e.String() }
func (e DscExpansionDataConst) String() string {
	switch e {
		case 100:
			return "Enhanced position"
		case 101:
			return "Source and datum of position"
		case 102:
			return "SOG"
		case 103:
			return "COG"
		case 104:
			return "Additional station identification"
		case 105:
			return "Enhanced geographic area"
		case 106:
			return "Number of persons on board"
	default:
		return fmt.Sprintf("%s(%d)", "DscExpansionDataConst", int(e))
	}
}

type SeatalkAlarmStatusConst uint8
const (
	AlarmConditionNotMet	SeatalkAlarmStatusConst = 0
	AlarmConditionMetAndNotSilenced	SeatalkAlarmStatusConst = 1
	AlarmConditionMetAndSilenced	SeatalkAlarmStatusConst = 2
)

func (e SeatalkAlarmStatusConst) GoString() string {return e.String() }
func (e SeatalkAlarmStatusConst) String() string {
	switch e {
		case 0:
			return "Alarm condition not met"
		case 1:
			return "Alarm condition met and not silenced"
		case 2:
			return "Alarm condition met and silenced"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmStatusConst", int(e))
	}
}

type SeatalkAlarmIdConst uint8
const (
	NoAlarm	SeatalkAlarmIdConst = 0
	ShallowDepth	SeatalkAlarmIdConst = 1
	DeepDepth	SeatalkAlarmIdConst = 2
	ShallowAnchor	SeatalkAlarmIdConst = 3
	DeepAnchor	SeatalkAlarmIdConst = 4
	OffCourse	SeatalkAlarmIdConst = 5
	AWAHigh	SeatalkAlarmIdConst = 6
	AWALow	SeatalkAlarmIdConst = 7
	AWSHigh	SeatalkAlarmIdConst = 8
	AWSLow	SeatalkAlarmIdConst = 9
	TWAHigh	SeatalkAlarmIdConst = 10
	TWALow	SeatalkAlarmIdConst = 11
	TWSHigh	SeatalkAlarmIdConst = 12
	TWSLow	SeatalkAlarmIdConst = 13
	WPArrival	SeatalkAlarmIdConst = 14
	BoatSpeedHigh	SeatalkAlarmIdConst = 15
	BoatSpeedLow	SeatalkAlarmIdConst = 16
	SeaTemperatureHigh	SeatalkAlarmIdConst = 17
	SeaTemperatureLow	SeatalkAlarmIdConst = 18
	PilotWatch	SeatalkAlarmIdConst = 19
	PilotOffCourse	SeatalkAlarmIdConst = 20
	PilotWindShift	SeatalkAlarmIdConst = 21
	PilotLowBattery	SeatalkAlarmIdConst = 22
	PilotLastMinuteOfWatch	SeatalkAlarmIdConst = 23
	PilotNoNMEAData	SeatalkAlarmIdConst = 24
	PilotLargeXTE	SeatalkAlarmIdConst = 25
	PilotNMEADataError	SeatalkAlarmIdConst = 26
	PilotCUDisconnected	SeatalkAlarmIdConst = 27
	PilotAutoRelease	SeatalkAlarmIdConst = 28
	PilotWayPointAdvance	SeatalkAlarmIdConst = 29
	PilotDriveStopped	SeatalkAlarmIdConst = 30
	PilotTypeUnspecified	SeatalkAlarmIdConst = 31
	PilotCalibrationRequired	SeatalkAlarmIdConst = 32
	PilotLastHeading	SeatalkAlarmIdConst = 33
	PilotNoPilot	SeatalkAlarmIdConst = 34
	PilotRouteComplete	SeatalkAlarmIdConst = 35
	PilotVariableText	SeatalkAlarmIdConst = 36
	GPSFailure	SeatalkAlarmIdConst = 37
	MOB	SeatalkAlarmIdConst = 38
	Seatalk1Anchor	SeatalkAlarmIdConst = 39
	PilotSwappedMotorPower	SeatalkAlarmIdConst = 40
	PilotStandbyTooFastToFish	SeatalkAlarmIdConst = 41
	PilotNoGPSFix	SeatalkAlarmIdConst = 42
	PilotNoGPSCOG	SeatalkAlarmIdConst = 43
	PilotStartUp	SeatalkAlarmIdConst = 44
	PilotTooSlow	SeatalkAlarmIdConst = 45
	PilotNoCompass	SeatalkAlarmIdConst = 46
	PilotRateGyroFault	SeatalkAlarmIdConst = 47
	PilotCurrentLimit	SeatalkAlarmIdConst = 48
	PilotWayPointAdvancePort	SeatalkAlarmIdConst = 49
	PilotWayPointAdvanceStbd	SeatalkAlarmIdConst = 50
	PilotNoWindData	SeatalkAlarmIdConst = 51
	PilotNoSpeedData	SeatalkAlarmIdConst = 52
	PilotSeatalkFail1	SeatalkAlarmIdConst = 53
	PilotSeatalkFail2	SeatalkAlarmIdConst = 54
	PilotWarningTooFastToFish	SeatalkAlarmIdConst = 55
	PilotAutoDocksideFail	SeatalkAlarmIdConst = 56
	PilotTurnTooFast	SeatalkAlarmIdConst = 57
	PilotNoNavData	SeatalkAlarmIdConst = 58
	PilotLostWaypointData	SeatalkAlarmIdConst = 59
	PilotEEPROMCorrupt	SeatalkAlarmIdConst = 60
	PilotRudderFeedbackFail	SeatalkAlarmIdConst = 61
	PilotAutolearnFail1	SeatalkAlarmIdConst = 62
	PilotAutolearnFail2	SeatalkAlarmIdConst = 63
	PilotAutolearnFail3	SeatalkAlarmIdConst = 64
	PilotAutolearnFail4	SeatalkAlarmIdConst = 65
	PilotAutolearnFail5	SeatalkAlarmIdConst = 66
	PilotAutolearnFail6	SeatalkAlarmIdConst = 67
	PilotWarningCalRequired	SeatalkAlarmIdConst = 68
	PilotWarningOffCourse	SeatalkAlarmIdConst = 69
	PilotWarningXTE	SeatalkAlarmIdConst = 70
	PilotWarningWindShift	SeatalkAlarmIdConst = 71
	PilotWarningDriveShort	SeatalkAlarmIdConst = 72
	PilotWarningClutchShort	SeatalkAlarmIdConst = 73
	PilotWarningSolenoidShort	SeatalkAlarmIdConst = 74
	PilotJoystickFault	SeatalkAlarmIdConst = 75
	PilotNoJoystickData	SeatalkAlarmIdConst = 76
	NotAssigned	SeatalkAlarmIdConst = 77
	NotAssigned2	SeatalkAlarmIdConst = 78
	NotAssigned3	SeatalkAlarmIdConst = 79
	PilotInvalidCommand	SeatalkAlarmIdConst = 80
	AISTXMalfunction	SeatalkAlarmIdConst = 81
	AISAntennaVSWRFault	SeatalkAlarmIdConst = 82
	AISRxChannel1Malfunction	SeatalkAlarmIdConst = 83
	AISRxChannel2Malfunction	SeatalkAlarmIdConst = 84
	AISNoSensorPositionInUse	SeatalkAlarmIdConst = 85
	AISNoValidSOGInformation	SeatalkAlarmIdConst = 86
	AISNoValidCOGInformation	SeatalkAlarmIdConst = 87
	AIS12VAlarm	SeatalkAlarmIdConst = 88
	AIS6VAlarm	SeatalkAlarmIdConst = 89
	AISNoiseThresholdExceededChannelA	SeatalkAlarmIdConst = 90
	AISNoiseThresholdExceededChannelB	SeatalkAlarmIdConst = 91
	AISTransmitterPAFault	SeatalkAlarmIdConst = 92
	AIS3V3Alarm	SeatalkAlarmIdConst = 93
	AISRxChannel70Malfunction	SeatalkAlarmIdConst = 94
	AISHeadingLostInvalid	SeatalkAlarmIdConst = 95
	AISInternalGPSLost	SeatalkAlarmIdConst = 96
	AISNoSensorPosition	SeatalkAlarmIdConst = 97
	AISLockFailure	SeatalkAlarmIdConst = 98
	AISInternalGGATimeout	SeatalkAlarmIdConst = 99
	AISProtocolStackRestart	SeatalkAlarmIdConst = 100
	PilotNoIPSCommunications	SeatalkAlarmIdConst = 101
	PilotPowerOnOrSleepSwitchResetWhileEngaged	SeatalkAlarmIdConst = 102
	PilotUnexpectedResetWhileEngaged	SeatalkAlarmIdConst = 103
	AISDangerousTarget	SeatalkAlarmIdConst = 104
	AISLostTarget	SeatalkAlarmIdConst = 105
	AISSafetyRelatedMessageUsedToSilence	SeatalkAlarmIdConst = 106
	AISConnectionLost	SeatalkAlarmIdConst = 107
	NoFix	SeatalkAlarmIdConst = 108
)

func (e SeatalkAlarmIdConst) GoString() string {return e.String() }
func (e SeatalkAlarmIdConst) String() string {
	switch e {
		case 0:
			return "No Alarm"
		case 1:
			return "Shallow Depth"
		case 2:
			return "Deep Depth"
		case 3:
			return "Shallow Anchor"
		case 4:
			return "Deep Anchor"
		case 5:
			return "Off Course"
		case 6:
			return "AWA High"
		case 7:
			return "AWA Low"
		case 8:
			return "AWS High"
		case 9:
			return "AWS Low"
		case 10:
			return "TWA High"
		case 11:
			return "TWA Low"
		case 12:
			return "TWS High"
		case 13:
			return "TWS Low"
		case 14:
			return "WP Arrival"
		case 15:
			return "Boat Speed High"
		case 16:
			return "Boat Speed Low"
		case 17:
			return "Sea Temperature High"
		case 18:
			return "Sea Temperature Low"
		case 19:
			return "Pilot Watch"
		case 20:
			return "Pilot Off Course"
		case 21:
			return "Pilot Wind Shift"
		case 22:
			return "Pilot Low Battery"
		case 23:
			return "Pilot Last Minute Of Watch"
		case 24:
			return "Pilot No NMEA Data"
		case 25:
			return "Pilot Large XTE"
		case 26:
			return "Pilot NMEA DataError"
		case 27:
			return "Pilot CU Disconnected"
		case 28:
			return "Pilot Auto Release"
		case 29:
			return "Pilot Way Point Advance"
		case 30:
			return "Pilot Drive Stopped"
		case 31:
			return "Pilot Type Unspecified"
		case 32:
			return "Pilot Calibration Required"
		case 33:
			return "Pilot Last Heading"
		case 34:
			return "Pilot No Pilot"
		case 35:
			return "Pilot Route Complete"
		case 36:
			return "Pilot Variable Text"
		case 37:
			return "GPS Failure"
		case 38:
			return "MOB"
		case 39:
			return "Seatalk1 Anchor"
		case 40:
			return "Pilot Swapped Motor Power"
		case 41:
			return "Pilot Standby Too Fast To Fish"
		case 42:
			return "Pilot No GPS Fix"
		case 43:
			return "Pilot No GPS COG"
		case 44:
			return "Pilot Start Up"
		case 45:
			return "Pilot Too Slow"
		case 46:
			return "Pilot No Compass"
		case 47:
			return "Pilot Rate Gyro Fault"
		case 48:
			return "Pilot Current Limit"
		case 49:
			return "Pilot Way Point Advance Port"
		case 50:
			return "Pilot Way Point Advance Stbd"
		case 51:
			return "Pilot No Wind Data"
		case 52:
			return "Pilot No Speed Data"
		case 53:
			return "Pilot Seatalk Fail1"
		case 54:
			return "Pilot Seatalk Fail2"
		case 55:
			return "Pilot Warning Too Fast To Fish"
		case 56:
			return "Pilot Auto Dockside Fail"
		case 57:
			return "Pilot Turn Too Fast"
		case 58:
			return "Pilot No Nav Data"
		case 59:
			return "Pilot Lost Waypoint Data"
		case 60:
			return "Pilot EEPROM Corrupt"
		case 61:
			return "Pilot Rudder Feedback Fail"
		case 62:
			return "Pilot Autolearn Fail1"
		case 63:
			return "Pilot Autolearn Fail2"
		case 64:
			return "Pilot Autolearn Fail3"
		case 65:
			return "Pilot Autolearn Fail4"
		case 66:
			return "Pilot Autolearn Fail5"
		case 67:
			return "Pilot Autolearn Fail6"
		case 68:
			return "Pilot Warning Cal Required"
		case 69:
			return "Pilot Warning OffCourse"
		case 70:
			return "Pilot Warning XTE"
		case 71:
			return "Pilot Warning Wind Shift"
		case 72:
			return "Pilot Warning Drive Short"
		case 73:
			return "Pilot Warning Clutch Short"
		case 74:
			return "Pilot Warning Solenoid Short"
		case 75:
			return "Pilot Joystick Fault"
		case 76:
			return "Pilot No Joystick Data"
		case 77:
			return "not assigned"
		case 78:
			return "not assigned"
		case 79:
			return "not assigned"
		case 80:
			return "Pilot Invalid Command"
		case 81:
			return "AIS TX Malfunction"
		case 82:
			return "AIS Antenna VSWR fault"
		case 83:
			return "AIS Rx channel 1 malfunction"
		case 84:
			return "AIS Rx channel 2 malfunction"
		case 85:
			return "AIS No sensor position in use"
		case 86:
			return "AIS No valid SOG information"
		case 87:
			return "AIS No valid COG information"
		case 88:
			return "AIS 12V alarm"
		case 89:
			return "AIS 6V alarm"
		case 90:
			return "AIS Noise threshold exceeded channel A"
		case 91:
			return "AIS Noise threshold exceeded channel B"
		case 92:
			return "AIS Transmitter PA fault"
		case 93:
			return "AIS 3V3 alarm"
		case 94:
			return "AIS Rx channel 70 malfunction"
		case 95:
			return "AIS Heading lost/invalid"
		case 96:
			return "AIS internal GPS lost"
		case 97:
			return "AIS No sensor position"
		case 98:
			return "AIS Lock failure"
		case 99:
			return "AIS Internal GGA timeout"
		case 100:
			return "AIS Protocol stack restart"
		case 101:
			return "Pilot No IPS communications"
		case 102:
			return "Pilot Power-On or Sleep-Switch Reset While Engaged"
		case 103:
			return "Pilot Unexpected Reset While Engaged"
		case 104:
			return "AIS Dangerous Target"
		case 105:
			return "AIS Lost Target"
		case 106:
			return "AIS Safety Related Message (used to silence)"
		case 107:
			return "AIS Connection Lost"
		case 108:
			return "No Fix"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmIdConst", int(e))
	}
}

type SeatalkAlarmGroupConst uint8
const (
	Instrument	SeatalkAlarmGroupConst = 0
	Autopilot	SeatalkAlarmGroupConst = 1
	Radar	SeatalkAlarmGroupConst = 2
	ChartPlotter	SeatalkAlarmGroupConst = 3
	AIS	SeatalkAlarmGroupConst = 4
)

func (e SeatalkAlarmGroupConst) GoString() string {return e.String() }
func (e SeatalkAlarmGroupConst) String() string {
	switch e {
		case 0:
			return "Instrument"
		case 1:
			return "Autopilot"
		case 2:
			return "Radar"
		case 3:
			return "Chart Plotter"
		case 4:
			return "AIS"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmGroupConst", int(e))
	}
}

type SeatalkPilotModeConst uint8
const (
	Standby	SeatalkPilotModeConst = 64
	Auto	SeatalkPilotModeConst = 66
	Wind	SeatalkPilotModeConst = 70
	Track	SeatalkPilotModeConst = 74
)

func (e SeatalkPilotModeConst) GoString() string {return e.String() }
func (e SeatalkPilotModeConst) String() string {
	switch e {
		case 64:
			return "Standby"
		case 66:
			return "Auto"
		case 70:
			return "Wind"
		case 74:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkPilotModeConst", int(e))
	}
}

type EntertainmentZoneConst uint8
const (
	AllZones	EntertainmentZoneConst = 0
	Zone1	EntertainmentZoneConst = 1
	Zone2	EntertainmentZoneConst = 2
	Zone3	EntertainmentZoneConst = 3
	Zone4	EntertainmentZoneConst = 4
)

func (e EntertainmentZoneConst) GoString() string {return e.String() }
func (e EntertainmentZoneConst) String() string {
	switch e {
		case 0:
			return "All zones"
		case 1:
			return "Zone 1"
		case 2:
			return "Zone 2"
		case 3:
			return "Zone 3"
		case 4:
			return "Zone 4"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentZoneConst", int(e))
	}
}

type EntertainmentSourceConst uint8
const (
	VesselAlarm	EntertainmentSourceConst = 0
	AM	EntertainmentSourceConst = 1
	FM	EntertainmentSourceConst = 2
	Weather	EntertainmentSourceConst = 3
	DAB	EntertainmentSourceConst = 4
	Aux	EntertainmentSourceConst = 5
	USB	EntertainmentSourceConst = 6
	CD	EntertainmentSourceConst = 7
	MP3	EntertainmentSourceConst = 8
	AppleIOS	EntertainmentSourceConst = 9
	Android	EntertainmentSourceConst = 10
	Bluetooth	EntertainmentSourceConst = 11
	SiriusXM	EntertainmentSourceConst = 12
	Pandora	EntertainmentSourceConst = 13
	Spotify	EntertainmentSourceConst = 14
	Slacker	EntertainmentSourceConst = 15
	Songza	EntertainmentSourceConst = 16
	AppleRadio	EntertainmentSourceConst = 17
	LastFM	EntertainmentSourceConst = 18
	Ethernet	EntertainmentSourceConst = 19
	VideoMP4	EntertainmentSourceConst = 20
	VideoDVD	EntertainmentSourceConst = 21
	VideoBluRay	EntertainmentSourceConst = 22
	HDMI	EntertainmentSourceConst = 23
	Video	EntertainmentSourceConst = 24
)

func (e EntertainmentSourceConst) GoString() string {return e.String() }
func (e EntertainmentSourceConst) String() string {
	switch e {
		case 0:
			return "Vessel alarm"
		case 1:
			return "AM"
		case 2:
			return "FM"
		case 3:
			return "Weather"
		case 4:
			return "DAB"
		case 5:
			return "Aux"
		case 6:
			return "USB"
		case 7:
			return "CD"
		case 8:
			return "MP3"
		case 9:
			return "Apple iOS"
		case 10:
			return "Android"
		case 11:
			return "Bluetooth"
		case 12:
			return "Sirius XM"
		case 13:
			return "Pandora"
		case 14:
			return "Spotify"
		case 15:
			return "Slacker"
		case 16:
			return "Songza"
		case 17:
			return "Apple Radio"
		case 18:
			return "Last FM"
		case 19:
			return "Ethernet"
		case 20:
			return "Video MP4"
		case 21:
			return "Video DVD"
		case 22:
			return "Video BluRay"
		case 23:
			return "HDMI"
		case 24:
			return "Video"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentSourceConst", int(e))
	}
}

type EntertainmentPlayStatusConst uint16
const (
	Play	EntertainmentPlayStatusConst = 0
	Pause	EntertainmentPlayStatusConst = 1
	Stop	EntertainmentPlayStatusConst = 2
	FF1x	EntertainmentPlayStatusConst = 3
	FF2x	EntertainmentPlayStatusConst = 4
	FF3x	EntertainmentPlayStatusConst = 5
	FF4x	EntertainmentPlayStatusConst = 6
	RW1x	EntertainmentPlayStatusConst = 7
	RW2x	EntertainmentPlayStatusConst = 8
	RW3x	EntertainmentPlayStatusConst = 9
	RW4x	EntertainmentPlayStatusConst = 10
	SkipAhead	EntertainmentPlayStatusConst = 11
	SkipBack	EntertainmentPlayStatusConst = 12
	JogAhead	EntertainmentPlayStatusConst = 13
	JogBack	EntertainmentPlayStatusConst = 14
	SeekUp	EntertainmentPlayStatusConst = 15
	SeekDown	EntertainmentPlayStatusConst = 16
	ScanUp	EntertainmentPlayStatusConst = 17
	ScanDown	EntertainmentPlayStatusConst = 18
	TuneUp	EntertainmentPlayStatusConst = 19
	TuneDown	EntertainmentPlayStatusConst = 20
	SlowMotion75x	EntertainmentPlayStatusConst = 21
	SlowMotion5x	EntertainmentPlayStatusConst = 22
	SlowMotion25x	EntertainmentPlayStatusConst = 23
	SlowMotion125x	EntertainmentPlayStatusConst = 24
)

func (e EntertainmentPlayStatusConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusConst", int(e))
	}
}

type EntertainmentRepeatStatusConst uint8
const (
	Off2	EntertainmentRepeatStatusConst = 0
	One	EntertainmentRepeatStatusConst = 1
	All	EntertainmentRepeatStatusConst = 2
)

func (e EntertainmentRepeatStatusConst) GoString() string {return e.String() }
func (e EntertainmentRepeatStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatStatusConst", int(e))
	}
}

type EntertainmentShuffleStatusConst uint8
const (
	Off3	EntertainmentShuffleStatusConst = 0
	PlayQueue	EntertainmentShuffleStatusConst = 1
	All2	EntertainmentShuffleStatusConst = 2
)

func (e EntertainmentShuffleStatusConst) GoString() string {return e.String() }
func (e EntertainmentShuffleStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Play queue"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleStatusConst", int(e))
	}
}

type EntertainmentLikeStatusConst uint8
const (
	None	EntertainmentLikeStatusConst = 0
	ThumbsUp	EntertainmentLikeStatusConst = 1
	ThumbsDown	EntertainmentLikeStatusConst = 2
)

func (e EntertainmentLikeStatusConst) GoString() string {return e.String() }
func (e EntertainmentLikeStatusConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "Thumbs up"
		case 2:
			return "Thumbs down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentLikeStatusConst", int(e))
	}
}

type EntertainmentTypeConst uint8
const (
	File	EntertainmentTypeConst = 0
	PlaylistName	EntertainmentTypeConst = 1
	GenreName	EntertainmentTypeConst = 2
	AlbumName	EntertainmentTypeConst = 3
	ArtistName	EntertainmentTypeConst = 4
	TrackName	EntertainmentTypeConst = 5
	StationName	EntertainmentTypeConst = 6
	StationNumber	EntertainmentTypeConst = 7
	FavouriteNumber	EntertainmentTypeConst = 8
	PlayQueue2	EntertainmentTypeConst = 9
	ContentInfo	EntertainmentTypeConst = 10
)

func (e EntertainmentTypeConst) GoString() string {return e.String() }
func (e EntertainmentTypeConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentTypeConst", int(e))
	}
}

type EntertainmentGroupConst uint8
const (
	File2	EntertainmentGroupConst = 0
	PlaylistName2	EntertainmentGroupConst = 1
	GenreName2	EntertainmentGroupConst = 2
	AlbumName2	EntertainmentGroupConst = 3
	ArtistName2	EntertainmentGroupConst = 4
	TrackName2	EntertainmentGroupConst = 5
	StationName2	EntertainmentGroupConst = 6
	StationNumber2	EntertainmentGroupConst = 7
	FavouriteNumber2	EntertainmentGroupConst = 8
	PlayQueue3	EntertainmentGroupConst = 9
	ContentInfo2	EntertainmentGroupConst = 10
)

func (e EntertainmentGroupConst) GoString() string {return e.String() }
func (e EntertainmentGroupConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupConst", int(e))
	}
}

type EntertainmentChannelConst uint8
const (
	AllChannels	EntertainmentChannelConst = 0
	StereoFullRange	EntertainmentChannelConst = 1
	StereoFront	EntertainmentChannelConst = 2
	StereoBack	EntertainmentChannelConst = 3
	StereoSurround	EntertainmentChannelConst = 4
	Center	EntertainmentChannelConst = 5
	Subwoofer	EntertainmentChannelConst = 6
	FrontLeft	EntertainmentChannelConst = 7
	FrontRight	EntertainmentChannelConst = 8
	BackLeft	EntertainmentChannelConst = 9
	BackRight	EntertainmentChannelConst = 10
	SurroundLeft	EntertainmentChannelConst = 11
	SurroundRight	EntertainmentChannelConst = 12
)

func (e EntertainmentChannelConst) GoString() string {return e.String() }
func (e EntertainmentChannelConst) String() string {
	switch e {
		case 0:
			return "All channels"
		case 1:
			return "Stereo full range"
		case 2:
			return "Stereo front"
		case 3:
			return "Stereo back"
		case 4:
			return "Stereo surround"
		case 5:
			return "Center"
		case 6:
			return "Subwoofer"
		case 7:
			return "Front left"
		case 8:
			return "Front right"
		case 9:
			return "Back left"
		case 10:
			return "Back right"
		case 11:
			return "Surround left"
		case 12:
			return "Surround right"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentChannelConst", int(e))
	}
}

type EntertainmentEqConst uint8
const (
	Flat	EntertainmentEqConst = 0
	Rock	EntertainmentEqConst = 1
	Hall	EntertainmentEqConst = 2
	Jazz	EntertainmentEqConst = 3
	Pop	EntertainmentEqConst = 4
	Live	EntertainmentEqConst = 5
	Classic	EntertainmentEqConst = 6
	Vocal	EntertainmentEqConst = 7
	Arena	EntertainmentEqConst = 8
	Cinema	EntertainmentEqConst = 9
	Custom	EntertainmentEqConst = 10
)

func (e EntertainmentEqConst) GoString() string {return e.String() }
func (e EntertainmentEqConst) String() string {
	switch e {
		case 0:
			return "Flat"
		case 1:
			return "Rock"
		case 2:
			return "Hall"
		case 3:
			return "Jazz"
		case 4:
			return "Pop"
		case 5:
			return "Live"
		case 6:
			return "Classic"
		case 7:
			return "Vocal"
		case 8:
			return "Arena"
		case 9:
			return "Cinema"
		case 10:
			return "Custom"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentEqConst", int(e))
	}
}

type EntertainmentFilterConst uint8
const (
	FullRange	EntertainmentFilterConst = 0
	HighPass	EntertainmentFilterConst = 1
	LowPass	EntertainmentFilterConst = 2
	BandPass	EntertainmentFilterConst = 3
	NotchFilter	EntertainmentFilterConst = 4
)

func (e EntertainmentFilterConst) GoString() string {return e.String() }
func (e EntertainmentFilterConst) String() string {
	switch e {
		case 0:
			return "Full range"
		case 1:
			return "High pass"
		case 2:
			return "Low pass"
		case 3:
			return "Band pass"
		case 4:
			return "Notch filter"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentFilterConst", int(e))
	}
}

type AlertTypeConst uint8
const (
	EmergencyAlarm	AlertTypeConst = 1
	Alarm	AlertTypeConst = 2
	Warning2	AlertTypeConst = 5
	Caution2	AlertTypeConst = 8
)

func (e AlertTypeConst) GoString() string {return e.String() }
func (e AlertTypeConst) String() string {
	switch e {
		case 1:
			return "Emergency Alarm"
		case 2:
			return "Alarm"
		case 5:
			return "Warning"
		case 8:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTypeConst", int(e))
	}
}

type AlertCategoryConst uint8
const (
	Navigational	AlertCategoryConst = 0
	Technical	AlertCategoryConst = 1
)

func (e AlertCategoryConst) GoString() string {return e.String() }
func (e AlertCategoryConst) String() string {
	switch e {
		case 0:
			return "Navigational"
		case 1:
			return "Technical"
	default:
		return fmt.Sprintf("%s(%d)", "AlertCategoryConst", int(e))
	}
}

type AlertTriggerConditionConst uint8
const (
	Manual3	AlertTriggerConditionConst = 0
	Auto2	AlertTriggerConditionConst = 1
	Test2	AlertTriggerConditionConst = 2
	Disabled	AlertTriggerConditionConst = 3
)

func (e AlertTriggerConditionConst) GoString() string {return e.String() }
func (e AlertTriggerConditionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Auto"
		case 2:
			return "Test"
		case 3:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTriggerConditionConst", int(e))
	}
}

type AlertThresholdStatusConst uint8
const (
	Normal	AlertThresholdStatusConst = 0
	ThresholdExceeded	AlertThresholdStatusConst = 1
	ExtremeThresholdExceeded	AlertThresholdStatusConst = 2
	LowThresholdExceeded	AlertThresholdStatusConst = 3
	Acknowledged	AlertThresholdStatusConst = 4
	AwaitingAcknowledge	AlertThresholdStatusConst = 5
)

func (e AlertThresholdStatusConst) GoString() string {return e.String() }
func (e AlertThresholdStatusConst) String() string {
	switch e {
		case 0:
			return "Normal"
		case 1:
			return "Threshold Exceeded"
		case 2:
			return "Extreme Threshold Exceeded"
		case 3:
			return "Low Threshold Exceeded"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertThresholdStatusConst", int(e))
	}
}

type AlertStateConst uint8
const (
	Disabled2	AlertStateConst = 0
	Normal2	AlertStateConst = 1
	Active	AlertStateConst = 2
	Silenced	AlertStateConst = 3
	Acknowledged2	AlertStateConst = 4
	AwaitingAcknowledge2	AlertStateConst = 5
)

func (e AlertStateConst) GoString() string {return e.String() }
func (e AlertStateConst) String() string {
	switch e {
		case 0:
			return "Disabled"
		case 1:
			return "Normal"
		case 2:
			return "Active"
		case 3:
			return "Silenced"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertStateConst", int(e))
	}
}

type AlertLanguageIdConst uint8
const (
	EnglishUS	AlertLanguageIdConst = 0
	EnglishUK	AlertLanguageIdConst = 1
	Arabic	AlertLanguageIdConst = 2
	ChineseSimplified	AlertLanguageIdConst = 3
	Croatian	AlertLanguageIdConst = 4
	Danish	AlertLanguageIdConst = 5
	Dutch	AlertLanguageIdConst = 6
	Finnish	AlertLanguageIdConst = 7
	French	AlertLanguageIdConst = 8
	German	AlertLanguageIdConst = 9
	Greek	AlertLanguageIdConst = 10
	Italian	AlertLanguageIdConst = 11
	Japanese	AlertLanguageIdConst = 12
	Korean	AlertLanguageIdConst = 13
	Norwegian	AlertLanguageIdConst = 14
	Polish	AlertLanguageIdConst = 15
	Portuguese	AlertLanguageIdConst = 16
	Russian	AlertLanguageIdConst = 17
	Spanish	AlertLanguageIdConst = 18
	Swedish	AlertLanguageIdConst = 19
)

func (e AlertLanguageIdConst) GoString() string {return e.String() }
func (e AlertLanguageIdConst) String() string {
	switch e {
		case 0:
			return "English (US)"
		case 1:
			return "English (UK)"
		case 2:
			return "Arabic"
		case 3:
			return "Chinese (simplified)"
		case 4:
			return "Croatian"
		case 5:
			return "Danish"
		case 6:
			return "Dutch"
		case 7:
			return "Finnish"
		case 8:
			return "French"
		case 9:
			return "German"
		case 10:
			return "Greek"
		case 11:
			return "Italian"
		case 12:
			return "Japanese"
		case 13:
			return "Korean"
		case 14:
			return "Norwegian"
		case 15:
			return "Polish"
		case 16:
			return "Portuguese"
		case 17:
			return "Russian"
		case 18:
			return "Spanish"
		case 19:
			return "Swedish"
	default:
		return fmt.Sprintf("%s(%d)", "AlertLanguageIdConst", int(e))
	}
}

type AlertResponseCommandConst uint8
const (
	Acknowledge	AlertResponseCommandConst = 0
	TemporarySilence	AlertResponseCommandConst = 1
	TestCommandOff	AlertResponseCommandConst = 2
	TestCommandOn	AlertResponseCommandConst = 3
)

func (e AlertResponseCommandConst) GoString() string {return e.String() }
func (e AlertResponseCommandConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Temporary Silence"
		case 2:
			return "Test Command off"
		case 3:
			return "Test Command on"
	default:
		return fmt.Sprintf("%s(%d)", "AlertResponseCommandConst", int(e))
	}
}

type ConverterStateConst uint8
const (
	Off4	ConverterStateConst = 0
	LowPowerMode	ConverterStateConst = 1
	Fault	ConverterStateConst = 2
	Bulk	ConverterStateConst = 3
	Absorption	ConverterStateConst = 4
	Float	ConverterStateConst = 5
	Storage	ConverterStateConst = 6
	Equalize	ConverterStateConst = 7
	PassThru	ConverterStateConst = 8
	Inverting	ConverterStateConst = 9
	Assisting	ConverterStateConst = 10
)

func (e ConverterStateConst) GoString() string {return e.String() }
func (e ConverterStateConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Low Power Mode"
		case 2:
			return "Fault"
		case 3:
			return "Bulk"
		case 4:
			return "Absorption"
		case 5:
			return "Float"
		case 6:
			return "Storage"
		case 7:
			return "Equalize"
		case 8:
			return "Pass thru"
		case 9:
			return "Inverting"
		case 10:
			return "Assisting"
	default:
		return fmt.Sprintf("%s(%d)", "ConverterStateConst", int(e))
	}
}

type ThrusterDirectionControlConst uint8
const (
	Off5	ThrusterDirectionControlConst = 0
	Ready	ThrusterDirectionControlConst = 1
	ToPort	ThrusterDirectionControlConst = 2
	ToStarboard	ThrusterDirectionControlConst = 3
)

func (e ThrusterDirectionControlConst) GoString() string {return e.String() }
func (e ThrusterDirectionControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Ready"
		case 2:
			return "To Port"
		case 3:
			return "To Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterDirectionControlConst", int(e))
	}
}

type ThrusterRetractControlConst uint8
const (
	Off6	ThrusterRetractControlConst = 0
	Extend	ThrusterRetractControlConst = 1
	Retract	ThrusterRetractControlConst = 2
)

func (e ThrusterRetractControlConst) GoString() string {return e.String() }
func (e ThrusterRetractControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Extend"
		case 2:
			return "Retract"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterRetractControlConst", int(e))
	}
}

type ThrusterMotorTypeConst uint8
const (
	A12VDC	ThrusterMotorTypeConst = 0
	A24VDC	ThrusterMotorTypeConst = 1
	A48VDC	ThrusterMotorTypeConst = 2
	A24VAC	ThrusterMotorTypeConst = 3
	Hydraulic2	ThrusterMotorTypeConst = 4
)

func (e ThrusterMotorTypeConst) GoString() string {return e.String() }
func (e ThrusterMotorTypeConst) String() string {
	switch e {
		case 0:
			return "A12VDC"
		case 1:
			return "A24VDC"
		case 2:
			return "A48VDC"
		case 3:
			return "A24VAC"
		case 4:
			return "Hydraulic"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorTypeConst", int(e))
	}
}

type BootStateConst uint8
const (
	InStartupMonitor	BootStateConst = 0
	RunningBootloader	BootStateConst = 1
	RunningApplication	BootStateConst = 2
)

func (e BootStateConst) GoString() string {return e.String() }
func (e BootStateConst) String() string {
	switch e {
		case 0:
			return "in Startup Monitor"
		case 1:
			return "running Bootloader"
		case 2:
			return "running Application"
	default:
		return fmt.Sprintf("%s(%d)", "BootStateConst", int(e))
	}
}

type AccessLevelConst uint8
const (
	Locked	AccessLevelConst = 0
	UnlockedLevel1	AccessLevelConst = 1
	UnlockedLevel2	AccessLevelConst = 2
)

func (e AccessLevelConst) GoString() string {return e.String() }
func (e AccessLevelConst) String() string {
	switch e {
		case 0:
			return "Locked"
		case 1:
			return "unlocked level 1"
		case 2:
			return "unlocked level 2"
	default:
		return fmt.Sprintf("%s(%d)", "AccessLevelConst", int(e))
	}
}

type TransmissionIntervalConst uint8
const (
	Acknowledge2	TransmissionIntervalConst = 0
	TransmitIntervalPriorityNotSupported	TransmissionIntervalConst = 1
	TransmitIntervalTooLow	TransmissionIntervalConst = 2
	AccessDenied	TransmissionIntervalConst = 3
	NotSupported	TransmissionIntervalConst = 4
)

func (e TransmissionIntervalConst) GoString() string {return e.String() }
func (e TransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Transmit Interval/Priority not supported"
		case 2:
			return "Transmit Interval too low"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
	default:
		return fmt.Sprintf("%s(%d)", "TransmissionIntervalConst", int(e))
	}
}

type ParameterFieldConst uint8
const (
	Acknowledge3	ParameterFieldConst = 0
	InvalidParameterField	ParameterFieldConst = 1
	TemporaryError	ParameterFieldConst = 2
	ParameterOutOfRange	ParameterFieldConst = 3
	AccessDenied2	ParameterFieldConst = 4
	NotSupported2	ParameterFieldConst = 5
	ReadOrWriteNotSupported	ParameterFieldConst = 6
)

func (e ParameterFieldConst) GoString() string {return e.String() }
func (e ParameterFieldConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Invalid parameter field"
		case 2:
			return "Temporary error"
		case 3:
			return "Parameter out of range"
		case 4:
			return "Access denied"
		case 5:
			return "Not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "ParameterFieldConst", int(e))
	}
}

type PgnListFunctionConst uint8
const (
	TransmitPGNList	PgnListFunctionConst = 0
	ReceivePGNList	PgnListFunctionConst = 1
)

func (e PgnListFunctionConst) GoString() string {return e.String() }
func (e PgnListFunctionConst) String() string {
	switch e {
		case 0:
			return "Transmit PGN list"
		case 1:
			return "Receive PGN list"
	default:
		return fmt.Sprintf("%s(%d)", "PgnListFunctionConst", int(e))
	}
}

type FusionCommandConst uint8
const (
	Play2	FusionCommandConst = 1
	Pause2	FusionCommandConst = 2
	Next	FusionCommandConst = 4
	Prev	FusionCommandConst = 6
)

func (e FusionCommandConst) GoString() string {return e.String() }
func (e FusionCommandConst) String() string {
	switch e {
		case 1:
			return "Play"
		case 2:
			return "Pause"
		case 4:
			return "Next"
		case 6:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionCommandConst", int(e))
	}
}

type FusionSiriusCommandConst uint8
const (
	Next2	FusionSiriusCommandConst = 1
	Prev2	FusionSiriusCommandConst = 2
)

func (e FusionSiriusCommandConst) GoString() string {return e.String() }
func (e FusionSiriusCommandConst) String() string {
	switch e {
		case 1:
			return "Next"
		case 2:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionSiriusCommandConst", int(e))
	}
}

type FusionMuteCommandConst uint8
const (
	MuteOn	FusionMuteCommandConst = 1
	MuteOff	FusionMuteCommandConst = 2
)

func (e FusionMuteCommandConst) GoString() string {return e.String() }
func (e FusionMuteCommandConst) String() string {
	switch e {
		case 1:
			return "Mute On"
		case 2:
			return "Mute Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMuteCommandConst", int(e))
	}
}

type SeatalkKeystrokeConst uint8
const (
	Auto3	SeatalkKeystrokeConst = 1
	Standby2	SeatalkKeystrokeConst = 2
	Wind2	SeatalkKeystrokeConst = 3
	AMinus1	SeatalkKeystrokeConst = 5
	AMinus10	SeatalkKeystrokeConst = 6
	APlus1	SeatalkKeystrokeConst = 7
	APlus10	SeatalkKeystrokeConst = 8
	AMinus1AndMinus10	SeatalkKeystrokeConst = 33
	APlus1AndPlus10	SeatalkKeystrokeConst = 34
	Track2	SeatalkKeystrokeConst = 35
)

func (e SeatalkKeystrokeConst) GoString() string {return e.String() }
func (e SeatalkKeystrokeConst) String() string {
	switch e {
		case 1:
			return "Auto"
		case 2:
			return "Standby"
		case 3:
			return "Wind"
		case 5:
			return "A-1"
		case 6:
			return "A-10"
		case 7:
			return "A+1"
		case 8:
			return "A+10"
		case 33:
			return "A-1 and -10"
		case 34:
			return "A+1 and +10"
		case 35:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkKeystrokeConst", int(e))
	}
}

type SeatalkDeviceIdConst uint8
const (
	S100	SeatalkDeviceIdConst = 3
	CourseComputer	SeatalkDeviceIdConst = 5
)

func (e SeatalkDeviceIdConst) GoString() string {return e.String() }
func (e SeatalkDeviceIdConst) String() string {
	switch e {
		case 3:
			return "S100"
		case 5:
			return "Course Computer"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkDeviceIdConst", int(e))
	}
}

type AirmarCalibrateFunctionConst uint8
const (
	NormalCancelCalibration	AirmarCalibrateFunctionConst = 0
	EnterCalibrationMode	AirmarCalibrateFunctionConst = 1
	ResetCalibrationTo0	AirmarCalibrateFunctionConst = 2
	Verify	AirmarCalibrateFunctionConst = 3
	ResetCompassToDefaults	AirmarCalibrateFunctionConst = 4
	ResetDampingToDefaults	AirmarCalibrateFunctionConst = 5
)

func (e AirmarCalibrateFunctionConst) GoString() string {return e.String() }
func (e AirmarCalibrateFunctionConst) String() string {
	switch e {
		case 0:
			return "Normal/cancel calibration"
		case 1:
			return "Enter calibration mode"
		case 2:
			return "Reset calibration to 0"
		case 3:
			return "Verify"
		case 4:
			return "Reset compass to defaults"
		case 5:
			return "Reset damping to defaults"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateFunctionConst", int(e))
	}
}

type AirmarCalibrateStatusConst uint8
const (
	Queried	AirmarCalibrateStatusConst = 0
	Passed	AirmarCalibrateStatusConst = 1
	FailedTimeout	AirmarCalibrateStatusConst = 2
	FailedTiltError	AirmarCalibrateStatusConst = 3
	FailedOther	AirmarCalibrateStatusConst = 4
	InProgress	AirmarCalibrateStatusConst = 5
)

func (e AirmarCalibrateStatusConst) GoString() string {return e.String() }
func (e AirmarCalibrateStatusConst) String() string {
	switch e {
		case 0:
			return "Queried"
		case 1:
			return "Passed"
		case 2:
			return "Failed - timeout"
		case 3:
			return "Failed - tilt error"
		case 4:
			return "Failed - other"
		case 5:
			return "In progress"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateStatusConst", int(e))
	}
}

type AirmarTemperatureInstanceConst uint8
const (
	DeviceSensor	AirmarTemperatureInstanceConst = 0
	OnboardWaterSensor	AirmarTemperatureInstanceConst = 1
	OptionalWaterSensor	AirmarTemperatureInstanceConst = 2
)

func (e AirmarTemperatureInstanceConst) GoString() string {return e.String() }
func (e AirmarTemperatureInstanceConst) String() string {
	switch e {
		case 0:
			return "Device Sensor"
		case 1:
			return "Onboard Water Sensor"
		case 2:
			return "Optional Water Sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTemperatureInstanceConst", int(e))
	}
}

type AirmarFilterConst uint8
const (
	NoFilter	AirmarFilterConst = 0
	BasicIIRFilter	AirmarFilterConst = 1
)

func (e AirmarFilterConst) GoString() string {return e.String() }
func (e AirmarFilterConst) String() string {
	switch e {
		case 0:
			return "No filter"
		case 1:
			return "Basic IIR filter"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarFilterConst", int(e))
	}
}

type ControllerStateConst uint8
const (
	ErrorActive	ControllerStateConst = 0
	ErrorPassive	ControllerStateConst = 1
	BusOff	ControllerStateConst = 2
)

func (e ControllerStateConst) GoString() string {return e.String() }
func (e ControllerStateConst) String() string {
	switch e {
		case 0:
			return "Error Active"
		case 1:
			return "Error Passive"
		case 2:
			return "Bus Off"
	default:
		return fmt.Sprintf("%s(%d)", "ControllerStateConst", int(e))
	}
}

type EquipmentStatusConst uint8
const (
	Operational	EquipmentStatusConst = 0
	Fault2	EquipmentStatusConst = 1
)

func (e EquipmentStatusConst) GoString() string {return e.String() }
func (e EquipmentStatusConst) String() string {
	switch e {
		case 0:
			return "Operational"
		case 1:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "EquipmentStatusConst", int(e))
	}
}

type MobStatusConst uint8
const (
	MOBEmitterActivated	MobStatusConst = 0
	ManualOnBoardMOBButtonActivation	MobStatusConst = 1
	TestMode	MobStatusConst = 2
)

func (e MobStatusConst) GoString() string {return e.String() }
func (e MobStatusConst) String() string {
	switch e {
		case 0:
			return "MOB Emitter Activated"
		case 1:
			return "Manual on-board MOB Button Activation"
		case 2:
			return "Test mode"
	default:
		return fmt.Sprintf("%s(%d)", "MobStatusConst", int(e))
	}
}

type LowBatteryConst uint8
const (
	Good	LowBatteryConst = 0
	Low2	LowBatteryConst = 1
)

func (e LowBatteryConst) GoString() string {return e.String() }
func (e LowBatteryConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Low"
	default:
		return fmt.Sprintf("%s(%d)", "LowBatteryConst", int(e))
	}
}

type TurnModeConst uint8
const (
	RudderLimitControlled	TurnModeConst = 0
	TurnRateControlled	TurnModeConst = 1
	RadiusControlled	TurnModeConst = 2
)

func (e TurnModeConst) GoString() string {return e.String() }
func (e TurnModeConst) String() string {
	switch e {
		case 0:
			return "Rudder limit controlled"
		case 1:
			return "Turn rate controlled"
		case 2:
			return "Radius controlled"
	default:
		return fmt.Sprintf("%s(%d)", "TurnModeConst", int(e))
	}
}

type AcceptabilityConst uint8
const (
	BadLevel	AcceptabilityConst = 0
	BadFrequency	AcceptabilityConst = 1
	BeingQualified	AcceptabilityConst = 2
	Good2	AcceptabilityConst = 3
)

func (e AcceptabilityConst) GoString() string {return e.String() }
func (e AcceptabilityConst) String() string {
	switch e {
		case 0:
			return "Bad level"
		case 1:
			return "Bad frequency"
		case 2:
			return "Being qualified"
		case 3:
			return "Good"
	default:
		return fmt.Sprintf("%s(%d)", "AcceptabilityConst", int(e))
	}
}

type LineConst uint8
const (
	Line1	LineConst = 0
	Line2	LineConst = 1
	Line3	LineConst = 2
)

func (e LineConst) GoString() string {return e.String() }
func (e LineConst) String() string {
	switch e {
		case 0:
			return "Line 1"
		case 1:
			return "Line 2"
		case 2:
			return "Line 3"
	default:
		return fmt.Sprintf("%s(%d)", "LineConst", int(e))
	}
}

type WaveformConst uint8
const (
	SineWave	WaveformConst = 0
	ModifiedSineWave	WaveformConst = 1
)

func (e WaveformConst) GoString() string {return e.String() }
func (e WaveformConst) String() string {
	switch e {
		case 0:
			return "Sine wave"
		case 1:
			return "Modified sine wave"
	default:
		return fmt.Sprintf("%s(%d)", "WaveformConst", int(e))
	}
}

type TankTypeConst uint8
const (
	Fuel2	TankTypeConst = 0
	Water2	TankTypeConst = 1
	GrayWater	TankTypeConst = 2
	LiveWell	TankTypeConst = 3
	Oil2	TankTypeConst = 4
	BlackWater	TankTypeConst = 5
)

func (e TankTypeConst) GoString() string {return e.String() }
func (e TankTypeConst) String() string {
	switch e {
		case 0:
			return "Fuel"
		case 1:
			return "Water"
		case 2:
			return "Gray water"
		case 3:
			return "Live well"
		case 4:
			return "Oil"
		case 5:
			return "Black water"
	default:
		return fmt.Sprintf("%s(%d)", "TankTypeConst", int(e))
	}
}

type DcSourceConst uint8
const (
	Battery	DcSourceConst = 0
	Alternator	DcSourceConst = 1
	Convertor	DcSourceConst = 2
	SolarCell	DcSourceConst = 3
	WindGenerator	DcSourceConst = 4
)

func (e DcSourceConst) GoString() string {return e.String() }
func (e DcSourceConst) String() string {
	switch e {
		case 0:
			return "Battery"
		case 1:
			return "Alternator"
		case 2:
			return "Convertor"
		case 3:
			return "Solar cell"
		case 4:
			return "Wind generator"
	default:
		return fmt.Sprintf("%s(%d)", "DcSourceConst", int(e))
	}
}

type ChargerStateConst uint8
const (
	NotCharging	ChargerStateConst = 0
	Bulk2	ChargerStateConst = 1
	Absorption2	ChargerStateConst = 2
	Overcharge	ChargerStateConst = 3
	Equalise	ChargerStateConst = 4
	Float2	ChargerStateConst = 5
	NoFloat	ChargerStateConst = 6
	ConstantVI	ChargerStateConst = 7
	Disabled3	ChargerStateConst = 8
	Fault3	ChargerStateConst = 9
)

func (e ChargerStateConst) GoString() string {return e.String() }
func (e ChargerStateConst) String() string {
	switch e {
		case 0:
			return "Not charging"
		case 1:
			return "Bulk"
		case 2:
			return "Absorption"
		case 3:
			return "Overcharge"
		case 4:
			return "Equalise"
		case 5:
			return "Float"
		case 6:
			return "No float"
		case 7:
			return "Constant VI"
		case 8:
			return "Disabled"
		case 9:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerStateConst", int(e))
	}
}

type ChargingAlgorithmConst uint8
const (
	Trickle	ChargingAlgorithmConst = 0
	ConstantVoltageConstantCurrent	ChargingAlgorithmConst = 1
	A2StageNoFloat	ChargingAlgorithmConst = 2
	A3Stage	ChargingAlgorithmConst = 3
)

func (e ChargingAlgorithmConst) GoString() string {return e.String() }
func (e ChargingAlgorithmConst) String() string {
	switch e {
		case 0:
			return "Trickle"
		case 1:
			return "Constant voltage / Constant current"
		case 2:
			return "A2 stage (no float)"
		case 3:
			return "A3 stage"
	default:
		return fmt.Sprintf("%s(%d)", "ChargingAlgorithmConst", int(e))
	}
}

type ChargerModeConst uint8
const (
	Standalone	ChargerModeConst = 0
	Primary	ChargerModeConst = 1
	Secondary	ChargerModeConst = 2
	Echo	ChargerModeConst = 3
)

func (e ChargerModeConst) GoString() string {return e.String() }
func (e ChargerModeConst) String() string {
	switch e {
		case 0:
			return "Standalone"
		case 1:
			return "Primary"
		case 2:
			return "Secondary"
		case 3:
			return "Echo"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerModeConst", int(e))
	}
}

type InverterStateConst uint8
const (
	Invert	InverterStateConst = 0
	ACPassthru	InverterStateConst = 1
	LoadSense	InverterStateConst = 2
	Fault4	InverterStateConst = 3
	Disabled4	InverterStateConst = 4
)

func (e InverterStateConst) GoString() string {return e.String() }
func (e InverterStateConst) String() string {
	switch e {
		case 0:
			return "Invert"
		case 1:
			return "AC passthru"
		case 2:
			return "Load sense"
		case 3:
			return "Fault"
		case 4:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "InverterStateConst", int(e))
	}
}

type BatteryTypeConst uint8
const (
	Flooded	BatteryTypeConst = 0
	Gel	BatteryTypeConst = 1
	AGM	BatteryTypeConst = 2
)

func (e BatteryTypeConst) GoString() string {return e.String() }
func (e BatteryTypeConst) String() string {
	switch e {
		case 0:
			return "Flooded"
		case 1:
			return "Gel"
		case 2:
			return "AGM"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryTypeConst", int(e))
	}
}

type BatteryVoltageConst uint8
const (
	A6V	BatteryVoltageConst = 0
	A12V	BatteryVoltageConst = 1
	A24V	BatteryVoltageConst = 2
	A32V	BatteryVoltageConst = 3
	A36V	BatteryVoltageConst = 4
	A42V	BatteryVoltageConst = 5
	A48V	BatteryVoltageConst = 6
)

func (e BatteryVoltageConst) GoString() string {return e.String() }
func (e BatteryVoltageConst) String() string {
	switch e {
		case 0:
			return "A6V"
		case 1:
			return "A12V"
		case 2:
			return "A24V"
		case 3:
			return "A32V"
		case 4:
			return "A36V"
		case 5:
			return "A42V"
		case 6:
			return "A48V"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryVoltageConst", int(e))
	}
}

type BatteryChemistryConst uint8
const (
	PbLead	BatteryChemistryConst = 0
	Li	BatteryChemistryConst = 1
	NiCd	BatteryChemistryConst = 2
	ZnO	BatteryChemistryConst = 3
	NiMH	BatteryChemistryConst = 4
)

func (e BatteryChemistryConst) GoString() string {return e.String() }
func (e BatteryChemistryConst) String() string {
	switch e {
		case 0:
			return "Pb (Lead)"
		case 1:
			return "Li"
		case 2:
			return "NiCd"
		case 3:
			return "ZnO"
		case 4:
			return "NiMH"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryChemistryConst", int(e))
	}
}

type GoodWarningErrorConst uint8
const (
	Good3	GoodWarningErrorConst = 0
	Warning3	GoodWarningErrorConst = 1
	Error3	GoodWarningErrorConst = 2
)

func (e GoodWarningErrorConst) GoString() string {return e.String() }
func (e GoodWarningErrorConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Warning"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "GoodWarningErrorConst", int(e))
	}
}

type TrackingConst uint8
const (
	Cancelled	TrackingConst = 0
	Acquiring	TrackingConst = 1
	Tracking	TrackingConst = 2
	Lost	TrackingConst = 3
)

func (e TrackingConst) GoString() string {return e.String() }
func (e TrackingConst) String() string {
	switch e {
		case 0:
			return "Cancelled"
		case 1:
			return "Acquiring"
		case 2:
			return "Tracking"
		case 3:
			return "Lost"
	default:
		return fmt.Sprintf("%s(%d)", "TrackingConst", int(e))
	}
}

type TargetAcquisitionConst uint8
const (
	Manual4	TargetAcquisitionConst = 0
	Automatic	TargetAcquisitionConst = 1
)

func (e TargetAcquisitionConst) GoString() string {return e.String() }
func (e TargetAcquisitionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic"
	default:
		return fmt.Sprintf("%s(%d)", "TargetAcquisitionConst", int(e))
	}
}

type WindlassDirectionConst uint8
const (
	Off7	WindlassDirectionConst = 0
	Down	WindlassDirectionConst = 1
	Up	WindlassDirectionConst = 2
)

func (e WindlassDirectionConst) GoString() string {return e.String() }
func (e WindlassDirectionConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Down"
		case 2:
			return "Up"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassDirectionConst", int(e))
	}
}

type SpeedTypeConst uint8
const (
	SingleSpeed	SpeedTypeConst = 0
	DualSpeed	SpeedTypeConst = 1
	ProportionalSpeed	SpeedTypeConst = 2
)

func (e SpeedTypeConst) GoString() string {return e.String() }
func (e SpeedTypeConst) String() string {
	switch e {
		case 0:
			return "Single speed"
		case 1:
			return "Dual speed"
		case 2:
			return "Proportional speed"
	default:
		return fmt.Sprintf("%s(%d)", "SpeedTypeConst", int(e))
	}
}

type WindlassMotionConst uint8
const (
	WindlassStopped	WindlassMotionConst = 0
	DeploymentOccurring	WindlassMotionConst = 1
	RetrievalOccurring	WindlassMotionConst = 2
)

func (e WindlassMotionConst) GoString() string {return e.String() }
func (e WindlassMotionConst) String() string {
	switch e {
		case 0:
			return "Windlass stopped"
		case 1:
			return "Deployment occurring"
		case 2:
			return "Retrieval occurring"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMotionConst", int(e))
	}
}

type RodeTypeConst uint8
const (
	ChainPresentlyDetected	RodeTypeConst = 0
	RopePresentlyDetected	RodeTypeConst = 1
)

func (e RodeTypeConst) GoString() string {return e.String() }
func (e RodeTypeConst) String() string {
	switch e {
		case 0:
			return "Chain presently detected"
		case 1:
			return "Rope presently detected"
	default:
		return fmt.Sprintf("%s(%d)", "RodeTypeConst", int(e))
	}
}

type DockingStatusConst uint8
const (
	NotDocked	DockingStatusConst = 0
	FullyDocked	DockingStatusConst = 1
)

func (e DockingStatusConst) GoString() string {return e.String() }
func (e DockingStatusConst) String() string {
	switch e {
		case 0:
			return "Not docked"
		case 1:
			return "Fully docked"
	default:
		return fmt.Sprintf("%s(%d)", "DockingStatusConst", int(e))
	}
}

type AisTypeConst uint8
const (
	SOTDMA	AisTypeConst = 0
	CS	AisTypeConst = 1
)

func (e AisTypeConst) GoString() string {return e.String() }
func (e AisTypeConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "CS"
	default:
		return fmt.Sprintf("%s(%d)", "AisTypeConst", int(e))
	}
}

type AisBandConst uint8
const (
	Top525KHzOfMarineBand	AisBandConst = 0
	EntireMarineBand	AisBandConst = 1
)

func (e AisBandConst) GoString() string {return e.String() }
func (e AisBandConst) String() string {
	switch e {
		case 0:
			return "Top 525 kHz of marine band"
		case 1:
			return "Entire marine band"
	default:
		return fmt.Sprintf("%s(%d)", "AisBandConst", int(e))
	}
}

type AisModeConst uint8
const (
	Autonomous2	AisModeConst = 0
	Assigned	AisModeConst = 1
)

func (e AisModeConst) GoString() string {return e.String() }
func (e AisModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Assigned"
	default:
		return fmt.Sprintf("%s(%d)", "AisModeConst", int(e))
	}
}

type AisCommunicationStateConst uint8
const (
	SOTDMA2	AisCommunicationStateConst = 0
	ITDMA	AisCommunicationStateConst = 1
)

func (e AisCommunicationStateConst) GoString() string {return e.String() }
func (e AisCommunicationStateConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "ITDMA"
	default:
		return fmt.Sprintf("%s(%d)", "AisCommunicationStateConst", int(e))
	}
}

type AvailableConst uint8
const (
	Available	AvailableConst = 0
	NotAvailable3	AvailableConst = 1
)

func (e AvailableConst) GoString() string {return e.String() }
func (e AvailableConst) String() string {
	switch e {
		case 0:
			return "Available"
		case 1:
			return "Not available"
	default:
		return fmt.Sprintf("%s(%d)", "AvailableConst", int(e))
	}
}

type BearingModeConst uint8
const (
	GreatCircle	BearingModeConst = 0
	Rhumbline	BearingModeConst = 1
)

func (e BearingModeConst) GoString() string {return e.String() }
func (e BearingModeConst) String() string {
	switch e {
		case 0:
			return "Great Circle"
		case 1:
			return "Rhumbline"
	default:
		return fmt.Sprintf("%s(%d)", "BearingModeConst", int(e))
	}
}

type MarkTypeConst uint8
const (
	Collision2	MarkTypeConst = 0
	TurningPoint	MarkTypeConst = 1
	Reference	MarkTypeConst = 2
	Wheelover	MarkTypeConst = 3
	Waypoint	MarkTypeConst = 4
)

func (e MarkTypeConst) GoString() string {return e.String() }
func (e MarkTypeConst) String() string {
	switch e {
		case 0:
			return "Collision"
		case 1:
			return "Turning point"
		case 2:
			return "Reference"
		case 3:
			return "Wheelover"
		case 4:
			return "Waypoint"
	default:
		return fmt.Sprintf("%s(%d)", "MarkTypeConst", int(e))
	}
}

type GnssModeConst uint8
const (
	A1D	GnssModeConst = 0
	A2D	GnssModeConst = 1
	A3D	GnssModeConst = 2
	Auto4	GnssModeConst = 3
)

func (e GnssModeConst) GoString() string {return e.String() }
func (e GnssModeConst) String() string {
	switch e {
		case 0:
			return "A1D"
		case 1:
			return "A2D"
		case 2:
			return "A3D"
		case 3:
			return "Auto"
	default:
		return fmt.Sprintf("%s(%d)", "GnssModeConst", int(e))
	}
}

type RangeResidualModeConst uint8
const (
	RangeResidualsWereUsedToCalculateData	RangeResidualModeConst = 0
	RangeResidualsWereCalculatedAfterThePosition	RangeResidualModeConst = 1
)

func (e RangeResidualModeConst) GoString() string {return e.String() }
func (e RangeResidualModeConst) String() string {
	switch e {
		case 0:
			return "Range residuals were used to calculate data"
		case 1:
			return "Range residuals were calculated after the position"
	default:
		return fmt.Sprintf("%s(%d)", "RangeResidualModeConst", int(e))
	}
}

type DgnssModeConst uint8
const (
	None2	DgnssModeConst = 0
	SBASIfAvailable	DgnssModeConst = 1
	SBAS	DgnssModeConst = 3
)

func (e DgnssModeConst) GoString() string {return e.String() }
func (e DgnssModeConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "SBAS if available"
		case 3:
			return "SBAS"
	default:
		return fmt.Sprintf("%s(%d)", "DgnssModeConst", int(e))
	}
}

type SatelliteStatusConst uint8
const (
	NotTracked	SatelliteStatusConst = 0
	Tracked	SatelliteStatusConst = 1
	Used	SatelliteStatusConst = 2
	NotTrackedDiff	SatelliteStatusConst = 3
	TrackedDiff	SatelliteStatusConst = 4
	UsedDiff	SatelliteStatusConst = 5
)

func (e SatelliteStatusConst) GoString() string {return e.String() }
func (e SatelliteStatusConst) String() string {
	switch e {
		case 0:
			return "Not tracked"
		case 1:
			return "Tracked"
		case 2:
			return "Used"
		case 3:
			return "Not tracked+Diff"
		case 4:
			return "Tracked+Diff"
		case 5:
			return "Used+Diff"
	default:
		return fmt.Sprintf("%s(%d)", "SatelliteStatusConst", int(e))
	}
}

type AisVersionConst uint8
const (
	ITURM1371Minus1	AisVersionConst = 0
	ITURM13713	AisVersionConst = 1
	ITURM13715	AisVersionConst = 2
	ITURM1371FutureEdition	AisVersionConst = 3
)

func (e AisVersionConst) GoString() string {return e.String() }
func (e AisVersionConst) String() string {
	switch e {
		case 0:
			return "ITU-R M.1371-1"
		case 1:
			return "ITU-R M.1371-3"
		case 2:
			return "ITU-R M.1371-5"
		case 3:
			return "ITU-R M.1371 future edition"
	default:
		return fmt.Sprintf("%s(%d)", "AisVersionConst", int(e))
	}
}

type TideConst uint8
const (
	Falling	TideConst = 0
	Rising	TideConst = 1
)

func (e TideConst) GoString() string {return e.String() }
func (e TideConst) String() string {
	switch e {
		case 0:
			return "Falling"
		case 1:
			return "Rising"
	default:
		return fmt.Sprintf("%s(%d)", "TideConst", int(e))
	}
}

type WatermakerStateConst uint8
const (
	Stopped	WatermakerStateConst = 0
	Starting	WatermakerStateConst = 1
	Running	WatermakerStateConst = 2
	Stopping	WatermakerStateConst = 3
	Flushing	WatermakerStateConst = 4
	Rinsing	WatermakerStateConst = 5
	Initiating	WatermakerStateConst = 6
	Manual5	WatermakerStateConst = 7
)

func (e WatermakerStateConst) GoString() string {return e.String() }
func (e WatermakerStateConst) String() string {
	switch e {
		case 0:
			return "Stopped"
		case 1:
			return "Starting"
		case 2:
			return "Running"
		case 3:
			return "Stopping"
		case 4:
			return "Flushing"
		case 5:
			return "Rinsing"
		case 6:
			return "Initiating"
		case 7:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "WatermakerStateConst", int(e))
	}
}

type EntertainmentIdTypeConst uint8
const (
	Group	EntertainmentIdTypeConst = 0
	File3	EntertainmentIdTypeConst = 1
	EncryptedGroup	EntertainmentIdTypeConst = 2
	EncryptedFile	EntertainmentIdTypeConst = 3
)

func (e EntertainmentIdTypeConst) GoString() string {return e.String() }
func (e EntertainmentIdTypeConst) String() string {
	switch e {
		case 0:
			return "Group"
		case 1:
			return "File"
		case 2:
			return "Encrypted group"
		case 3:
			return "Encrypted file"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentIdTypeConst", int(e))
	}
}

type EntertainmentDefaultSettingsConst uint8
const (
	SaveCurrentSettingsAsUserDefault	EntertainmentDefaultSettingsConst = 0
	LoadUserDefault	EntertainmentDefaultSettingsConst = 1
	LoadManufacturerDefault	EntertainmentDefaultSettingsConst = 2
)

func (e EntertainmentDefaultSettingsConst) GoString() string {return e.String() }
func (e EntertainmentDefaultSettingsConst) String() string {
	switch e {
		case 0:
			return "Save current settings as user default"
		case 1:
			return "Load user default"
		case 2:
			return "Load manufacturer default"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentDefaultSettingsConst", int(e))
	}
}

type EntertainmentRegionsConst uint8
const (
	USA	EntertainmentRegionsConst = 0
	Europe	EntertainmentRegionsConst = 1
	Asia	EntertainmentRegionsConst = 2
	MiddleEast	EntertainmentRegionsConst = 3
	LatinAmerica	EntertainmentRegionsConst = 4
	Australia	EntertainmentRegionsConst = 5
	Russia	EntertainmentRegionsConst = 6
	Japan	EntertainmentRegionsConst = 7
)

func (e EntertainmentRegionsConst) GoString() string {return e.String() }
func (e EntertainmentRegionsConst) String() string {
	switch e {
		case 0:
			return "USA"
		case 1:
			return "Europe"
		case 2:
			return "Asia"
		case 3:
			return "Middle East"
		case 4:
			return "Latin America"
		case 5:
			return "Australia"
		case 6:
			return "Russia"
		case 7:
			return "Japan"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRegionsConst", int(e))
	}
}

type VideoProtocolsConst uint8
const (
	PAL	VideoProtocolsConst = 0
	NTSC	VideoProtocolsConst = 1
)

func (e VideoProtocolsConst) GoString() string {return e.String() }
func (e VideoProtocolsConst) String() string {
	switch e {
		case 0:
			return "PAL"
		case 1:
			return "NTSC"
	default:
		return fmt.Sprintf("%s(%d)", "VideoProtocolsConst", int(e))
	}
}

type EntertainmentVolumeControlConst uint8
const (
	Up2	EntertainmentVolumeControlConst = 0
	Down2	EntertainmentVolumeControlConst = 1
)

func (e EntertainmentVolumeControlConst) GoString() string {return e.String() }
func (e EntertainmentVolumeControlConst) String() string {
	switch e {
		case 0:
			return "Up"
		case 1:
			return "Down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentVolumeControlConst", int(e))
	}
}

type BluetoothStatusConst uint8
const (
	Connected	BluetoothStatusConst = 0
	NotConnected	BluetoothStatusConst = 1
	NotPaired	BluetoothStatusConst = 2
)

func (e BluetoothStatusConst) GoString() string {return e.String() }
func (e BluetoothStatusConst) String() string {
	switch e {
		case 0:
			return "Connected"
		case 1:
			return "Not connected"
		case 2:
			return "Not paired"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothStatusConst", int(e))
	}
}

type BluetoothSourceStatusConst uint8
const (
	Reserved3	BluetoothSourceStatusConst = 0
	Connected2	BluetoothSourceStatusConst = 1
	Connecting	BluetoothSourceStatusConst = 2
	NotConnected2	BluetoothSourceStatusConst = 3
)

func (e BluetoothSourceStatusConst) GoString() string {return e.String() }
func (e BluetoothSourceStatusConst) String() string {
	switch e {
		case 0:
			return "Reserved"
		case 1:
			return "Connected"
		case 2:
			return "Connecting"
		case 3:
			return "Not connected"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothSourceStatusConst", int(e))
	}
}

type SonichubCommandConst uint8
const (
	Init2	SonichubCommandConst = 1
	AMRadio	SonichubCommandConst = 4
	ZoneInfo	SonichubCommandConst = 5
	Source	SonichubCommandConst = 6
	SourceList	SonichubCommandConst = 8
	Control	SonichubCommandConst = 9
	FMRadio	SonichubCommandConst = 12
	Playlist	SonichubCommandConst = 13
	Track3	SonichubCommandConst = 14
	Artist	SonichubCommandConst = 15
	Album	SonichubCommandConst = 16
	MenuItem	SonichubCommandConst = 19
	Zones	SonichubCommandConst = 20
	MaxVolume	SonichubCommandConst = 23
	Volume	SonichubCommandConst = 24
	Init1	SonichubCommandConst = 25
	Position	SonichubCommandConst = 48
	Init3	SonichubCommandConst = 50
)

func (e SonichubCommandConst) GoString() string {return e.String() }
func (e SonichubCommandConst) String() string {
	switch e {
		case 1:
			return "Init #2"
		case 4:
			return "AM Radio"
		case 5:
			return "Zone Info"
		case 6:
			return "Source"
		case 8:
			return "Source List"
		case 9:
			return "Control"
		case 12:
			return "FM Radio"
		case 13:
			return "Playlist"
		case 14:
			return "Track"
		case 15:
			return "Artist"
		case 16:
			return "Album"
		case 19:
			return "Menu Item"
		case 20:
			return "Zones"
		case 23:
			return "Max Volume"
		case 24:
			return "Volume"
		case 25:
			return "Init #1"
		case 48:
			return "Position"
		case 50:
			return "Init #3"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubCommandConst", int(e))
	}
}

type SimradCommandConst uint8
const (
	Text	SimradCommandConst = 50
)

func (e SimradCommandConst) GoString() string {return e.String() }
func (e SimradCommandConst) String() string {
	switch e {
		case 50:
			return "Text"
	default:
		return fmt.Sprintf("%s(%d)", "SimradCommandConst", int(e))
	}
}

type SimradTypeConst uint16
const (
	HeadingOffset	SimradTypeConst = 0
	LocalField	SimradTypeConst = 768
	FieldAngle	SimradTypeConst = 1024
)

func (e SimradTypeConst) GoString() string {return e.String() }
func (e SimradTypeConst) String() string {
	switch e {
		case 0:
			return "Heading Offset"
		case 768:
			return "Local field"
		case 1024:
			return "Field angle"
	default:
		return fmt.Sprintf("%s(%d)", "SimradTypeConst", int(e))
	}
}

type SimradEventCommandConst uint8
const (
	Alarm2	SimradEventCommandConst = 1
	APCommand	SimradEventCommandConst = 2
)

func (e SimradEventCommandConst) GoString() string {return e.String() }
func (e SimradEventCommandConst) String() string {
	switch e {
		case 1:
			return "Alarm"
		case 2:
			return "AP command"
	default:
		return fmt.Sprintf("%s(%d)", "SimradEventCommandConst", int(e))
	}
}

type FusionMessageIdConst uint8
const (
	RequestStatus	FusionMessageIdConst = 1
	Source2	FusionMessageIdConst = 2
	TrackInfo	FusionMessageIdConst = 4
	TrackTitle	FusionMessageIdConst = 5
	TrackArtist	FusionMessageIdConst = 6
	TrackProgress	FusionMessageIdConst = 9
	AMFMStation	FusionMessageIdConst = 11
	VHF	FusionMessageIdConst = 12
	Squelch	FusionMessageIdConst = 13
	Scan	FusionMessageIdConst = 14
	MenuItem2	FusionMessageIdConst = 17
	Replay	FusionMessageIdConst = 20
	Mute	FusionMessageIdConst = 23
	SetZoneVolume	FusionMessageIdConst = 24
	SetAllVolumes	FusionMessageIdConst = 25
	SubVolume	FusionMessageIdConst = 26
	Tone	FusionMessageIdConst = 27
	Volume2	FusionMessageIdConst = 29
	Power	FusionMessageIdConst = 32
	UnitName	FusionMessageIdConst = 33
	SiriusXMChannel	FusionMessageIdConst = 36
	SiriusXMTitle	FusionMessageIdConst = 37
	SiriusXMArtist	FusionMessageIdConst = 38
	SiriusXMGenre	FusionMessageIdConst = 40
	ZoneName	FusionMessageIdConst = 45
)

func (e FusionMessageIdConst) GoString() string {return e.String() }
func (e FusionMessageIdConst) String() string {
	switch e {
		case 1:
			return "Request Status"
		case 2:
			return "Source"
		case 4:
			return "Track Info"
		case 5:
			return "Track Title"
		case 6:
			return "Track Artist"
		case 9:
			return "Track Progress"
		case 11:
			return "AM/FM Station"
		case 12:
			return "VHF"
		case 13:
			return "Squelch"
		case 14:
			return "Scan"
		case 17:
			return "Menu Item"
		case 20:
			return "Replay"
		case 23:
			return "Mute"
		case 24:
			return "Set Zone Volume"
		case 25:
			return "Set All Volumes"
		case 26:
			return "Sub Volume"
		case 27:
			return "Tone"
		case 29:
			return "Volume"
		case 32:
			return "Power"
		case 33:
			return "Unit Name"
		case 36:
			return "SiriusXM Channel"
		case 37:
			return "SiriusXM Title"
		case 38:
			return "SiriusXM Artist"
		case 40:
			return "SiriusXM Genre"
		case 45:
			return "Zone Name"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMessageIdConst", int(e))
	}
}

type SonichubControlConst uint8
const (
	Set	SonichubControlConst = 0
	Ack	SonichubControlConst = 128
)

func (e SonichubControlConst) GoString() string {return e.String() }
func (e SonichubControlConst) String() string {
	switch e {
		case 0:
			return "Set"
		case 128:
			return "Ack"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubControlConst", int(e))
	}
}

type SonichubSourceConst uint8
const (
	AM2	SonichubSourceConst = 0
	FM2	SonichubSourceConst = 1
	IPod	SonichubSourceConst = 2
	USB2	SonichubSourceConst = 3
	AUX	SonichubSourceConst = 4
	AUX2	SonichubSourceConst = 5
	Mic	SonichubSourceConst = 6
)

func (e SonichubSourceConst) GoString() string {return e.String() }
func (e SonichubSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
		case 2:
			return "iPod"
		case 3:
			return "USB"
		case 4:
			return "AUX"
		case 5:
			return "AUX 2"
		case 6:
			return "Mic"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubSourceConst", int(e))
	}
}

type IsoControlConst uint8
const (
	ACK	IsoControlConst = 0
	NAK	IsoControlConst = 1
	AccessDenied3	IsoControlConst = 2
	AddressBusy	IsoControlConst = 3
)

func (e IsoControlConst) GoString() string {return e.String() }
func (e IsoControlConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 1:
			return "NAK"
		case 2:
			return "Access Denied"
		case 3:
			return "Address Busy"
	default:
		return fmt.Sprintf("%s(%d)", "IsoControlConst", int(e))
	}
}

type IsoCommandConst uint8
const (
	ACK2	IsoCommandConst = 0
	RTS	IsoCommandConst = 16
	CTS	IsoCommandConst = 17
	EOM	IsoCommandConst = 19
	BAM	IsoCommandConst = 32
	Abort	IsoCommandConst = 255
)

func (e IsoCommandConst) GoString() string {return e.String() }
func (e IsoCommandConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 16:
			return "RTS"
		case 17:
			return "CTS"
		case 19:
			return "EOM"
		case 32:
			return "BAM"
		case 255:
			return "Abort"
	default:
		return fmt.Sprintf("%s(%d)", "IsoCommandConst", int(e))
	}
}

type GroupFunctionConst uint8
const (
	Request	GroupFunctionConst = 0
	Command	GroupFunctionConst = 1
	Acknowledge4	GroupFunctionConst = 2
	ReadFields	GroupFunctionConst = 3
	ReadFieldsReply	GroupFunctionConst = 4
	WriteFields	GroupFunctionConst = 5
	WriteFieldsReply	GroupFunctionConst = 6
)

func (e GroupFunctionConst) GoString() string {return e.String() }
func (e GroupFunctionConst) String() string {
	switch e {
		case 0:
			return "Request"
		case 1:
			return "Command"
		case 2:
			return "Acknowledge"
		case 3:
			return "Read Fields"
		case 4:
			return "Read Fields Reply"
		case 5:
			return "Write Fields"
		case 6:
			return "Write Fields Reply"
	default:
		return fmt.Sprintf("%s(%d)", "GroupFunctionConst", int(e))
	}
}

type AirmarCommandConst uint8
const (
	AttitudeOffsets	AirmarCommandConst = 32
	CalibrateCompass	AirmarCommandConst = 33
	TrueWindOptions	AirmarCommandConst = 34
	SimulateMode2	AirmarCommandConst = 35
	CalibrateDepth	AirmarCommandConst = 40
	CalibrateSpeed	AirmarCommandConst = 41
	CalibrateTemperature	AirmarCommandConst = 42
	SpeedFilter	AirmarCommandConst = 43
	TemperatureFilter	AirmarCommandConst = 44
	NMEA2000Options	AirmarCommandConst = 46
)

func (e AirmarCommandConst) GoString() string {return e.String() }
func (e AirmarCommandConst) String() string {
	switch e {
		case 32:
			return "Attitude Offsets"
		case 33:
			return "Calibrate Compass"
		case 34:
			return "True Wind Options"
		case 35:
			return "Simulate Mode"
		case 40:
			return "Calibrate Depth"
		case 41:
			return "Calibrate Speed"
		case 42:
			return "Calibrate Temperature"
		case 43:
			return "Speed Filter"
		case 44:
			return "Temperature Filter"
		case 46:
			return "NMEA 2000 options"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCommandConst", int(e))
	}
}

type AirmarDepthQualityFactorConst uint8
const (
	DepthUnlocked	AirmarDepthQualityFactorConst = 0
	Quality10Percent	AirmarDepthQualityFactorConst = 1
	Quality20Percent	AirmarDepthQualityFactorConst = 2
	Quality30Percent	AirmarDepthQualityFactorConst = 3
	Quality40Percent	AirmarDepthQualityFactorConst = 4
	Quality50Percent	AirmarDepthQualityFactorConst = 5
	Quality60Percent	AirmarDepthQualityFactorConst = 6
	Quality70Percent	AirmarDepthQualityFactorConst = 7
	Quality80Percent	AirmarDepthQualityFactorConst = 8
	Quality90Percent	AirmarDepthQualityFactorConst = 9
	Quality100Percent	AirmarDepthQualityFactorConst = 10
)

func (e AirmarDepthQualityFactorConst) GoString() string {return e.String() }
func (e AirmarDepthQualityFactorConst) String() string {
	switch e {
		case 0:
			return "Depth unlocked"
		case 1:
			return "Quality 10%"
		case 2:
			return "Quality 20%"
		case 3:
			return "Quality 30%"
		case 4:
			return "Quality 40%"
		case 5:
			return "Quality 50%"
		case 6:
			return "Quality 60%"
		case 7:
			return "Quality 70%"
		case 8:
			return "Quality 80%"
		case 9:
			return "Quality 90%"
		case 10:
			return "Quality 100%"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarDepthQualityFactorConst", int(e))
	}
}

type PgnErrorCodeConst uint8
const (
	Acknowledge5	PgnErrorCodeConst = 0
	PGNNotSupported	PgnErrorCodeConst = 1
	PGNNotAvailable	PgnErrorCodeConst = 2
	AccessDenied4	PgnErrorCodeConst = 3
	NotSupported3	PgnErrorCodeConst = 4
	TagNotSupported	PgnErrorCodeConst = 5
	ReadOrWriteNotSupported2	PgnErrorCodeConst = 6
)

func (e PgnErrorCodeConst) GoString() string {return e.String() }
func (e PgnErrorCodeConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "PGN not supported"
		case 2:
			return "PGN not available"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
		case 5:
			return "Tag not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "PgnErrorCodeConst", int(e))
	}
}

type AirmarTransmissionIntervalConst uint8
const (
	MeasureInterval	AirmarTransmissionIntervalConst = 0
	RequestedByUser	AirmarTransmissionIntervalConst = 1
)

func (e AirmarTransmissionIntervalConst) GoString() string {return e.String() }
func (e AirmarTransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Measure interval"
		case 1:
			return "Requested by user"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTransmissionIntervalConst", int(e))
	}
}

type MobPositionSourceConst uint8
const (
	PositionEstimatedByTheVessel	MobPositionSourceConst = 0
	PositionReportedByMOBEmitter	MobPositionSourceConst = 1
)

func (e MobPositionSourceConst) GoString() string {return e.String() }
func (e MobPositionSourceConst) String() string {
	switch e {
		case 0:
			return "Position estimated by the vessel"
		case 1:
			return "Position reported by MOB emitter"
	default:
		return fmt.Sprintf("%s(%d)", "MobPositionSourceConst", int(e))
	}
}

type SteeringModeConst uint8
const (
	MainSteering	SteeringModeConst = 0
	NonFollowUpDevice	SteeringModeConst = 1
	FollowUpDevice	SteeringModeConst = 2
	HeadingControlStandalone	SteeringModeConst = 3
	HeadingControl	SteeringModeConst = 4
	TrackControl	SteeringModeConst = 5
)

func (e SteeringModeConst) GoString() string {return e.String() }
func (e SteeringModeConst) String() string {
	switch e {
		case 0:
			return "Main Steering"
		case 1:
			return "Non-Follow-Up Device"
		case 2:
			return "Follow-Up Device"
		case 3:
			return "Heading Control Standalone"
		case 4:
			return "Heading Control"
		case 5:
			return "Track Control"
	default:
		return fmt.Sprintf("%s(%d)", "SteeringModeConst", int(e))
	}
}

type FusionRadioSourceConst uint8
const (
	AM3	FusionRadioSourceConst = 0
	FM3	FusionRadioSourceConst = 1
)

func (e FusionRadioSourceConst) GoString() string {return e.String() }
func (e FusionRadioSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
	default:
		return fmt.Sprintf("%s(%d)", "FusionRadioSourceConst", int(e))
	}
}

type FusionReplayModeConst uint8
const (
	USBRepeat	FusionReplayModeConst = 9
	USBShuffle	FusionReplayModeConst = 10
	IPodRepeat	FusionReplayModeConst = 12
	IPodShuffle	FusionReplayModeConst = 13
)

func (e FusionReplayModeConst) GoString() string {return e.String() }
func (e FusionReplayModeConst) String() string {
	switch e {
		case 9:
			return "USB repeat"
		case 10:
			return "USB shuffle"
		case 12:
			return "iPod repeat"
		case 13:
			return "iPod shuffle"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayModeConst", int(e))
	}
}

type FusionReplayStatusConst uint8
const (
	Off8	FusionReplayStatusConst = 0
	OneTrack	FusionReplayStatusConst = 1
	AllAlbum	FusionReplayStatusConst = 2
)

func (e FusionReplayStatusConst) GoString() string {return e.String() }
func (e FusionReplayStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One/track"
		case 2:
			return "All/album"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayStatusConst", int(e))
	}
}

type AirmarPostControlConst uint8
const (
	ReportPreviousValues	AirmarPostControlConst = 0
	GenerateNewValues	AirmarPostControlConst = 1
)

func (e AirmarPostControlConst) GoString() string {return e.String() }
func (e AirmarPostControlConst) String() string {
	switch e {
		case 0:
			return "Report previous values"
		case 1:
			return "Generate new values"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostControlConst", int(e))
	}
}

type AirmarPostIdConst uint8
const (
	FormatCode	AirmarPostIdConst = 1
	FactoryEEPROM	AirmarPostIdConst = 2
	UserEEPROM	AirmarPostIdConst = 3
	WaterTemperatureSensor	AirmarPostIdConst = 4
	SonarTransceiver	AirmarPostIdConst = 5
	SpeedSensor	AirmarPostIdConst = 6
	InternalTemperatureSensor	AirmarPostIdConst = 7
	BatteryVoltageSensor	AirmarPostIdConst = 8
)

func (e AirmarPostIdConst) GoString() string {return e.String() }
func (e AirmarPostIdConst) String() string {
	switch e {
		case 1:
			return "Format Code"
		case 2:
			return "Factory EEPROM"
		case 3:
			return "User EEPROM"
		case 4:
			return "Water Temperature Sensor"
		case 5:
			return "Sonar Transceiver"
		case 6:
			return "Speed sensor"
		case 7:
			return "Internal temperature sensor"
		case 8:
			return "Battery voltage sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostIdConst", int(e))
	}
}

type SonichubTuningConst uint8
const (
	SeekingUp	SonichubTuningConst = 1
	Tuned	SonichubTuningConst = 2
	SeekingDown	SonichubTuningConst = 3
)

func (e SonichubTuningConst) GoString() string {return e.String() }
func (e SonichubTuningConst) String() string {
	switch e {
		case 1:
			return "Seeking up"
		case 2:
			return "Tuned"
		case 3:
			return "Seeking down"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubTuningConst", int(e))
	}
}

type SonichubPlaylistConst uint8
const (
	Report	SonichubPlaylistConst = 1
	NextSong	SonichubPlaylistConst = 4
	PreviousSong	SonichubPlaylistConst = 6
)

func (e SonichubPlaylistConst) GoString() string {return e.String() }
func (e SonichubPlaylistConst) String() string {
	switch e {
		case 1:
			return "Report"
		case 4:
			return "Next song"
		case 6:
			return "Previous song"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubPlaylistConst", int(e))
	}
}

type FusionPowerStateConst uint8
const (
	On2	FusionPowerStateConst = 1
	Off9	FusionPowerStateConst = 2
)

func (e FusionPowerStateConst) GoString() string {return e.String() }
func (e FusionPowerStateConst) String() string {
	switch e {
		case 1:
			return "On"
		case 2:
			return "Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionPowerStateConst", int(e))
	}
}

type SimnetBacklightLevelConst uint8
const (
	DayMode	SimnetBacklightLevelConst = 1
	NightMode	SimnetBacklightLevelConst = 4
	Level1	SimnetBacklightLevelConst = 11
	Level2	SimnetBacklightLevelConst = 22
	Level3	SimnetBacklightLevelConst = 33
	Level4	SimnetBacklightLevelConst = 44
	Level5	SimnetBacklightLevelConst = 55
	Level6	SimnetBacklightLevelConst = 66
	Level7	SimnetBacklightLevelConst = 77
	Level8	SimnetBacklightLevelConst = 88
	Level9	SimnetBacklightLevelConst = 99
)

func (e SimnetBacklightLevelConst) GoString() string {return e.String() }
func (e SimnetBacklightLevelConst) String() string {
	switch e {
		case 1:
			return "Day mode"
		case 4:
			return "Night mode"
		case 11:
			return "Level 1"
		case 22:
			return "Level 2"
		case 33:
			return "Level 3"
		case 44:
			return "Level 4"
		case 55:
			return "Level 5"
		case 66:
			return "Level 6"
		case 77:
			return "Level 7"
		case 88:
			return "Level 8"
		case 99:
			return "Level 9"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetBacklightLevelConst", int(e))
	}
}

type SimnetApEventsConst uint8
const (
	Standby3	SimnetApEventsConst = 6
	AutoMode	SimnetApEventsConst = 9
	NavMode	SimnetApEventsConst = 10
	NonFollowUpMode	SimnetApEventsConst = 13
	WindMode	SimnetApEventsConst = 15
	SquareTurn	SimnetApEventsConst = 18
	CTurn	SimnetApEventsConst = 19
	UTurn	SimnetApEventsConst = 20
	SpiralTurn	SimnetApEventsConst = 21
	ZigZagTurn	SimnetApEventsConst = 22
	LazySTurn	SimnetApEventsConst = 23
	DepthTurn	SimnetApEventsConst = 24
	ChangeCourse	SimnetApEventsConst = 26
	TimerSync	SimnetApEventsConst = 61
	PingPortEnd	SimnetApEventsConst = 112
	PingStarboardEnd	SimnetApEventsConst = 113
)

func (e SimnetApEventsConst) GoString() string {return e.String() }
func (e SimnetApEventsConst) String() string {
	switch e {
		case 6:
			return "Standby"
		case 9:
			return "Auto mode"
		case 10:
			return "Nav mode"
		case 13:
			return "Non Follow Up mode"
		case 15:
			return "Wind mode"
		case 18:
			return "Square (Turn)"
		case 19:
			return "C-Turn"
		case 20:
			return "U-Turn"
		case 21:
			return "Spiral (Turn)"
		case 22:
			return "Zig Zag (Turn)"
		case 23:
			return "Lazy-S (Turn)"
		case 24:
			return "Depth (Turn)"
		case 26:
			return "Change course"
		case 61:
			return "Timer sync"
		case 112:
			return "Ping port end"
		case 113:
			return "Ping starboard end"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApEventsConst", int(e))
	}
}

type SimnetDirectionConst uint8
const (
	Port	SimnetDirectionConst = 2
	Starboard	SimnetDirectionConst = 3
	LeftRudderPort	SimnetDirectionConst = 4
	RightRudderStarboard	SimnetDirectionConst = 5
)

func (e SimnetDirectionConst) GoString() string {return e.String() }
func (e SimnetDirectionConst) String() string {
	switch e {
		case 2:
			return "Port"
		case 3:
			return "Starboard"
		case 4:
			return "Left rudder (port)"
		case 5:
			return "Right rudder (starboard)"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDirectionConst", int(e))
	}
}

type PriorityConst uint8
const (
	A0	PriorityConst = 0
	A1	PriorityConst = 1
	A2	PriorityConst = 2
	A3	PriorityConst = 3
	A4	PriorityConst = 4
	A5	PriorityConst = 5
	A6	PriorityConst = 6
	A7	PriorityConst = 7
	LeaveUnchanged	PriorityConst = 8
	ResetToDefault	PriorityConst = 9
)

func (e PriorityConst) GoString() string {return e.String() }
func (e PriorityConst) String() string {
	switch e {
		case 0:
			return "A0"
		case 1:
			return "A1"
		case 2:
			return "A2"
		case 3:
			return "A3"
		case 4:
			return "A4"
		case 5:
			return "A5"
		case 6:
			return "A6"
		case 7:
			return "A7"
		case 8:
			return "Leave unchanged"
		case 9:
			return "Reset to default"
	default:
		return fmt.Sprintf("%s(%d)", "PriorityConst", int(e))
	}
}

type DeviceTempStateConst uint8
const (
	Cold	DeviceTempStateConst = 0
	Warm	DeviceTempStateConst = 1
	Hot	DeviceTempStateConst = 2
)

func (e DeviceTempStateConst) GoString() string {return e.String() }
func (e DeviceTempStateConst) String() string {
	switch e {
		case 0:
			return "Cold"
		case 1:
			return "Warm"
		case 2:
			return "Hot"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceTempStateConst", int(e))
	}
}


type DeviceFunctionConst uint16
var DeviceFunctionConstMap = map[int]map[int]string{10: {130: "Diagnostic",
	140: "Bus Traffic Logger",
	 },
20: {110: "Alarm Enunciator",
	130: "Emergency Position Indicating Radio Beacon (EPIRB)",
	135: "Man Overboard",
	140: "Voyage Data Recorder",
	150: "Camera",
	 },
25: {130: "PC Gateway",
	131: "NMEA 2000 to Analog Gateway",
	132: "Analog to NMEA 2000 Gateway",
	133: "NMEA 2000 to Serial Gateway",
	135: "NMEA 0183 Gateway",
	136: "NMEA Network Gateway",
	137: "NMEA 2000 Wireless Gateway",
	140: "Router",
	150: "Bridge",
	160: "Repeater",
	 },
30: {130: "Binary Event Monitor",
	140: "Load Controller",
	141: "AC/DC Input",
	150: "Function Controller",
	 },
35: {140: "Engine",
	141: "DC Generator/Alternator",
	142: "Solar Panel (Solar Array)",
	143: "Wind Generator (DC)",
	144: "Fuel Cell",
	145: "Network Power Supply",
	151: "AC Generator",
	152: "AC Bus",
	153: "AC Mains (Utility/Shore)",
	154: "AC Output",
	160: "Power Converter - Battery Charger",
	161: "Power Converter - Battery Charger+Inverter",
	162: "Power Converter - Inverter",
	163: "Power Converter - DC",
	170: "Battery",
	180: "Engine Gateway",
	 },
40: {130: "Follow-up Controller",
	140: "Mode Controller",
	150: "Autopilot",
	155: "Rudder",
	160: "Heading Sensors",
	170: "Trim (Tabs)/Interceptors",
	180: "Attitude (Pitch, Roll, Yaw) Control",
	 },
50: {130: "Engineroom Monitoring",
	140: "Engine",
	141: "DC Generator/Alternator",
	150: "Engine Controller",
	151: "AC Generator",
	155: "Motor",
	160: "Engine Gateway",
	165: "Transmission",
	170: "Throttle/Shift Control",
	180: "Actuator",
	190: "Gauge Interface",
	200: "Gauge Large",
	210: "Gauge Small",
	 },
60: {130: "Bottom Depth",
	135: "Bottom Depth/Speed",
	136: "Bottom Depth/Speed/Temperature",
	140: "Ownship Attitude",
	145: "Ownship Position (GNSS)",
	150: "Ownship Position (Loran C)",
	155: "Speed",
	160: "Turn Rate Indicator",
	170: "Integrated Navigation",
	175: "Integrated Navigation System",
	190: "Navigation Management",
	195: "Automatic Identification System (AIS)",
	200: "Radar",
	201: "Infrared Imaging",
	205: "ECDIS",
	210: "ECS",
	220: "Direction Finder",
	230: "Voyage Status",
	 },
70: {130: "EPIRB",
	140: "AIS",
	150: "DSC",
	160: "Data Receiver/Transceiver",
	170: "Satellite",
	180: "Radio-telephone (MF/HF)",
	190: "Radiotelephone",
	 },
75: {130: "Temperature",
	140: "Pressure",
	150: "Fluid Level",
	160: "Flow",
	170: "Humidity",
	 },
80: {130: "Time/Date Systems",
	140: "VDR",
	150: "Integrated Instrumentation",
	160: "General Purpose Displays",
	170: "General Sensor Box",
	180: "Weather Instruments",
	190: "Transducer/General",
	200: "NMEA 0183 Converter",
	 },
85: {130: "Atmospheric",
	160: "Aquatic",
	 },
90: {130: "HVAC",
	 },
100: {130: "Scale (Catch)",
	 },
120: {130: "Display",
	140: "Alarm Enunciator",
	 },
125: {130: "Multimedia Player",
	140: "Multimedia Controller",
	 },

}



type StationStatusConst uint16
const (
	StationInUse	StationStatusConst = 0
	LowSNR	StationStatusConst = 1
	CycleError	StationStatusConst = 2
	Blink	StationStatusConst = 3
)

func (e StationStatusConst) GoString() string {return e.String() }
func (e StationStatusConst) String() string {
	switch e {
		case 0:
			return "Station in use"
		case 1:
			return "Low SNR"
		case 2:
			return "Cycle Error"
		case 3:
			return "Blink"
	default:
		return fmt.Sprintf("%s(%d)", "StationStatusConst", int(e))
	}
}

type EngineStatus1Const uint16
const (
	CheckEngine	EngineStatus1Const = 0
	OverTemperature	EngineStatus1Const = 1
	LowOilPressure	EngineStatus1Const = 2
	LowOilLevel	EngineStatus1Const = 3
	LowFuelPressure	EngineStatus1Const = 4
	LowSystemVoltage	EngineStatus1Const = 5
	LowCoolantLevel	EngineStatus1Const = 6
	WaterFlow	EngineStatus1Const = 7
	WaterInFuel	EngineStatus1Const = 8
	ChargeIndicator	EngineStatus1Const = 9
	PreheatIndicator	EngineStatus1Const = 10
	HighBoostPressure	EngineStatus1Const = 11
	RevLimitExceeded	EngineStatus1Const = 12
	EGRSystem	EngineStatus1Const = 13
	ThrottlePositionSensor	EngineStatus1Const = 14
	EmergencyStop	EngineStatus1Const = 15
)

func (e EngineStatus1Const) GoString() string {return e.String() }
func (e EngineStatus1Const) String() string {
	switch e {
		case 0:
			return "Check Engine"
		case 1:
			return "Over Temperature"
		case 2:
			return "Low Oil Pressure"
		case 3:
			return "Low Oil Level"
		case 4:
			return "Low Fuel Pressure"
		case 5:
			return "Low System Voltage"
		case 6:
			return "Low Coolant Level"
		case 7:
			return "Water Flow"
		case 8:
			return "Water In Fuel"
		case 9:
			return "Charge Indicator"
		case 10:
			return "Preheat Indicator"
		case 11:
			return "High Boost Pressure"
		case 12:
			return "Rev Limit Exceeded"
		case 13:
			return "EGR System"
		case 14:
			return "Throttle Position Sensor"
		case 15:
			return "Emergency Stop"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus1Const", int(e))
	}
}

type EngineStatus2Const uint16
const (
	WarningLevel1	EngineStatus2Const = 0
	WarningLevel2	EngineStatus2Const = 1
	PowerReduction	EngineStatus2Const = 2
	MaintenanceNeeded	EngineStatus2Const = 3
	EngineCommError	EngineStatus2Const = 4
	SubOrSecondaryThrottle	EngineStatus2Const = 5
	NeutralStartProtect	EngineStatus2Const = 6
	EngineShuttingDown	EngineStatus2Const = 7
)

func (e EngineStatus2Const) GoString() string {return e.String() }
func (e EngineStatus2Const) String() string {
	switch e {
		case 0:
			return "Warning Level 1"
		case 1:
			return "Warning Level 2"
		case 2:
			return "Power Reduction"
		case 3:
			return "Maintenance Needed"
		case 4:
			return "Engine Comm Error"
		case 5:
			return "Sub or Secondary Throttle"
		case 6:
			return "Neutral Start Protect"
		case 7:
			return "Engine Shutting Down"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus2Const", int(e))
	}
}

type EntertainmentPlayStatusBitfieldConst uint16
const (
	Play3	EntertainmentPlayStatusBitfieldConst = 0
	Pause3	EntertainmentPlayStatusBitfieldConst = 1
	Stop2	EntertainmentPlayStatusBitfieldConst = 2
	FF1x2	EntertainmentPlayStatusBitfieldConst = 3
	FF2x2	EntertainmentPlayStatusBitfieldConst = 4
	FF3x2	EntertainmentPlayStatusBitfieldConst = 5
	FF4x2	EntertainmentPlayStatusBitfieldConst = 6
	RW1x2	EntertainmentPlayStatusBitfieldConst = 7
	RW2x2	EntertainmentPlayStatusBitfieldConst = 8
	RW3x2	EntertainmentPlayStatusBitfieldConst = 9
	RW4x2	EntertainmentPlayStatusBitfieldConst = 10
	SkipAhead2	EntertainmentPlayStatusBitfieldConst = 11
	SkipBack2	EntertainmentPlayStatusBitfieldConst = 12
	JogAhead2	EntertainmentPlayStatusBitfieldConst = 13
	JogBack2	EntertainmentPlayStatusBitfieldConst = 14
	SeekUp2	EntertainmentPlayStatusBitfieldConst = 15
	SeekDown2	EntertainmentPlayStatusBitfieldConst = 16
	ScanUp2	EntertainmentPlayStatusBitfieldConst = 17
	ScanDown2	EntertainmentPlayStatusBitfieldConst = 18
	TuneUp2	EntertainmentPlayStatusBitfieldConst = 19
	TuneDown2	EntertainmentPlayStatusBitfieldConst = 20
	SlowMotion75x2	EntertainmentPlayStatusBitfieldConst = 21
	SlowMotion5x2	EntertainmentPlayStatusBitfieldConst = 22
	SlowMotion25x2	EntertainmentPlayStatusBitfieldConst = 23
	SlowMotion125x2	EntertainmentPlayStatusBitfieldConst = 24
	SourceRenaming	EntertainmentPlayStatusBitfieldConst = 25
)

func (e EntertainmentPlayStatusBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
		case 25:
			return "Source renaming"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusBitfieldConst", int(e))
	}
}

type EntertainmentGroupBitfieldConst uint16
const (
	File4	EntertainmentGroupBitfieldConst = 0
	PlaylistName3	EntertainmentGroupBitfieldConst = 1
	GenreName3	EntertainmentGroupBitfieldConst = 2
	AlbumName3	EntertainmentGroupBitfieldConst = 3
	ArtistName3	EntertainmentGroupBitfieldConst = 4
	TrackName3	EntertainmentGroupBitfieldConst = 5
	StationName3	EntertainmentGroupBitfieldConst = 6
	StationNumber3	EntertainmentGroupBitfieldConst = 7
	FavouriteNumber3	EntertainmentGroupBitfieldConst = 8
	PlayQueue4	EntertainmentGroupBitfieldConst = 9
	ContentInfo3	EntertainmentGroupBitfieldConst = 10
)

func (e EntertainmentGroupBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentGroupBitfieldConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupBitfieldConst", int(e))
	}
}

type ThrusterControlEventsConst uint16
const (
	AnotherDeviceControllingThruster	ThrusterControlEventsConst = 0
	BoatSpeedTooFastToSafelyUseThruster	ThrusterControlEventsConst = 1
)

func (e ThrusterControlEventsConst) GoString() string {return e.String() }
func (e ThrusterControlEventsConst) String() string {
	switch e {
		case 0:
			return "Another device controlling thruster"
		case 1:
			return "Boat speed too fast to safely use thruster"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterControlEventsConst", int(e))
	}
}

type ThrusterMotorEventsConst uint16
const (
	MotorOverTemperatureCutout	ThrusterMotorEventsConst = 0
	MotorOverCurrentCutout	ThrusterMotorEventsConst = 1
	LowOilLevelWarning	ThrusterMotorEventsConst = 2
	OilOverTemperatureWarning	ThrusterMotorEventsConst = 3
	ControllerUnderVoltageCutout	ThrusterMotorEventsConst = 4
	ManufacturerDefined	ThrusterMotorEventsConst = 5
)

func (e ThrusterMotorEventsConst) GoString() string {return e.String() }
func (e ThrusterMotorEventsConst) String() string {
	switch e {
		case 0:
			return "Motor over temperature cutout"
		case 1:
			return "Motor over current cutout"
		case 2:
			return "Low oil level warning"
		case 3:
			return "Oil over temperature warning"
		case 4:
			return "Controller under voltage cutout"
		case 5:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorEventsConst", int(e))
	}
}

type WindlassControlConst uint16
const (
	AnotherDeviceControllingWindlass	WindlassControlConst = 0
)

func (e WindlassControlConst) GoString() string {return e.String() }
func (e WindlassControlConst) String() string {
	switch e {
		case 0:
			return "Another device controlling windlass"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassControlConst", int(e))
	}
}

type WindlassOperationConst uint16
const (
	SystemError	WindlassOperationConst = 0
	SensorError	WindlassOperationConst = 1
	NoWindlassMotionDetected	WindlassOperationConst = 2
	RetrievalDockingDistanceReached	WindlassOperationConst = 3
	EndOfRodeReached	WindlassOperationConst = 4
)

func (e WindlassOperationConst) GoString() string {return e.String() }
func (e WindlassOperationConst) String() string {
	switch e {
		case 0:
			return "System error"
		case 1:
			return "Sensor error"
		case 2:
			return "No windlass motion detected"
		case 3:
			return "Retrieval docking distance reached"
		case 4:
			return "End of rode reached"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassOperationConst", int(e))
	}
}

type WindlassMonitoringConst uint16
const (
	ControllerUnderVoltageCutOut	WindlassMonitoringConst = 0
	ControllerOverCurrentCutOut	WindlassMonitoringConst = 1
	ControllerOverTemperatureCutOut	WindlassMonitoringConst = 2
	ManufacturerDefined2	WindlassMonitoringConst = 3
)

func (e WindlassMonitoringConst) GoString() string {return e.String() }
func (e WindlassMonitoringConst) String() string {
	switch e {
		case 0:
			return "Controller under voltage cut-out"
		case 1:
			return "Controller over current cut-out"
		case 2:
			return "Controller over temperature cut-out"
		case 3:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMonitoringConst", int(e))
	}
}

type EntertainmentRepeatBitfieldConst uint16
const (
	Song	EntertainmentRepeatBitfieldConst = 0
	PlayQueue5	EntertainmentRepeatBitfieldConst = 1
)

func (e EntertainmentRepeatBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentRepeatBitfieldConst) String() string {
	switch e {
		case 0:
			return "Song"
		case 1:
			return "Play queue"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatBitfieldConst", int(e))
	}
}

type EntertainmentShuffleBitfieldConst uint16
const (
	PlayQueue6	EntertainmentShuffleBitfieldConst = 0
	All3	EntertainmentShuffleBitfieldConst = 1
)

func (e EntertainmentShuffleBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentShuffleBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play queue"
		case 1:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleBitfieldConst", int(e))
	}
}
		
var pgnList = []PgnInfo{
	{
		PGN: 59392,
		Description: "ISO Acknowledgement",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoAcknowledgement,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoControlConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 59904,
		Description: "ISO Request",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoRequest,
		FieldInfo: map[int]FieldDescriptor{
		1: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60160,
		Description: "ISO Transport Protocol, Data Transfer",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolDataTransfer,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 56,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Request To Send",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementRequestToSend,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoCommandConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Clear To Send",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementClearToSend,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoCommandConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		5: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - End Of Message",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementEndOfMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoCommandConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		5: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Broadcast Announce",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoCommandConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		5: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Abort",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementAbort,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"IsoCommandConst",
			1,
			false,
			},
		2: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		
		4: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 60928,
		Description: "ISO Address Claim",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoAddressClaim,
		FieldInfo: map[int]FieldDescriptor{
		1: { 21,
			false,
			"*uint32",
			1,
			false,
			},
		2: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		3: { 3,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 5,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"DeviceFunctionConst",
			1,
			false,
			},
		
		7: { 7,
			false,
			"DeviceClassConst",
			1,
			false,
			},
		8: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		10: { 1,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 61184,
		Description: "Seatalk: Wireless Keypad Light Control",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkWirelessKeypadLightControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 61184,
		Description: "Seatalk: Wireless Keypad Control",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkWirelessKeypadControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 61184,
		Description: "Victron Battery Register",
		Fast: false,
		ManId: 358,
		Decoder: DecodeVictronBatteryRegister,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 65001,
		Description: "Bus #1 Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseCBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		
		},
	},
	{
		PGN: 65002,
		Description: "Bus #1 Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseBBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		
		},
	},
	{
		PGN: 65003,
		Description: "Bus #1 Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseABasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		
		},
	},
	{
		PGN: 65004,
		Description: "Bus #1 Average Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1AverageBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		
		},
	},
	{
		PGN: 65005,
		Description: "Utility Total AC Energy",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityTotalAcEnergy,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		2: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 65006,
		Description: "Utility Phase C AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65007,
		Description: "Utility Phase C AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65008,
		Description: "Utility Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65009,
		Description: "Utility Phase B AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65010,
		Description: "Utility Phase B AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65011,
		Description: "Utility Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65012,
		Description: "Utility Phase A AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseAAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65013,
		Description: "Utility Phase A AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseAAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65014,
		Description: "Utility Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseABasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65015,
		Description: "Utility Total AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityTotalAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65016,
		Description: "Utility Total AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityTotalAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65017,
		Description: "Utility Average Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityAverageBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65018,
		Description: "Generator Total AC Energy",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorTotalAcEnergy,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		2: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 65019,
		Description: "Generator Phase C AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65020,
		Description: "Generator Phase C AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65021,
		Description: "Generator Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65022,
		Description: "Generator Phase B AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65023,
		Description: "Generator Phase B AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65024,
		Description: "Generator Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65025,
		Description: "Generator Phase A AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseAAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65026,
		Description: "Generator Phase A AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseAAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65027,
		Description: "Generator Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseABasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65028,
		Description: "Generator Total AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorTotalAcReactivePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 16,
			false,
			"*float32",
			6.10352e-05,
			false,
			},
		3: { 2,
			false,
			"PowerFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65029,
		Description: "Generator Total AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorTotalAcPower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 65030,
		Description: "Generator Average Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorAverageBasicAcQuantities,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0078125,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 65240,
		Description: "ISO Commanded Address",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoCommandedAddress,
		FieldInfo: map[int]FieldDescriptor{
		1: { 21,
			false,
			"interface{}",
			1,
			false,
			},
		2: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		3: { 3,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 5,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"DeviceFunctionConst",
			1,
			false,
			},
		
		7: { 7,
			false,
			"DeviceClassConst",
			1,
			false,
			},
		8: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 65280,
		Description: "Furuno: Heave",
		Fast: false,
		ManId: 1855,
		Decoder: DecodeFurunoHeave,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.001,
			true,
			},
		
		},
	},
	{
		PGN: 65284,
		Description: "Maretron: Proprietary DC Breaker Current",
		Fast: false,
		ManId: 137,
		Decoder: DecodeMaretronProprietaryDcBreakerCurrent,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		
		},
	},
	{
		PGN: 65285,
		Description: "Airmar: Boot State Acknowledgment",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarBootStateAcknowledgment,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 3,
			false,
			"BootStateConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65285,
		Description: "Lowrance: Temperature",
		Fast: false,
		ManId: 140,
		Decoder: DecodeLowranceTemperature,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"TemperatureSourceConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		},
	},
	{
		PGN: 65286,
		Description: "Chetco: Dimmer",
		Fast: false,
		ManId: 409,
		Decoder: DecodeChetcoDimmer,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 65286,
		Description: "Airmar: Boot State Request",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarBootStateRequest,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65287,
		Description: "Airmar: Access Level",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarAccessLevel,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 3,
			false,
			"AccessLevelConst",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 65287,
		Description: "Simnet: Configure Temperature Sensor",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetConfigureTemperatureSensor,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65288,
		Description: "Seatalk: Alarm",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkAlarm,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		5: { 8,
			false,
			"SeatalkAlarmStatusConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SeatalkAlarmIdConst",
			1,
			false,
			},
		7: { 8,
			false,
			"SeatalkAlarmGroupConst",
			1,
			false,
			},
		8: { 16,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 65289,
		Description: "Simnet: Trim Tab Sensor Calibration",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetTrimTabSensorCalibration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65290,
		Description: "Simnet: Paddle Wheel Speed Configuration",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetPaddleWheelSpeedConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65292,
		Description: "Simnet: Clear Fluid Level Warnings",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetClearFluidLevelWarnings,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65293,
		Description: "Simnet: LGC-2000 Configuration",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetLgc2000Configuration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65309,
		Description: "Navico: Wireless Battery Status",
		Fast: false,
		ManId: 275,
		Decoder: DecodeNavicoWirelessBatteryStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65312,
		Description: "Navico: Wireless Signal Status",
		Fast: false,
		ManId: 275,
		Decoder: DecodeNavicoWirelessSignalStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65345,
		Description: "Seatalk: Pilot Wind Datum",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkPilotWindDatum,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		
		},
	},
	{
		PGN: 65359,
		Description: "Seatalk: Pilot Heading",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkPilotHeading,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		
		},
	},
	{
		PGN: 65360,
		Description: "Seatalk: Pilot Locked Heading",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkPilotLockedHeading,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		
		},
	},
	{
		PGN: 65361,
		Description: "Seatalk: Silence Alarm",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkSilenceAlarm,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"SeatalkAlarmIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"SeatalkAlarmGroupConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65371,
		Description: "Seatalk: Keypad Message",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkKeypadMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65374,
		Description: "SeaTalk: Keypad Heartbeat",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkKeypadHeartbeat,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65379,
		Description: "Seatalk: Pilot Mode",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkPilotMode,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		5: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		6: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65408,
		Description: "Airmar: Depth Quality Factor",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarDepthQualityFactor,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 4,
			false,
			"AirmarDepthQualityFactorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65409,
		Description: "Airmar: Speed Pulse Count",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarSpeedPulseCount,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.001,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 65410,
		Description: "Airmar: Device Information",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarDeviceInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		},
	},
	{
		PGN: 65480,
		Description: "Simnet: Autopilot Mode",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetAutopilotMode,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Request group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaRequestGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Command group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaCommandGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 4,
			false,
			"PriorityConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Acknowledge group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaAcknowledgeGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 4,
			false,
			"PgnErrorCodeConst",
			1,
			false,
			},
		4: { 4,
			false,
			"TransmissionIntervalConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Read Fields group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaReadFieldsGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		5: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Read Fields reply group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaReadFieldsReplyGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		5: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Write Fields group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaWriteFieldsGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		5: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126208,
		Description: "NMEA - Write Fields reply group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaWriteFieldsReplyGroupFunction,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"GroupFunctionConst",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		5: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126464,
		Description: "PGN List (Transmit and Receive)",
		Fast: true,
		ManId: 0,
		Decoder: DecodePgnListTransmitAndReceive,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"PgnListFunctionConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Seatalk1: Pilot Mode",
		Fast: true,
		ManId: 1851,
		Decoder: DecodeSeatalk1PilotMode,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 24,
			false,
			"interface{}",
			1,
			false,
			},
		7: { 8,
			false,
			"SeatalkPilotModeConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		10: { 80,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Media Control",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionMediaControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"FusionCommandConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Sirius Control",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSiriusControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"FusionSiriusCommandConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Request Status",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionRequestStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Set Source",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSetSource,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Set Mute",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSetMute,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"FusionMuteCommandConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Set Zone Volume",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSetZoneVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Fusion: Set All Volumes",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSetAllVolumes,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Seatalk1: Keystroke",
		Fast: true,
		ManId: 1851,
		Decoder: DecodeSeatalk1Keystroke,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"SeatalkKeystrokeConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 112,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Seatalk1: Device Identification",
		Fast: true,
		ManId: 1851,
		Decoder: DecodeSeatalk1DeviceIdentification,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 8,
			false,
			"SeatalkDeviceIdConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Attitude Offset",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarAttitudeOffset,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		6: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		7: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Calibrate Compass",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateCompass,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 8,
			false,
			"AirmarCalibrateFunctionConst",
			1,
			false,
			},
		6: { 8,
			false,
			"AirmarCalibrateStatusConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		9: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		11: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		12: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		13: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		14: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		15: { 16,
			false,
			"*float32",
			0.05,
			true,
			},
		16: { 16,
			false,
			"*float32",
			0.05,
			true,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: True Wind Options",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarTrueWindOptions,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Simulate Mode",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSimulateMode,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Calibrate Depth",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateDepth,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Calibrate Speed",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateSpeed,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Calibrate Temperature",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateTemperature,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 2,
			false,
			"AirmarTemperatureInstanceConst",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Speed Filter None",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSpeedFilterNone,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Speed Filter IIR",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSpeedFilterIir,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Temperature Filter None",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarTemperatureFilterNone,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Temperature Filter IIR",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarTemperatureFilterIir,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: NMEA 2000 options",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarNmea2000Options,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"AirmarCommandConst",
			1,
			false,
			},
		5: { 2,
			false,
			"AirmarTransmissionIntervalConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126720,
		Description: "Airmar: Addressable Multi-Frame",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarAddressableMultiFrame,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126720,
		Description: "Maretron: Slave Response",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSlaveResponse,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126983,
		Description: "Alert",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlert,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		11: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		12: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		13: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		14: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		15: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		17: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		18: { 4,
			false,
			"AlertTriggerConditionConst",
			1,
			false,
			},
		19: { 4,
			false,
			"AlertThresholdStatusConst",
			1,
			false,
			},
		20: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		21: { 8,
			false,
			"AlertStateConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 126984,
		Description: "Alert Response",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertResponse,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		11: { 2,
			false,
			"AlertResponseCommandConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126985,
		Description: "Alert Text",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertText,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"AlertLanguageIdConst",
			1,
			false,
			},
		11: { 0,
			true,
			"string",
			1,
			false,
			},
		12: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 126986,
		Description: "Alert Configuration",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		15: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126987,
		Description: "Alert Threshold",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertThreshold,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126988,
		Description: "Alert Value",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertValue,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"AlertTypeConst",
			1,
			false,
			},
		2: { 4,
			false,
			"AlertCategoryConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126992,
		Description: "System Time",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSystemTime,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"SystemTimeConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		},
	},
	{
		PGN: 126993,
		Description: "Heartbeat",
		Fast: false,
		ManId: 0,
		Decoder: DecodeHeartbeat,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*float32",
			0.001,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"ControllerStateConst",
			1,
			false,
			},
		4: { 2,
			false,
			"ControllerStateConst",
			1,
			false,
			},
		5: { 2,
			false,
			"EquipmentStatusConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 126996,
		Description: "Product Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeProductInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*float32",
			0.001,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 256,
			false,
			"string",
			1,
			false,
			},
		4: { 256,
			false,
			"string",
			1,
			false,
			},
		5: { 256,
			false,
			"string",
			1,
			false,
			},
		6: { 256,
			false,
			"string",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 126998,
		Description: "Configuration Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeConfigurationInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 0,
			true,
			"string",
			1,
			false,
			},
		2: { 0,
			true,
			"string",
			1,
			false,
			},
		3: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 127233,
		Description: "Man Overboard Notification",
		Fast: true,
		ManId: 0,
		Decoder: DecodeManOverboardNotification,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 3,
			false,
			"MobStatusConst",
			1,
			false,
			},
		
		5: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 3,
			false,
			"MobPositionSourceConst",
			1,
			false,
			},
		
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		11: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		12: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		14: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		15: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		16: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		17: { 3,
			false,
			"LowBatteryConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127237,
		Description: "Heading/Track control",
		Fast: true,
		ManId: 0,
		Decoder: DecodeHeadingTrackControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		2: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		3: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 3,
			false,
			"SteeringModeConst",
			1,
			false,
			},
		6: { 3,
			false,
			"TurnModeConst",
			1,
			false,
			},
		7: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		9: { 3,
			false,
			"DirectionRudderConst",
			1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		11: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		12: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		13: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		14: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		15: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		16: { 16,
			false,
			"*float32",
			3.125e-05,
			true,
			},
		17: { 16,
			false,
			"*int16",
			1,
			true,
			},
		18: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		},
	},
	{
		PGN: 127245,
		Description: "Rudder",
		Fast: false,
		ManId: 0,
		Decoder: DecodeRudder,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 3,
			false,
			"DirectionRudderConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		
		},
	},
	{
		PGN: 127250,
		Description: "Vessel Heading",
		Fast: false,
		ManId: 0,
		Decoder: DecodeVesselHeading,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		4: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		5: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127251,
		Description: "Rate of Turn",
		Fast: false,
		ManId: 0,
		Decoder: DecodeRateOfTurn,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			3.125e-08,
			true,
			},
		
		},
	},
	{
		PGN: 127252,
		Description: "Heave",
		Fast: false,
		ManId: 0,
		Decoder: DecodeHeave,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		
		},
	},
	{
		PGN: 127257,
		Description: "Attitude",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAttitude,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		3: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		4: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		
		},
	},
	{
		PGN: 127258,
		Description: "Magnetic Variation",
		Fast: false,
		ManId: 0,
		Decoder: DecodeMagneticVariation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"MagneticVariationConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		
		},
	},
	{
		PGN: 127488,
		Description: "Engine Parameters, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEngineParametersRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EngineInstanceConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.25,
			false,
			},
		3: { 16,
			false,
			"*float32",
			100,
			false,
			},
		4: { 8,
			false,
			"*int8",
			1,
			true,
			},
		
		},
	},
	{
		PGN: 127489,
		Description: "Engine Parameters, Dynamic",
		Fast: true,
		ManId: 0,
		Decoder: DecodeEngineParametersDynamic,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EngineInstanceConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			100,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		6: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			100,
			false,
			},
		9: { 16,
			false,
			"*float32",
			1000,
			false,
			},
		
		11: { 16,
			false,
			"EngineStatus1Const",
			1,
			false,
			},
		12: { 16,
			false,
			"EngineStatus2Const",
			1,
			false,
			},
		13: { 8,
			false,
			"*int8",
			1,
			true,
			},
		14: { 8,
			false,
			"*int8",
			1,
			true,
			},
		},
	},
	{
		PGN: 127490,
		Description: "Electric Drive Status, Dynamic",
		Fast: true,
		ManId: 0,
		Decoder: DecodeElectricDriveStatusDynamic,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 127491,
		Description: "Electric Energy Storage Status, Dynamic",
		Fast: true,
		ManId: 0,
		Decoder: DecodeElectricEnergyStorageStatusDynamic,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			60,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		8: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		9: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127493,
		Description: "Transmission Parameters, Dynamic",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTransmissionParametersDynamic,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EngineInstanceConst",
			1,
			false,
			},
		2: { 2,
			false,
			"GearStatusConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			100,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127494,
		Description: "Electric Drive Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeElectricDriveInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.25,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		11: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		12: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		13: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 127495,
		Description: "Electric Energy Storage Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeElectricEnergyStorageInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		9: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		15: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		16: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127496,
		Description: "Trip Parameters, Vessel",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTripParametersVessel,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		},
	},
	{
		PGN: 127497,
		Description: "Trip Parameters, Engine",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTripParametersEngine,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EngineInstanceConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		4: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		5: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		},
	},
	{
		PGN: 127498,
		Description: "Engine Parameters, Static",
		Fast: true,
		ManId: 0,
		Decoder: DecodeEngineParametersStatic,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EngineInstanceConst",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.25,
			false,
			},
		3: { 136,
			false,
			"string",
			1,
			false,
			},
		4: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 127500,
		Description: "Load Controller Connection State/Control",
		Fast: false,
		ManId: 0,
		Decoder: DecodeLoadControllerConnectionStateControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127501,
		Description: "Binary Switch Bank Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBinarySwitchBankStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		3: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		4: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		5: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		6: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		7: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		8: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		9: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		10: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		11: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		12: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		13: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		14: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		15: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		16: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		17: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		18: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		19: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		20: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		21: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		22: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		23: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		24: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		25: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		26: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		27: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		28: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		29: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 127502,
		Description: "Switch Bank Control",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSwitchBankControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		3: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		4: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		5: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		6: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		7: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		8: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		9: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		10: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		11: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		12: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		13: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		14: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		15: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		16: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		17: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		18: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		19: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		20: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		21: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		22: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		23: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		24: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		25: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		26: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		27: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		28: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		29: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 127503,
		Description: "AC Input Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAcInputStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127504,
		Description: "AC Output Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAcOutputStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127505,
		Description: "Fluid Level",
		Fast: false,
		ManId: 0,
		Decoder: DecodeFluidLevel,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"TankTypeConst",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.004,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.1,
			false,
			},
		
		},
	},
	{
		PGN: 127506,
		Description: "DC Detailed Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDcDetailedStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"DcSourceConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*float32",
			60,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 127507,
		Description: "Charger Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeChargerStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 4,
			false,
			"ChargerStateConst",
			1,
			false,
			},
		4: { 4,
			false,
			"ChargerModeConst",
			1,
			false,
			},
		5: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		6: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		8: { 16,
			false,
			"*float32",
			60,
			false,
			},
		},
	},
	{
		PGN: 127508,
		Description: "Battery Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBatteryStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127509,
		Description: "Inverter Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeInverterStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 4,
			false,
			"InverterStateConst",
			1,
			false,
			},
		5: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127510,
		Description: "Charger Configuration Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeChargerConfigurationStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 4,
			false,
			"ChargingAlgorithmConst",
			1,
			false,
			},
		7: { 4,
			false,
			"ChargerModeConst",
			1,
			false,
			},
		8: { 4,
			false,
			"DeviceTempStateConst",
			1,
			false,
			},
		9: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		10: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		11: { 16,
			false,
			"*float32",
			60,
			false,
			},
		},
	},
	{
		PGN: 127511,
		Description: "Inverter Configuration Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeInverterConfigurationStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 127512,
		Description: "AGS Configuration Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAgsConfigurationStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127513,
		Description: "Battery Configuration Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeBatteryConfigurationStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"BatteryTypeConst",
			1,
			false,
			},
		3: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		5: { 4,
			false,
			"BatteryVoltageConst",
			1,
			false,
			},
		6: { 4,
			false,
			"BatteryChemistryConst",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 8,
			false,
			"*int8",
			1,
			true,
			},
		9: { 8,
			false,
			"*float32",
			0.002,
			false,
			},
		10: { 8,
			false,
			"*int8",
			1,
			true,
			},
		},
	},
	{
		PGN: 127514,
		Description: "AGS Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAgsStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127744,
		Description: "AC Power / Current - Phase A",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseA,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 127745,
		Description: "AC Power / Current - Phase B",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseB,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 127746,
		Description: "AC Power / Current - Phase C",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseC,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 127750,
		Description: "Converter Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeConverterStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"ConverterStateConst",
			1,
			false,
			},
		4: { 2,
			false,
			"GoodWarningErrorConst",
			1,
			false,
			},
		5: { 2,
			false,
			"GoodWarningErrorConst",
			1,
			false,
			},
		6: { 2,
			false,
			"GoodWarningErrorConst",
			1,
			false,
			},
		7: { 2,
			false,
			"GoodWarningErrorConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 127751,
		Description: "DC Voltage/Current",
		Fast: false,
		ManId: 0,
		Decoder: DecodeDcVoltageCurrent,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		4: { 24,
			false,
			"*float32",
			0.01,
			true,
			},
		
		},
	},
	{
		PGN: 128000,
		Description: "Leeway Angle",
		Fast: false,
		ManId: 0,
		Decoder: DecodeLeewayAngle,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		
		},
	},
	{
		PGN: 128001,
		Description: "Vessel Acceleration",
		Fast: false,
		ManId: 0,
		Decoder: DecodeVesselAcceleration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*int16",
			1,
			true,
			},
		3: { 16,
			false,
			"*int16",
			1,
			true,
			},
		4: { 16,
			false,
			"*int16",
			1,
			true,
			},
		
		},
	},
	{
		PGN: 128002,
		Description: "Electric Drive Status, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeElectricDriveStatusRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		5: { 16,
			false,
			"*float32",
			0.25,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		},
	},
	{
		PGN: 128003,
		Description: "Electric Energy Storage Status, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeElectricEnergyStorageStatusRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		
		},
	},
	{
		PGN: 128006,
		Description: "Thruster Control Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterControlStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 4,
			false,
			"ThrusterDirectionControlConst",
			1,
			false,
			},
		4: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		5: { 2,
			false,
			"ThrusterRetractControlConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"ThrusterControlEventsConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*float32",
			0.005,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		},
	},
	{
		PGN: 128007,
		Description: "Thruster Information",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"ThrusterMotorTypeConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.25,
			false,
			},
		},
	},
	{
		PGN: 128008,
		Description: "Thruster Motor Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterMotorStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"ThrusterMotorEventsConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			60,
			false,
			},
		},
	},
	{
		PGN: 128259,
		Description: "Speed",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSpeed,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		4: { 8,
			false,
			"WaterReferenceConst",
			1,
			false,
			},
		5: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 128267,
		Description: "Water Depth",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWaterDepth,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		4: { 8,
			false,
			"*float32",
			10,
			false,
			},
		},
	},
	{
		PGN: 128275,
		Description: "Distance Log",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDistanceLog,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 128520,
		Description: "Tracked Target Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTrackedTargetData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"TrackingConst",
			1,
			false,
			},
		4: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 1,
			false,
			"TargetAcquisitionConst",
			1,
			false,
			},
		6: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		8: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		9: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		11: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		12: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		13: { 32,
			false,
			"*float32",
			0.001,
			true,
			},
		14: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		15: { 1784,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 128538,
		Description: "Elevator Car Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeElevatorCarStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		15: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		16: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		17: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		18: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		19: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		20: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		22: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		23: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		24: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		25: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		26: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		27: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		28: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		29: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		30: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		31: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 128768,
		Description: "Elevator Motor Control",
		Fast: false,
		ManId: 0,
		Decoder: DecodeElevatorMotorControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 128769,
		Description: "Elevator Deck Push Button",
		Fast: false,
		ManId: 0,
		Decoder: DecodeElevatorDeckPushButton,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 128776,
		Description: "Windlass Control Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWindlassControlStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"WindlassDirectionConst",
			1,
			false,
			},
		4: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		5: { 2,
			false,
			"SpeedTypeConst",
			1,
			false,
			},
		
		7: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		8: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		9: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		10: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		11: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		12: { 8,
			false,
			"*float32",
			0.005,
			false,
			},
		13: { 4,
			false,
			"WindlassControlConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 128777,
		Description: "Anchor Windlass Operating Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAnchorWindlassOperatingStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"WindlassDirectionConst",
			1,
			false,
			},
		4: { 2,
			false,
			"WindlassMotionConst",
			1,
			false,
			},
		5: { 2,
			false,
			"RodeTypeConst",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		9: { 2,
			false,
			"DockingStatusConst",
			1,
			false,
			},
		10: { 6,
			false,
			"WindlassOperationConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 128778,
		Description: "Anchor Windlass Monitoring Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAnchorWindlassMonitoringStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"WindlassMonitoringConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*float32",
			0.2,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*float32",
			60,
			false,
			},
		
		},
	},
	{
		PGN: 128780,
		Description: "Linear Actuator Control/Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeLinearActuatorControlStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129025,
		Description: "Position, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodePositionRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		2: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		},
	},
	{
		PGN: 129026,
		Description: "COG & SOG, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeCogSogRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		},
	},
	{
		PGN: 129027,
		Description: "Position Delta, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodePositionDeltaRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*int16",
			1,
			true,
			},
		4: { 16,
			false,
			"*int16",
			1,
			true,
			},
		
		},
	},
	{
		PGN: 129028,
		Description: "Altitude Delta, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAltitudeDeltaRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*int16",
			1,
			true,
			},
		3: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		6: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		7: { 16,
			false,
			"*int16",
			1,
			true,
			},
		},
	},
	{
		PGN: 129029,
		Description: "GNSS Position Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssPositionData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		4: { 64,
			false,
			"*float32",
			1e-16,
			true,
			},
		5: { 64,
			false,
			"*float32",
			1e-16,
			true,
			},
		6: { 64,
			false,
			"*float32",
			1e-06,
			true,
			},
		7: { 4,
			false,
			"GnsConst",
			1,
			false,
			},
		8: { 4,
			false,
			"GnsMethodConst",
			1,
			false,
			},
		9: { 2,
			false,
			"GnsIntegrityConst",
			1,
			false,
			},
		
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		13: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		14: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		15: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129033,
		Description: "Time & Date",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTimeDate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		3: { 16,
			false,
			"*float32",
			60,
			true,
			},
		},
	},
	{
		PGN: 129038,
		Description: "AIS Class A Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassAPositionReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		8: { 6,
			false,
			"TimeStampConst",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		11: { 19,
			false,
			"interface{}",
			1,
			false,
			},
		12: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		13: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		14: { 16,
			false,
			"*float32",
			3.125e-05,
			true,
			},
		15: { 4,
			false,
			"NavStatusConst",
			1,
			false,
			},
		16: { 2,
			false,
			"AisSpecialManeuverConst",
			1,
			false,
			},
		
		
		
		20: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129039,
		Description: "AIS Class B Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBPositionReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		8: { 6,
			false,
			"TimeStampConst",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		11: { 19,
			false,
			"interface{}",
			1,
			false,
			},
		12: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		13: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		
		
		16: { 1,
			false,
			"AisTypeConst",
			1,
			false,
			},
		17: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		18: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		19: { 1,
			false,
			"AisBandConst",
			1,
			false,
			},
		20: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		21: { 1,
			false,
			"AisModeConst",
			1,
			false,
			},
		22: { 1,
			false,
			"AisCommunicationStateConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129040,
		Description: "AIS Class B Extended Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBExtendedPositionReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		8: { 6,
			false,
			"TimeStampConst",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		
		
		14: { 8,
			false,
			"ShipTypeConst",
			1,
			false,
			},
		15: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		
		17: { 4,
			false,
			"PositionFixDeviceConst",
			1,
			false,
			},
		18: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		19: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		20: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		21: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		22: { 160,
			false,
			"string",
			1,
			false,
			},
		23: { 1,
			false,
			"AvailableConst",
			1,
			false,
			},
		24: { 1,
			false,
			"AisModeConst",
			1,
			false,
			},
		
		26: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129041,
		Description: "AIS Aids to Navigation (AtoN) Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAidsToNavigationAtonReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		8: { 6,
			false,
			"TimeStampConst",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		11: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		12: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		13: { 5,
			false,
			"AtonTypeConst",
			1,
			false,
			},
		14: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		15: { 1,
			false,
			"YesNoConst",
			1,
			false,
			},
		16: { 1,
			false,
			"AisAssignedModeConst",
			1,
			false,
			},
		
		18: { 4,
			false,
			"PositionFixDeviceConst",
			1,
			false,
			},
		
		20: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		21: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		23: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 129044,
		Description: "Datum",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDatum,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"string",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		3: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		4: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		5: { 32,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 129045,
		Description: "User Datum",
		Fast: true,
		ManId: 0,
		Decoder: DecodeUserDatum,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		2: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		3: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		4: { 32,
			false,
			"*float32",
			1,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1,
			true,
			},
		6: { 32,
			false,
			"*float32",
			1,
			true,
			},
		7: { 32,
			false,
			"*float32",
			1,
			true,
			},
		8: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		9: { 32,
			false,
			"*float32",
			1,
			true,
			},
		10: { 32,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 129283,
		Description: "Cross Track Error",
		Fast: false,
		ManId: 0,
		Decoder: DecodeCrossTrackError,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		
		},
	},
	{
		PGN: 129284,
		Description: "Navigation Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNavigationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		6: { 2,
			false,
			"BearingModeConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		11: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		12: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		13: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		14: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		15: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		},
	},
	{
		PGN: 129285,
		Description: "Navigation - Route/WP Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNavigationRouteWpInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 3,
			false,
			"DirectionConst",
			1,
			false,
			},
		6: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		8: { 0,
			true,
			"string",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129291,
		Description: "Set & Drift, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSetDriftRapidUpdate,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		},
	},
	{
		PGN: 129301,
		Description: "Navigation - Route / Time to+from Mark",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNavigationRouteTimeToFromMark,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 32,
			false,
			"*float32",
			0.001,
			true,
			},
		3: { 4,
			false,
			"MarkTypeConst",
			1,
			false,
			},
		
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 129302,
		Description: "Bearing and Distance between two Marks",
		Fast: true,
		ManId: 0,
		Decoder: DecodeBearingAndDistanceBetweenTwoMarks,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		3: { 2,
			false,
			"BearingModeConst",
			1,
			false,
			},
		
		5: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 4,
			false,
			"MarkTypeConst",
			1,
			false,
			},
		8: { 4,
			false,
			"MarkTypeConst",
			1,
			false,
			},
		9: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 129538,
		Description: "GNSS Control Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssControlStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 3,
			false,
			"GnssModeConst",
			1,
			false,
			},
		6: { 3,
			false,
			"DgnssModeConst",
			1,
			false,
			},
		7: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		10: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129539,
		Description: "GNSS DOPs",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGnssDops,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 3,
			false,
			"GnssModeConst",
			1,
			false,
			},
		3: { 3,
			false,
			"GnssModeConst",
			1,
			false,
			},
		
		5: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		},
	},
	{
		PGN: 129540,
		Description: "GNSS Sats in View",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssSatsInView,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"RangeResidualModeConst",
			1,
			false,
			},
		
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129541,
		Description: "GPS Almanac Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGpsAlmanacData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			4.76837e-07,
			false,
			},
		5: { 8,
			false,
			"*float32",
			4096,
			false,
			},
		6: { 16,
			false,
			"*float32",
			1.90735e-06,
			true,
			},
		7: { 16,
			false,
			"*float32",
			3.63798e-12,
			true,
			},
		8: { 24,
			false,
			"*float32",
			0.000488281,
			false,
			},
		9: { 24,
			false,
			"*float32",
			1.19209e-07,
			true,
			},
		10: { 24,
			false,
			"*float32",
			1.19209e-07,
			true,
			},
		11: { 24,
			false,
			"*float32",
			1.19209e-07,
			true,
			},
		12: { 11,
			false,
			"*float32",
			9.53674e-07,
			true,
			},
		13: { 11,
			false,
			"*float32",
			3.63798e-12,
			true,
			},
		
		},
	},
	{
		PGN: 129542,
		Description: "GNSS Pseudorange Noise Statistics",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssPseudorangeNoiseStatistics,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129545,
		Description: "GNSS RAIM Output",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssRaimOutput,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129546,
		Description: "GNSS RAIM Settings",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGnssRaimSettings,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129547,
		Description: "GNSS Pseudorange Error Statistics",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssPseudorangeErrorStatistics,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129549,
		Description: "DGNSS Corrections",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDgnssCorrections,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129550,
		Description: "GNSS Differential Correction Receiver Interface",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssDifferentialCorrectionReceiverInterface,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129551,
		Description: "GNSS Differential Correction Receiver Signal",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssDifferentialCorrectionReceiverSignal,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129556,
		Description: "GLONASS Almanac Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGlonassAlmanacData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		
		4: { 1,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 5,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		11: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		12: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		13: { 28,
			false,
			"*uint32",
			1,
			false,
			},
		14: { 12,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 129792,
		Description: "AIS DGNSS Broadcast Binary Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisDgnssBroadcastBinaryMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		8: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		
		
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 0,
			true,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 129793,
		Description: "AIS UTC and Date Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisUtcAndDateReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		
		9: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 19,
			false,
			"interface{}",
			1,
			false,
			},
		11: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		
		14: { 4,
			false,
			"PositionFixDeviceConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129794,
		Description: "AIS Class A Static and Voyage Related Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassAStaticAndVoyageRelatedData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		5: { 56,
			false,
			"string",
			1,
			false,
			},
		6: { 160,
			false,
			"string",
			1,
			false,
			},
		7: { 8,
			false,
			"ShipTypeConst",
			1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		11: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		13: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		14: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		15: { 160,
			false,
			"string",
			1,
			false,
			},
		16: { 2,
			false,
			"AisVersionConst",
			1,
			false,
			},
		17: { 4,
			false,
			"PositionFixDeviceConst",
			1,
			false,
			},
		18: { 1,
			false,
			"AvailableConst",
			1,
			false,
			},
		
		20: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129795,
		Description: "AIS Addressed Binary Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAddressedBinaryMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		6: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		9: { 1,
			false,
			"*uint8",
			1,
			false,
			},
		
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 0,
			true,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 129796,
		Description: "AIS Acknowledge",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAcknowledge,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 2,
			false,
			"interface{}",
			1,
			false,
			},
		
		10: { 2,
			false,
			"interface{}",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129797,
		Description: "AIS Binary Broadcast Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisBinaryBroadcastMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 0,
			true,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 129798,
		Description: "AIS SAR Aircraft Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisSarAircraftPositionReport,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 1,
			false,
			"PositionAccuracyConst",
			1,
			false,
			},
		7: { 1,
			false,
			"RaimFlagConst",
			1,
			false,
			},
		8: { 6,
			false,
			"TimeStampConst",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		11: { 19,
			false,
			"interface{}",
			1,
			false,
			},
		12: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		13: { 32,
			false,
			"*float32",
			0.01,
			true,
			},
		14: { 8,
			false,
			"interface{}",
			1,
			false,
			},
		15: { 1,
			false,
			"AvailableConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129799,
		Description: "Radio Frequency/Mode/Power",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRadioFrequencyModePower,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*float32",
			10,
			false,
			},
		2: { 32,
			false,
			"*float32",
			10,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129800,
		Description: "AIS UTC/Date Inquiry",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisUtcDateInquiry,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		6: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 129801,
		Description: "AIS Addressed Safety Related Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAddressedSafetyRelatedMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		5: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 1,
			false,
			"*uint8",
			1,
			false,
			},
		
		10: { 936,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 129802,
		Description: "AIS Safety Related Broadcast Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisSafetyRelatedBroadcastMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		6: { 1296,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 129803,
		Description: "AIS Interrogation",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisInterrogation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		9: { 12,
			false,
			"*uint16",
			1,
			false,
			},
		
		11: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		12: { 12,
			false,
			"*uint16",
			1,
			false,
			},
		
		14: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		15: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		16: { 12,
			false,
			"*uint16",
			1,
			false,
			},
		
		
		19: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129804,
		Description: "AIS Assignment Mode Command",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAssignmentModeCommand,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		6: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 129805,
		Description: "AIS Data Link Management Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisDataLinkManagementMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 129806,
		Description: "AIS Channel Management",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisChannelManagement,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		6: { 7,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 7,
			false,
			"*uint8",
			1,
			false,
			},
		
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		12: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		13: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		14: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		
		16: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		17: { 7,
			false,
			"*uint8",
			1,
			false,
			},
		18: { 7,
			false,
			"*uint8",
			1,
			false,
			},
		
		20: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129807,
		Description: "AIS Class B Group Assignment",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBGroupAssignment,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		5: { 4,
			false,
			"TxRxModeConst",
			1,
			false,
			},
		
		7: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		8: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		9: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		10: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		11: { 4,
			false,
			"StationTypeConst",
			1,
			false,
			},
		
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		
		16: { 4,
			false,
			"ReportingIntervalConst",
			1,
			false,
			},
		17: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129808,
		Description: "DSC Distress Call Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDscDistressCallInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"DscFormatConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 40,
			false,
			"[]uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"DscNatureConst",
			1,
			false,
			},
		5: { 8,
			false,
			"DscSecondTelecommandConst",
			1,
			false,
			},
		6: { 48,
			false,
			"string",
			1,
			false,
			},
		7: { 48,
			false,
			"string",
			1,
			false,
			},
		8: { 0,
			true,
			"string",
			1,
			false,
			},
		9: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		10: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		11: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		12: { 40,
			false,
			"[]uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		16: { 48,
			false,
			"string",
			1,
			false,
			},
		17: { 48,
			false,
			"string",
			1,
			false,
			},
		18: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		19: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		20: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 129808,
		Description: "DSC Call Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDscCallInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"DscFormatConst",
			1,
			false,
			},
		2: { 8,
			false,
			"DscCategoryConst",
			1,
			false,
			},
		3: { 40,
			false,
			"[]uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"DscFirstTelecommandConst",
			1,
			false,
			},
		5: { 8,
			false,
			"DscSecondTelecommandConst",
			1,
			false,
			},
		6: { 48,
			false,
			"string",
			1,
			false,
			},
		7: { 48,
			false,
			"string",
			1,
			false,
			},
		8: { 0,
			true,
			"string",
			1,
			false,
			},
		9: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		10: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		11: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		12: { 40,
			false,
			"[]uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		16: { 48,
			false,
			"string",
			1,
			false,
			},
		17: { 48,
			false,
			"string",
			1,
			false,
			},
		18: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		19: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		20: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 129809,
		Description: "AIS Class B static data (msg 24 Part A)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBStaticDataMsg24PartA,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 160,
			false,
			"string",
			1,
			false,
			},
		5: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 129810,
		Description: "AIS Class B static data (msg 24 Part B)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBStaticDataMsg24PartB,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"AisMessageIdConst",
			1,
			false,
			},
		2: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 8,
			false,
			"ShipTypeConst",
			1,
			false,
			},
		5: { 56,
			false,
			"string",
			1,
			false,
			},
		6: { 56,
			false,
			"string",
			1,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		11: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		
		14: { 5,
			false,
			"AisTransceiverConst",
			1,
			false,
			},
		
		16: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130052,
		Description: "Loran-C TD Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLoranCTdData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		3: { 32,
			false,
			"*int32",
			1,
			true,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		5: { 32,
			false,
			"*int32",
			1,
			true,
			},
		6: { 32,
			false,
			"*int32",
			1,
			true,
			},
		7: { 32,
			false,
			"*int32",
			1,
			true,
			},
		8: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		9: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		10: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		11: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		12: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		13: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		14: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130053,
		Description: "Loran-C Range Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLoranCRangeData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 32,
			false,
			"*int32",
			1,
			true,
			},
		3: { 32,
			false,
			"*int32",
			1,
			true,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		5: { 32,
			false,
			"*int32",
			1,
			true,
			},
		6: { 32,
			false,
			"*int32",
			1,
			true,
			},
		7: { 32,
			false,
			"*int32",
			1,
			true,
			},
		8: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		9: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		10: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		11: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		12: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		13: { 4,
			false,
			"StationStatusConst",
			1,
			false,
			},
		14: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130054,
		Description: "Loran-C Signal Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLoranCSignalData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*int32",
			1,
			true,
			},
		2: { 8,
			false,
			"string",
			1,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.01,
			true,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		5: { 32,
			false,
			"*int32",
			1,
			true,
			},
		},
	},
	{
		PGN: 130060,
		Description: "Label",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLabel,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130061,
		Description: "Channel Source Configuration",
		Fast: true,
		ManId: 0,
		Decoder: DecodeChannelSourceConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 12,
			false,
			"interface{}",
			1,
			false,
			},
		5: { 64,
			false,
			"*uint64",
			1,
			false,
			},
		6: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130064,
		Description: "Route and WP Service - Database List",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceDatabaseList,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130065,
		Description: "Route and WP Service - Route List",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRouteList,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130066,
		Description: "Route and WP Service - Route/WP-List Attributes",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRouteWpListAttributes,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 0,
			true,
			"string",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130067,
		Description: "Route and WP Service - Route - WP Name & Position",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRouteWpNamePosition,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130068,
		Description: "Route and WP Service - Route - WP Name",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRouteWpName,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130069,
		Description: "Route and WP Service - XTE Limit & Navigation Method",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceXteLimitNavigationMethod,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130070,
		Description: "Route and WP Service - WP Comment",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceWpComment,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130071,
		Description: "Route and WP Service - Route Comment",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRouteComment,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130072,
		Description: "Route and WP Service - Database Comment",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceDatabaseComment,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130073,
		Description: "Route and WP Service - Radius of Turn",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceRadiusOfTurn,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130074,
		Description: "Route and WP Service - WP List - WP Name & Position",
		Fast: true,
		ManId: 0,
		Decoder: DecodeRouteAndWpServiceWpListWpNamePosition,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130306,
		Description: "Wind Data",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWindData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		4: { 3,
			false,
			"WindReferenceConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130310,
		Description: "Environmental Parameters (obsolete)",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEnvironmentalParametersObsolete,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		3: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		4: { 16,
			false,
			"*float32",
			100,
			false,
			},
		
		},
	},
	{
		PGN: 130311,
		Description: "Environmental Parameters",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEnvironmentalParameters,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 6,
			false,
			"TemperatureSourceConst",
			1,
			false,
			},
		3: { 2,
			false,
			"HumiditySourceConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.004,
			false,
			},
		6: { 16,
			false,
			"*float32",
			100,
			false,
			},
		},
	},
	{
		PGN: 130312,
		Description: "Temperature",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTemperature,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"TemperatureSourceConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		
		},
	},
	{
		PGN: 130313,
		Description: "Humidity",
		Fast: false,
		ManId: 0,
		Decoder: DecodeHumidity,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"HumiditySourceConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*float32",
			0.004,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.004,
			false,
			},
		
		},
	},
	{
		PGN: 130314,
		Description: "Actual Pressure",
		Fast: false,
		ManId: 0,
		Decoder: DecodeActualPressure,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"PressureSourceConst",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.1,
			true,
			},
		
		},
	},
	{
		PGN: 130315,
		Description: "Set Pressure",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSetPressure,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"PressureSourceConst",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.1,
			false,
			},
		
		},
	},
	{
		PGN: 130316,
		Description: "Temperature Extended Range",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTemperatureExtendedRange,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"TemperatureSourceConst",
			1,
			false,
			},
		4: { 24,
			false,
			"*float32",
			0.001,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		},
	},
	{
		PGN: 130320,
		Description: "Tide Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTideStationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		2: { 2,
			false,
			"TideConst",
			1,
			false,
			},
		
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		7: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		8: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		9: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		10: { 0,
			true,
			"string",
			1,
			false,
			},
		11: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130321,
		Description: "Salinity Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeSalinityStationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		7: { 32,
			false,
			"*float32",
			1,
			true,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		9: { 0,
			true,
			"string",
			1,
			false,
			},
		10: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130322,
		Description: "Current Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeCurrentStationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		7: { 32,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		11: { 0,
			true,
			"string",
			1,
			false,
			},
		12: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130323,
		Description: "Meteorological Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeMeteorologicalStationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		9: { 3,
			false,
			"WindReferenceConst",
			1,
			false,
			},
		
		11: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		12: { 16,
			false,
			"*float32",
			100,
			false,
			},
		13: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		14: { 0,
			true,
			"string",
			1,
			false,
			},
		15: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130324,
		Description: "Moored Buoy Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeMooredBuoyStationData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		4: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		5: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		6: { 32,
			false,
			"*float32",
			1e-07,
			true,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		9: { 3,
			false,
			"WindReferenceConst",
			1,
			false,
			},
		
		11: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		13: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		14: { 16,
			false,
			"*float32",
			100,
			false,
			},
		15: { 16,
			false,
			"*int16",
			1,
			true,
			},
		16: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		17: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		18: { 64,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130330,
		Description: "Lighting System Settings",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingSystemSettings,
		FieldInfo: map[int]FieldDescriptor{
		1: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 3,
			false,
			"LightingCommandConst",
			1,
			false,
			},
		
		4: { 0,
			true,
			"string",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 130560,
		Description: "Payload Mass",
		Fast: false,
		ManId: 0,
		Decoder: DecodePayloadMass,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 3,
			false,
			"*uint8",
			1,
			false,
			},
		
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130561,
		Description: "Lighting Zone",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingZone,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 0,
			true,
			"string",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130562,
		Description: "Lighting Scene",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingScene,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 0,
			true,
			"string",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130563,
		Description: "Lighting Device",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingDevice,
		FieldInfo: map[int]FieldDescriptor{
		1: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 0,
			true,
			"string",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		15: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		16: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		17: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130564,
		Description: "Lighting Device Enumeration",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingDeviceEnumeration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130565,
		Description: "Lighting Color Sequence",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingColorSequence,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130566,
		Description: "Lighting Program",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLightingProgram,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 0,
			true,
			"string",
			1,
			false,
			},
		3: { 0,
			true,
			"string",
			1,
			false,
			},
		4: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130567,
		Description: "Watermaker Input Setting and Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeWatermakerInputSettingAndStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 6,
			false,
			"WatermakerStateConst",
			1,
			false,
			},
		2: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		3: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		6: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		7: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		8: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		9: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		10: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		11: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		12: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		13: { 2,
			false,
			"OkWarningConst",
			1,
			false,
			},
		
		15: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		16: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		17: { 16,
			false,
			"*float32",
			100,
			false,
			},
		18: { 16,
			false,
			"*float32",
			100,
			false,
			},
		19: { 16,
			false,
			"*float32",
			1000,
			true,
			},
		20: { 16,
			false,
			"*float32",
			1000,
			false,
			},
		21: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		22: { 16,
			false,
			"*float32",
			0.1,
			true,
			},
		23: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 130569,
		Description: "Current Status and File",
		Fast: true,
		ManId: 0,
		Decoder: DecodeCurrentStatusAndFile,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentZoneConst",
			1,
			false,
			},
		2: { 8,
			false,
			"EntertainmentSourceConst",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		4: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		5: { 8,
			false,
			"EntertainmentPlayStatusConst",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 4,
			false,
			"EntertainmentRepeatStatusConst",
			1,
			false,
			},
		9: { 4,
			false,
			"EntertainmentShuffleStatusConst",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 8,
			false,
			"EntertainmentLikeStatusConst",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		14: { 32,
			false,
			"*float32",
			10,
			false,
			},
		15: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		16: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		17: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130570,
		Description: "Library Data File",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLibraryDataFile,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentSourceConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 8,
			false,
			"EntertainmentTypeConst",
			1,
			false,
			},
		5: { 0,
			true,
			"string",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 32,
			false,
			"*float32",
			10,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"EntertainmentZoneConst",
			1,
			false,
			},
		12: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		13: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		15: { 0,
			true,
			"string",
			1,
			false,
			},
		16: { 0,
			true,
			"string",
			1,
			false,
			},
		17: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130571,
		Description: "Library Data Group",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLibraryDataGroup,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentSourceConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"EntertainmentTypeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"EntertainmentZoneConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130572,
		Description: "Library Data Search",
		Fast: true,
		ManId: 0,
		Decoder: DecodeLibraryDataSearch,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentSourceConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		4: { 8,
			false,
			"EntertainmentGroupConst",
			1,
			false,
			},
		5: { 0,
			true,
			"string",
			1,
			false,
			},
		6: { 8,
			false,
			"EntertainmentGroupConst",
			1,
			false,
			},
		7: { 0,
			true,
			"string",
			1,
			false,
			},
		8: { 8,
			false,
			"EntertainmentGroupConst",
			1,
			false,
			},
		9: { 0,
			true,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130573,
		Description: "Supported Source Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeSupportedSourceData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		2: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		3: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130574,
		Description: "Supported Zone Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeSupportedZoneData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130576,
		Description: "Small Craft Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSmallCraftStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*int8",
			1,
			true,
			},
		2: { 8,
			false,
			"*int8",
			1,
			true,
			},
		
		},
	},
	{
		PGN: 130577,
		Description: "Direction Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDirectionData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 4,
			false,
			"ResidualModeConst",
			1,
			false,
			},
		2: { 2,
			false,
			"DirectionReferenceConst",
			1,
			false,
			},
		
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 130578,
		Description: "Vessel Speed Components",
		Fast: true,
		ManId: 0,
		Decoder: DecodeVesselSpeedComponents,
		FieldInfo: map[int]FieldDescriptor{
		1: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		2: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		3: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		4: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		5: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		6: { 16,
			false,
			"*float32",
			0.001,
			true,
			},
		},
	},
	{
		PGN: 130579,
		Description: "System Configuration",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSystemConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		2: { 2,
			false,
			"EntertainmentDefaultSettingsConst",
			1,
			false,
			},
		3: { 4,
			false,
			"EntertainmentRegionsConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 4,
			false,
			"VideoProtocolsConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130580,
		Description: "System Configuration (deprecated)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeSystemConfigurationDeprecated,
		FieldInfo: map[int]FieldDescriptor{
		1: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		2: { 2,
			false,
			"EntertainmentDefaultSettingsConst",
			1,
			false,
			},
		3: { 4,
			false,
			"EntertainmentRegionsConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130581,
		Description: "Zone Configuration (deprecated)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeZoneConfigurationDeprecated,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130582,
		Description: "Zone Volume",
		Fast: false,
		ManId: 0,
		Decoder: DecodeZoneVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentZoneConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 2,
			false,
			"EntertainmentVolumeControlConst",
			1,
			false,
			},
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		
		6: { 8,
			false,
			"EntertainmentChannelConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130583,
		Description: "Available Audio EQ presets",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAvailableAudioEqPresets,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130584,
		Description: "Available Bluetooth addresses",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAvailableBluetoothAddresses,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130585,
		Description: "Bluetooth source status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBluetoothSourceStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		2: { 4,
			false,
			"BluetoothSourceStatusConst",
			1,
			false,
			},
		3: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		4: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		5: { 48,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 130586,
		Description: "Zone Configuration",
		Fast: true,
		ManId: 0,
		Decoder: DecodeZoneConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 8,
			false,
			"EntertainmentZoneConst",
			1,
			false,
			},
		2: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		3: { 8,
			false,
			"*int8",
			1,
			true,
			},
		4: { 8,
			false,
			"*int8",
			1,
			true,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*int8",
			1,
			true,
			},
		7: { 8,
			false,
			"*int8",
			1,
			true,
			},
		8: { 8,
			false,
			"*int8",
			1,
			true,
			},
		9: { 8,
			false,
			"EntertainmentEqConst",
			1,
			false,
			},
		10: { 8,
			false,
			"EntertainmentFilterConst",
			1,
			false,
			},
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		13: { 8,
			false,
			"EntertainmentChannelConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #2",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubInit2,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: AM Radio",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubAmRadio,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"SonichubTuningConst",
			1,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		12: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Zone info",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubZoneInfo,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Source",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubSource,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"SonichubSourceConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Source List",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubSourceList,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Control",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"FusionMuteCommandConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: FM Radio",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubFmRadio,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"SonichubTuningConst",
			1,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 2,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		
		12: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Playlist",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubPlaylist,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"SonichubPlaylistConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		11: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		12: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Track",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubTrack,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Artist",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubArtist,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Album",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubAlbum,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Menu Item",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubMenuItem,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Zones",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubZones,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Max Volume",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubMaxVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Volume",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #1",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubInit1,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Position",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubPosition,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 32,
			false,
			"*float32",
			0.001,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #3",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubInit3,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SonichubCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"SonichubControlConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130816,
		Description: "Simrad: Text Message",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimradTextMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"SimradCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130817,
		Description: "Navico: Product Information",
		Fast: true,
		ManId: 275,
		Decoder: DecodeNavicoProductInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 256,
			false,
			"string",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 80,
			false,
			"string",
			1,
			false,
			},
		10: { 256,
			false,
			"string",
			1,
			false,
			},
		11: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130817,
		Description: "Lowrance: Product Information",
		Fast: true,
		ManId: 140,
		Decoder: DecodeLowranceProductInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 256,
			false,
			"string",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 80,
			false,
			"string",
			1,
			false,
			},
		10: { 256,
			false,
			"string",
			1,
			false,
			},
		11: { 256,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130818,
		Description: "Simnet: Reprogram Data",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetReprogramData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 1736,
			false,
			"interface{}",
			1,
			false,
			},
		},
	},
	{
		PGN: 130819,
		Description: "Simnet: Request Reprogram",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetRequestReprogram,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Simnet: Reprogram Status",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetReprogramStatus,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130820,
		Description: "Furuno: Unknown 130820",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoUnknown130820,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Source Name",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSourceName,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 40,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Track Info",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionTrackInfo,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 4,
			false,
			"EntertainmentPlayStatusConst",
			1,
			false,
			},
		7: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		11: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		12: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		13: { 24,
			false,
			"*float32",
			0.001,
			false,
			},
		14: { 24,
			false,
			"*float32",
			0.001,
			false,
			},
		15: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Track",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionTrack,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 40,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 80,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Artist",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionArtist,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 40,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 80,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Album",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionAlbum,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 40,
			false,
			"*uint64",
			1,
			false,
			},
		7: { 80,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Unit Name",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionUnitName,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 112,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Zone Name",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionZoneName,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 104,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Play Progress",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionPlayProgress,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 24,
			false,
			"*float32",
			0.001,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: AM/FM Station",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionAmFmStation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"FusionRadioSourceConst",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 80,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: VHF",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionVhf,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Squelch",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSquelch,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Scan",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionScan,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 2,
			false,
			"YesNoConst",
			1,
			false,
			},
		8: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Menu Item",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionMenuItem,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 40,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Replay",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionReplay,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"FusionReplayModeConst",
			1,
			false,
			},
		7: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"FusionReplayStatusConst",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Mute",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionMute,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"FusionMuteCommandConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Sub Volume",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSubVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Tone",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionTone,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*int8",
			1,
			true,
			},
		8: { 8,
			false,
			"*int8",
			1,
			true,
			},
		9: { 8,
			false,
			"*int8",
			1,
			true,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Volume",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionVolume,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: Power State",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionPowerState,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"FusionPowerStateConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Channel",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSiriusxmChannel,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 96,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Title",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSiriusxmTitle,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 96,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Artist",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSiriusxmArtist,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 96,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Genre",
		Fast: true,
		ManId: 419,
		Decoder: DecodeFusionSiriusxmGenre,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"FusionMessageIdConst",
			1,
			false,
			},
		5: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		6: { 96,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130821,
		Description: "Furuno: Unknown 130821",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoUnknown130821,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130823,
		Description: "Maretron: Proprietary Temperature High Range",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronProprietaryTemperatureHighRange,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"TemperatureSourceConst",
			1,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		},
	},
	{
		PGN: 130824,
		Description: "B&G: Wind data",
		Fast: true,
		ManId: 381,
		Decoder: DecodeBGWindData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		},
	},
	{
		PGN: 130824,
		Description: "Maretron: Annunciator",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronAnnunciator,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130827,
		Description: "Lowrance: unknown",
		Fast: true,
		ManId: 140,
		Decoder: DecodeLowranceUnknown,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130828,
		Description: "Simnet: Set Serial Number",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetSetSerialNumber,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130831,
		Description: "Suzuki: Engine and Storage Device Config",
		Fast: true,
		ManId: 586,
		Decoder: DecodeSuzukiEngineAndStorageDeviceConfig,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130832,
		Description: "Simnet: Fuel Used - High Resolution",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetFuelUsedHighResolution,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130834,
		Description: "Simnet: Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetEngineAndTankConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130835,
		Description: "Simnet: Set Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetSetEngineAndTankConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130836,
		Description: "Simnet: Fluid Level Sensor Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetFluidLevelSensorConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 4,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 4,
			false,
			"TankTypeConst",
			1,
			false,
			},
		9: { 32,
			false,
			"*float32",
			0.1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 16,
			false,
			"*int16",
			1,
			true,
			},
		12: { 8,
			false,
			"*int8",
			1,
			true,
			},
		},
	},
	{
		PGN: 130836,
		Description: "Maretron: Switch Status Counter",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSwitchStatusCounter,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130837,
		Description: "Simnet: Fuel Flow Turbine Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetFuelFlowTurbineConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130837,
		Description: "Maretron: Switch Status Timer",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSwitchStatusTimer,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		7: { 32,
			false,
			"*float32",
			0.0001,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		10: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		11: { 2,
			false,
			"OffOnConst",
			1,
			false,
			},
		
		},
	},
	{
		PGN: 130838,
		Description: "Simnet: Fluid Level Warning",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetFluidLevelWarning,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130839,
		Description: "Simnet: Pressure Sensor Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetPressureSensorConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130840,
		Description: "Simnet: Data User Group Configuration",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetDataUserGroupConfiguration,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130842,
		Description: "Simnet: AIS Class B static data (msg 24 Part A)",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetAisClassBStaticDataMsg24PartA,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 160,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130842,
		Description: "Furuno: Six Degrees Of Freedom Movement",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoSixDegreesOfFreedomMovement,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 32,
			false,
			"*int32",
			1,
			true,
			},
		5: { 32,
			false,
			"*int32",
			1,
			true,
			},
		6: { 32,
			false,
			"*int32",
			1,
			true,
			},
		7: { 8,
			false,
			"*int8",
			1,
			true,
			},
		8: { 32,
			false,
			"*int32",
			1,
			true,
			},
		9: { 32,
			false,
			"*int32",
			1,
			true,
			},
		10: { 16,
			false,
			"*int16",
			1,
			true,
			},
		11: { 16,
			false,
			"*int16",
			1,
			true,
			},
		12: { 16,
			false,
			"*int16",
			1,
			true,
			},
		},
	},
	{
		PGN: 130842,
		Description: "Simnet: AIS Class B static data (msg 24 Part B)",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetAisClassBStaticDataMsg24PartB,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		9: { 8,
			false,
			"ShipTypeConst",
			1,
			false,
			},
		10: { 56,
			false,
			"string",
			1,
			false,
			},
		11: { 56,
			false,
			"string",
			1,
			false,
			},
		12: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		13: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		14: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		15: { 16,
			false,
			"*float32",
			0.1,
			false,
			},
		16: { 32,
			false,
			"*uint32",
			1,
			false,
			},
		
		
		},
	},
	{
		PGN: 130843,
		Description: "Furuno: Heel Angle, Roll Information",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoHeelAngleRollInformation,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		7: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		8: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		},
	},
	{
		PGN: 130843,
		Description: "Simnet: Sonar Status, Frequency and DSP Voltage",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetSonarStatusFrequencyAndDspVoltage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130845,
		Description: "Simnet: Compass Heading Offset",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetCompassHeadingOffset,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 16,
			false,
			"SimradTypeConst",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130845,
		Description: "Furuno: Multi Sats In View Extended",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoMultiSatsInViewExtended,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130845,
		Description: "Simnet: Compass Local Field",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetCompassLocalField,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 16,
			false,
			"SimradTypeConst",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.004,
			false,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130845,
		Description: "Simnet: Compass Field Angle",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetCompassFieldAngle,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 24,
			false,
			"*uint32",
			1,
			false,
			},
		7: { 16,
			false,
			"SimradTypeConst",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 16,
			false,
			"*float32",
			0.0001,
			true,
			},
		10: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130845,
		Description: "Simnet: Parameter Handle",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetParameterHandle,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 6,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 2,
			false,
			"RepeatIndicatorConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		12: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		13: { 8,
			false,
			"SimnetBacklightLevelConst",
			1,
			false,
			},
		14: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		},
	},
	{
		PGN: 130846,
		Description: "Furuno: Motion Sensor Status Extended",
		Fast: true,
		ManId: 1855,
		Decoder: DecodeFurunoMotionSensorStatusExtended,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		},
	},
	{
		PGN: 130847,
		Description: "SeaTalk: Node Statistics",
		Fast: true,
		ManId: 1851,
		Decoder: DecodeSeatalkNodeStatistics,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 130850,
		Description: "Simnet: Event Command: AP command",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetEventCommandApCommand,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"SimradEventCommandConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"SimnetApEventsConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"SimnetDirectionConst",
			1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130850,
		Description: "Simnet: Event Command: Alarm?",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetEventCommandAlarm,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"SimradEventCommandConst",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		8: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		9: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		10: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130851,
		Description: "Simnet: Event Reply: AP command",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetEventReplyApCommand,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"SimradEventCommandConst",
			1,
			false,
			},
		5: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"SimnetApEventsConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		9: { 8,
			false,
			"SimnetDirectionConst",
			1,
			false,
			},
		10: { 16,
			false,
			"*float32",
			0.0001,
			false,
			},
		11: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
	{
		PGN: 130856,
		Description: "Simnet: Alarm Message",
		Fast: true,
		ManId: 1857,
		Decoder: DecodeSimnetAlarmMessage,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 16,
			false,
			"*uint16",
			1,
			false,
			},
		5: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 1784,
			false,
			"string",
			1,
			false,
			},
		},
	},
	{
		PGN: 130880,
		Description: "Airmar: Additional Weather Data",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarAdditionalWeatherData,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 130881,
		Description: "Airmar: Heater Control",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarHeaterControl,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		5: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		6: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		7: { 16,
			false,
			"*float32",
			0.01,
			false,
			},
		},
	},
	{
		PGN: 130944,
		Description: "Airmar: POST",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarPost,
		FieldInfo: map[int]FieldDescriptor{
		1: { 11,
			false,
			"ManufacturerCodeConst",
			1,
			false,
			},
		
		3: { 3,
			false,
			"IndustryCodeConst",
			1,
			false,
			},
		4: { 1,
			false,
			"AirmarPostControlConst",
			1,
			false,
			},
		
		6: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		7: { 8,
			false,
			"AirmarPostIdConst",
			1,
			false,
			},
		8: { 8,
			false,
			"*uint8",
			1,
			false,
			},
		},
	},
}
// Build structs for each PGN
type IsoAcknowledgement struct {
	Info MessageInfo
	Control IsoControlConst
	GroupFunction *uint8
	Pgn *uint32
}
func DecodeIsoAcknowledgement(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoAcknowledgement
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Control: %w", err)
	} else {
		val.Control = IsoControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-GroupFunction: %w", err)
	} else {
		val.GroupFunction = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoRequest struct {
	Info MessageInfo
	Pgn *uint32
}
func DecodeIsoRequest(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoRequest
	val.Info = Info
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoRequest-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolDataTransfer struct {
	Info MessageInfo
	Sid *uint8
	Data interface{}
}
func DecodeIsoTransportProtocolDataTransfer(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolDataTransfer
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(56); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Data: %w", err)
	} else {
		val.Data = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementRequestToSend struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MessageSize *uint16
	Packets *uint8
	PacketsReply *uint8
	Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementRequestToSend(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolConnectionManagementRequestToSend
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: %w", err)
	} else {
		if v != 16 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: Expected %d != %d", 16, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-MessageSize: %w", err)
	} else {
		val.MessageSize = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Packets: %w", err)
	} else {
		val.Packets = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-PacketsReply: %w", err)
	} else {
		val.PacketsReply = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementClearToSend struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MaxPackets *uint8
	NextSid *uint8
	Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementClearToSend(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolConnectionManagementClearToSend
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: %w", err)
	} else {
		if v != 17 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: Expected %d != %d", 17, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-MaxPackets: %w", err)
	} else {
		val.MaxPackets = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-NextSid: %w", err)
	} else {
		val.NextSid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementEndOfMessage struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	TotalMessageSize *uint16
	TotalNumberOfFramesReceived *uint8
	Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementEndOfMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolConnectionManagementEndOfMessage
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: %w", err)
	} else {
		if v != 19 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: Expected %d != %d", 19, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalMessageSize: %w", err)
	} else {
		val.TotalMessageSize = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalNumberOfFramesReceived: %w", err)
	} else {
		val.TotalNumberOfFramesReceived = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementBroadcastAnnounce struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MessageSize *uint16
	Packets *uint8
	Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolConnectionManagementBroadcastAnnounce
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: %w", err)
	} else {
		if v != 32 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: Expected %d != %d", 32, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-MessageSize: %w", err)
	} else {
		val.MessageSize = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Packets: %w", err)
	} else {
		val.Packets = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementAbort struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	Reason interface{}
	Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementAbort(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoTransportProtocolConnectionManagementAbort
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: %w", err)
	} else {
		if v != 255 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: Expected %d != %d", 255, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Reason: %w", err)
	} else {
		val.Reason = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoAddressClaim struct {
	Info MessageInfo
	UniqueNumber *uint32
	ManufacturerCode ManufacturerCodeConst
	DeviceInstanceLower *uint8
	DeviceInstanceUpper *uint8
	DeviceFunction DeviceFunctionConst
	DeviceClass DeviceClassConst
	SystemInstance *uint8
	IndustryGroup IndustryCodeConst
	ArbitraryAddressCapable *uint8
}
func DecodeIsoAddressClaim(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoAddressClaim
	val.Info = Info
	if v, err := stream.readUInt32(21); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-UniqueNumber: %w", err)
	} else {
		val.UniqueNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceLower: %w", err)
	} else {
		val.DeviceInstanceLower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(5); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceUpper: %w", err)
	} else {
		val.DeviceInstanceUpper = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceFunction: %w", err)
	} else {
		val.DeviceFunction = DeviceFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(7); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceClass: %w", err)
	} else {
		val.DeviceClass = DeviceClassConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-SystemInstance: %w", err)
	} else {
		val.SystemInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-IndustryGroup: %w", err)
	} else {
		val.IndustryGroup = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-ArbitraryAddressCapable: %w", err)
	} else {
		val.ArbitraryAddressCapable = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SeatalkWirelessKeypadLightControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
	Variant *uint8
	WirelessSetting *uint8
	WiredSetting *uint8
}
func DecodeSeatalkWirelessKeypadLightControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkWirelessKeypadLightControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkWirelessKeypadLightControl-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkWirelessKeypadLightControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for SeatalkWirelessKeypadLightControl-ProprietaryId: Expected %d != %d", 1, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-Variant: %w", err)
	} else {
		val.Variant = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-WirelessSetting: %w", err)
	} else {
		val.WirelessSetting = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadLightControl-WiredSetting: %w", err)
	} else {
		val.WiredSetting = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkWirelessKeypadControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Pid *uint8
	Variant *uint8
	BeepControl *uint8
}
func DecodeSeatalkWirelessKeypadControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkWirelessKeypadControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadControl-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkWirelessKeypadControl-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkWirelessKeypadControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadControl-Pid: %w", err)
	} else {
		val.Pid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadControl-Variant: %w", err)
	} else {
		val.Variant = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkWirelessKeypadControl-BeepControl: %w", err)
	} else {
		val.BeepControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type VictronBatteryRegister struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	RegisterId *uint16
	Payload *uint32
}
func DecodeVictronBatteryRegister(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val VictronBatteryRegister
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for VictronBatteryRegister-ManufacturerCode: %w", err)
	} else {
		if v != 358 {
			return nil, fmt.Errorf("match failed for VictronBatteryRegister-ManufacturerCode: Expected %d != %d", 358, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for VictronBatteryRegister-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for VictronBatteryRegister-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for VictronBatteryRegister-RegisterId: %w", err)
	} else {
		val.RegisterId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for VictronBatteryRegister-Payload: %w", err)
	} else {
		val.Payload = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Bus1PhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func DecodeBus1PhaseCBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Bus1PhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Bus1PhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func DecodeBus1PhaseBBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Bus1PhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Bus1PhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func DecodeBus1PhaseABasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Bus1PhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Bus1AverageBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func DecodeBus1AverageBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Bus1AverageBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1AverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1AverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1AverageBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityTotalAcEnergy struct {
	Info MessageInfo
	TotalEnergyExport *uint32
	TotalEnergyImport *uint32
}
func DecodeUtilityTotalAcEnergy(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityTotalAcEnergy
	val.Info = Info
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcEnergy-TotalEnergyExport: %w", err)
	} else {
		val.TotalEnergyExport = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcEnergy-TotalEnergyImport: %w", err)
	} else {
		val.TotalEnergyImport = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseCAcReactivePower struct {
	Info MessageInfo
	ReactivePower *uint16
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseCAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseCAcReactivePower
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(30)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseCAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeUtilityPhaseCAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseCAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeUtilityPhaseCBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseBAcReactivePower struct {
	Info MessageInfo
	ReactivePower *uint16
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseBAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseBAcReactivePower
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(30)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseBAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeUtilityPhaseBAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseBAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeUtilityPhaseBBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseAAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseAAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseAAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseAAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeUtilityPhaseAAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseAAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeUtilityPhaseABasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityPhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityTotalAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeUtilityTotalAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityTotalAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityTotalAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeUtilityTotalAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityTotalAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityAverageBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeUtilityAverageBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UtilityAverageBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorTotalAcEnergy struct {
	Info MessageInfo
	TotalEnergyExport *uint32
	TotalEnergyImport *uint32
}
func DecodeGeneratorTotalAcEnergy(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorTotalAcEnergy
	val.Info = Info
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcEnergy-TotalEnergyExport: %w", err)
	} else {
		val.TotalEnergyExport = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcEnergy-TotalEnergyImport: %w", err)
	} else {
		val.TotalEnergyImport = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseCAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseCAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseCAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseCAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeGeneratorPhaseCAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseCAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseCBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseBAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseBAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseBAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseBAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeGeneratorPhaseBAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseBAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseBBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseAAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseAAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseAAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseAAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeGeneratorPhaseAAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseAAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseABasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorPhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorTotalAcReactivePower struct {
	Info MessageInfo
	ReactivePower *int32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorTotalAcReactivePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorTotalAcReactivePower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorTotalAcPower struct {
	Info MessageInfo
	RealPower *int32
	ApparentPower *int32
}
func DecodeGeneratorTotalAcPower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorTotalAcPower
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorAverageBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func DecodeGeneratorAverageBasicAcQuantities(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GeneratorAverageBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoCommandedAddress struct {
	Info MessageInfo
	UniqueNumber interface{}
	ManufacturerCode ManufacturerCodeConst
	DeviceInstanceLower *uint8
	DeviceInstanceUpper *uint8
	DeviceFunction DeviceFunctionConst
	DeviceClass DeviceClassConst
	SystemInstance *uint8
	IndustryCode IndustryCodeConst
	NewSourceAddress *uint8
}
func DecodeIsoCommandedAddress(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val IsoCommandedAddress
	val.Info = Info
	if v, err := stream.readBinaryData(21); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-UniqueNumber: %w", err)
	} else {
		val.UniqueNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceLower: %w", err)
	} else {
		val.DeviceInstanceLower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(5); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceUpper: %w", err)
	} else {
		val.DeviceInstanceUpper = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceFunction: %w", err)
	} else {
		val.DeviceFunction = DeviceFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(7); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceClass: %w", err)
	} else {
		val.DeviceClass = DeviceClassConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-SystemInstance: %w", err)
	} else {
		val.SystemInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-NewSourceAddress: %w", err)
	} else {
		val.NewSourceAddress = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FurunoHeave struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Heave *float32
}
func DecodeFurunoHeave(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoHeave
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeave-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoHeave-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeave-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoHeave-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeave-Heave: %w", err)
	} else {
		val.Heave = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type MaretronProprietaryDcBreakerCurrent struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	BankInstance *uint8
	IndicatorNumber *uint8
	BreakerCurrent *float32
}
func DecodeMaretronProprietaryDcBreakerCurrent(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronProprietaryDcBreakerCurrent
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BankInstance: %w", err)
	} else {
		val.BankInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BreakerCurrent: %w", err)
	} else {
		val.BreakerCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarBootStateAcknowledgment struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	BootState BootStateConst
}
func DecodeAirmarBootStateAcknowledgment(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarBootStateAcknowledgment
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-BootState: %w", err)
	} else {
		val.BootState = BootStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(45)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LowranceTemperature struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	TemperatureSource TemperatureSourceConst
	ActualTemperature *float32
}
func DecodeLowranceTemperature(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LowranceTemperature
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-ManufacturerCode: %w", err)
	} else {
		if v != 140 {
			return nil, fmt.Errorf("match failed for LowranceTemperature-ManufacturerCode: Expected %d != %d", 140, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for LowranceTemperature-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-TemperatureSource: %w", err)
	} else {
		val.TemperatureSource = TemperatureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ChetcoDimmer struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Instance *uint8
	Dimmer1 *uint8
	Dimmer2 *uint8
	Dimmer3 *uint8
	Dimmer4 *uint8
	Control *uint8
}
func DecodeChetcoDimmer(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ChetcoDimmer
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-ManufacturerCode: %w", err)
	} else {
		if v != 409 {
			return nil, fmt.Errorf("match failed for ChetcoDimmer-ManufacturerCode: Expected %d != %d", 409, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for ChetcoDimmer-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Dimmer1: %w", err)
	} else {
		val.Dimmer1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Dimmer2: %w", err)
	} else {
		val.Dimmer2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Dimmer3: %w", err)
	} else {
		val.Dimmer3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Dimmer4: %w", err)
	} else {
		val.Dimmer4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChetcoDimmer-Control: %w", err)
	} else {
		val.Control = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarBootStateRequest struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeAirmarBootStateRequest(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarBootStateRequest
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarBootStateRequest-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarBootStateRequest-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarAccessLevel struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	FormatCode *uint8
	AccessLevel AccessLevelConst
	AccessSeedKey *uint32
}
func DecodeAirmarAccessLevel(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarAccessLevel
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAccessLevel-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAccessLevel-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-FormatCode: %w", err)
	} else {
		val.FormatCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessLevel: %w", err)
	} else {
		val.AccessLevel = AccessLevelConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessSeedKey: %w", err)
	} else {
		val.AccessSeedKey = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetConfigureTemperatureSensor struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetConfigureTemperatureSensor(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetConfigureTemperatureSensor
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetConfigureTemperatureSensor-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetConfigureTemperatureSensor-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetConfigureTemperatureSensor-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetConfigureTemperatureSensor-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkAlarm struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid interface{}
	AlarmStatus SeatalkAlarmStatusConst
	AlarmId SeatalkAlarmIdConst
	AlarmGroup SeatalkAlarmGroupConst
	AlarmPriority interface{}
}
func DecodeSeatalkAlarm(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkAlarm
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkAlarm-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkAlarm-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-AlarmStatus: %w", err)
	} else {
		val.AlarmStatus = SeatalkAlarmStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-AlarmId: %w", err)
	} else {
		val.AlarmId = SeatalkAlarmIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-AlarmGroup: %w", err)
	} else {
		val.AlarmGroup = SeatalkAlarmGroupConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(16); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkAlarm-AlarmPriority: %w", err)
	} else {
		val.AlarmPriority = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetTrimTabSensorCalibration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetTrimTabSensorCalibration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetTrimTabSensorCalibration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetTrimTabSensorCalibration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetTrimTabSensorCalibration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetTrimTabSensorCalibration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetTrimTabSensorCalibration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetPaddleWheelSpeedConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetPaddleWheelSpeedConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetPaddleWheelSpeedConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPaddleWheelSpeedConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetPaddleWheelSpeedConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPaddleWheelSpeedConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetPaddleWheelSpeedConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetClearFluidLevelWarnings struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetClearFluidLevelWarnings(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetClearFluidLevelWarnings
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetClearFluidLevelWarnings-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetClearFluidLevelWarnings-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetClearFluidLevelWarnings-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetClearFluidLevelWarnings-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetLgc2000Configuration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetLgc2000Configuration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetLgc2000Configuration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetLgc2000Configuration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetLgc2000Configuration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetLgc2000Configuration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetLgc2000Configuration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NavicoWirelessBatteryStatus struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Status *uint8
	BatteryStatus *uint8
	BatteryChargeStatus *uint8
}
func DecodeNavicoWirelessBatteryStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavicoWirelessBatteryStatus
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessBatteryStatus-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for NavicoWirelessBatteryStatus-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessBatteryStatus-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for NavicoWirelessBatteryStatus-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessBatteryStatus-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessBatteryStatus-BatteryStatus: %w", err)
	} else {
		val.BatteryStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessBatteryStatus-BatteryChargeStatus: %w", err)
	} else {
		val.BatteryChargeStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NavicoWirelessSignalStatus struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Unknown *uint8
	SignalStrength *uint8
}
func DecodeNavicoWirelessSignalStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavicoWirelessSignalStatus
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessSignalStatus-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for NavicoWirelessSignalStatus-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessSignalStatus-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for NavicoWirelessSignalStatus-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessSignalStatus-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoWirelessSignalStatus-SignalStrength: %w", err)
	} else {
		val.SignalStrength = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkPilotWindDatum struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	WindDatum *float32
	RollingAverageWindAngle *float32
}
func DecodeSeatalkPilotWindDatum(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkPilotWindDatum
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotWindDatum-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkPilotWindDatum-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotWindDatum-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkPilotWindDatum-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotWindDatum-WindDatum: %w", err)
	} else {
		val.WindDatum = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotWindDatum-RollingAverageWindAngle: %w", err)
	} else {
		val.RollingAverageWindAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkPilotHeading struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid interface{}
	HeadingTrue *float32
	HeadingMagnetic *float32
}
func DecodeSeatalkPilotHeading(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkPilotHeading
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotHeading-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkPilotHeading-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotHeading-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkPilotHeading-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotHeading-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotHeading-HeadingTrue: %w", err)
	} else {
		val.HeadingTrue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotHeading-HeadingMagnetic: %w", err)
	} else {
		val.HeadingMagnetic = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkPilotLockedHeading struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid interface{}
	TargetHeadingTrue *float32
	TargetHeadingMagnetic *float32
}
func DecodeSeatalkPilotLockedHeading(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkPilotLockedHeading
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingTrue: %w", err)
	} else {
		val.TargetHeadingTrue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingMagnetic: %w", err)
	} else {
		val.TargetHeadingMagnetic = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkSilenceAlarm struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	AlarmId SeatalkAlarmIdConst
	AlarmGroup SeatalkAlarmGroupConst
}
func DecodeSeatalkSilenceAlarm(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkSilenceAlarm
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmId: %w", err)
	} else {
		val.AlarmId = SeatalkAlarmIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmGroup: %w", err)
	} else {
		val.AlarmGroup = SeatalkAlarmGroupConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkKeypadMessage struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
	FirstKey *uint8
	SecondKey *uint8
	FirstKeyState *uint8
	SecondKeyState *uint8
	EncoderPosition *uint8
}
func DecodeSeatalkKeypadMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkKeypadMessage
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkKeypadMessage-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkKeypadMessage-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-ProprietaryId: %w", err)
	} else {
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-FirstKey: %w", err)
	} else {
		val.FirstKey = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-SecondKey: %w", err)
	} else {
		val.SecondKey = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-FirstKeyState: %w", err)
	} else {
		val.FirstKeyState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-SecondKeyState: %w", err)
	} else {
		val.SecondKeyState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadMessage-EncoderPosition: %w", err)
	} else {
		val.EncoderPosition = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkKeypadHeartbeat struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
	Variant *uint8
	Status *uint8
}
func DecodeSeatalkKeypadHeartbeat(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkKeypadHeartbeat
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadHeartbeat-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkKeypadHeartbeat-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadHeartbeat-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkKeypadHeartbeat-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadHeartbeat-ProprietaryId: %w", err)
	} else {
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadHeartbeat-Variant: %w", err)
	} else {
		val.Variant = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkKeypadHeartbeat-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkPilotMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	PilotMode interface{}
	SubMode interface{}
	PilotModeData interface{}
}
func DecodeSeatalkPilotMode(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkPilotMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotMode-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkPilotMode-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkPilotMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotMode-PilotMode: %w", err)
	} else {
		val.PilotMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotMode-SubMode: %w", err)
	} else {
		val.SubMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotMode-PilotModeData: %w", err)
	} else {
		val.PilotModeData = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarDepthQualityFactor struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	DepthQualityFactor AirmarDepthQualityFactorConst
}
func DecodeAirmarDepthQualityFactor(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarDepthQualityFactor
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDepthQualityFactor-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarDepthQualityFactor-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDepthQualityFactor-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarDepthQualityFactor-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDepthQualityFactor-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDepthQualityFactor-DepthQualityFactor: %w", err)
	} else {
		val.DepthQualityFactor = AirmarDepthQualityFactorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(36)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarSpeedPulseCount struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	DurationOfInterval *float32
	NumberOfPulsesReceived *uint16
}
func DecodeAirmarSpeedPulseCount(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarSpeedPulseCount
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-DurationOfInterval: %w", err)
	} else {
		val.DurationOfInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-NumberOfPulsesReceived: %w", err)
	} else {
		val.NumberOfPulsesReceived = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarDeviceInformation struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	InternalDeviceTemperature *float32
	SupplyVoltage *float32
}
func DecodeAirmarDeviceInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarDeviceInformation
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDeviceInformation-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarDeviceInformation-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDeviceInformation-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarDeviceInformation-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDeviceInformation-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDeviceInformation-InternalDeviceTemperature: %w", err)
	} else {
		val.InternalDeviceTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarDeviceInformation-SupplyVoltage: %w", err)
	} else {
		val.SupplyVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetAutopilotMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetAutopilotMode(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetAutopilotMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAutopilotMode-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetAutopilotMode-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAutopilotMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetAutopilotMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NmeaRequestGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	TransmissionInterval *float32
	TransmissionIntervalOffset *float32
	NumberOfParameters *uint8
	Repeating1 []NmeaRequestGroupFunctionRepeating1
}
type NmeaRequestGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value interface{}
}
func DecodeNmeaRequestGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaRequestGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 0 {
			return nil, fmt.Errorf("match failed for NmeaRequestGroupFunction-FunctionCode: Expected %d != %d", 0, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionInterval: %w", err)
	} else {
		val.TransmissionInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionIntervalOffset: %w", err)
	} else {
		val.TransmissionIntervalOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaRequestGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaRequestGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaCommandGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	Priority PriorityConst
	NumberOfParameters *uint8
	Repeating1 []NmeaCommandGroupFunctionRepeating1
}
type NmeaCommandGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value interface{}
}
func DecodeNmeaCommandGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaCommandGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 1 {
			return nil, fmt.Errorf("match failed for NmeaCommandGroupFunction-FunctionCode: Expected %d != %d", 1, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Priority: %w", err)
	} else {
		val.Priority = PriorityConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaCommandGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaCommandGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaAcknowledgeGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	PgnErrorCode PgnErrorCodeConst
	TransmissionIntervalPriorityErrorCode TransmissionIntervalConst
	NumberOfParameters *uint8
	Repeating1 []NmeaAcknowledgeGroupFunctionRepeating1
}
type NmeaAcknowledgeGroupFunctionRepeating1 struct {
	Parameter ParameterFieldConst
}
func DecodeNmeaAcknowledgeGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaAcknowledgeGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for NmeaAcknowledgeGroupFunction-FunctionCode: Expected %d != %d", 2, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-PgnErrorCode: %w", err)
	} else {
		val.PgnErrorCode = PgnErrorCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-TransmissionIntervalPriorityErrorCode: %w", err)
	} else {
		val.TransmissionIntervalPriorityErrorCode = TransmissionIntervalConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaAcknowledgeGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaAcknowledgeGroupFunctionRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = ParameterFieldConst(v)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaReadFieldsGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaReadFieldsGroupFunctionRepeating1
	Repeating2 []NmeaReadFieldsGroupFunctionRepeating2
}
type NmeaReadFieldsGroupFunctionRepeating1 struct {
	Parameter *uint8
	SelectionValue interface{}
}
type NmeaReadFieldsGroupFunctionRepeating2 struct {
	Parameter *uint8
}
func DecodeNmeaReadFieldsGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaReadFieldsGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 3 {
			return nil, fmt.Errorf("match failed for NmeaReadFieldsGroupFunction-FunctionCode: Expected %d != %d", 3, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaReadFieldsGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaReadFieldsGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaReadFieldsGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaReadFieldsGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaReadFieldsReplyGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaReadFieldsReplyGroupFunctionRepeating1
	Repeating2 []NmeaReadFieldsReplyGroupFunctionRepeating2
}
type NmeaReadFieldsReplyGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value interface{}
}
type NmeaReadFieldsReplyGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value interface{}
}
func DecodeNmeaReadFieldsReplyGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaReadFieldsReplyGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 4, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaReadFieldsReplyGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaReadFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else if v != nil {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaWriteFieldsGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaWriteFieldsGroupFunctionRepeating1
	Repeating2 []NmeaWriteFieldsGroupFunctionRepeating2
}
type NmeaWriteFieldsGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value interface{}
}
type NmeaWriteFieldsGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value interface{}
}
func DecodeNmeaWriteFieldsGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaWriteFieldsGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 5 {
			return nil, fmt.Errorf("match failed for NmeaWriteFieldsGroupFunction-FunctionCode: Expected %d != %d", 5, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaWriteFieldsGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else if v != nil {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaWriteFieldsReplyGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaWriteFieldsReplyGroupFunctionRepeating1
	Repeating2 []NmeaWriteFieldsReplyGroupFunctionRepeating2
}
type NmeaWriteFieldsReplyGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value interface{}
}
type NmeaWriteFieldsReplyGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value interface{}
}
func DecodeNmeaWriteFieldsReplyGroupFunction(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NmeaWriteFieldsReplyGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 6 {
			return nil, fmt.Errorf("match failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 6, v)
		}
		val.FunctionCode = GroupFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else if v != nil {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type PgnListTransmitAndReceive struct {
	Info MessageInfo
	FunctionCode PgnListFunctionConst
	Repeating1 []PgnListTransmitAndReceiveRepeating1
}
type PgnListTransmitAndReceiveRepeating1 struct {
	Pgn *uint32
}
func DecodePgnListTransmitAndReceive(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val PgnListTransmitAndReceive
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-FunctionCode: %w", err)
	} else {
		val.FunctionCode = PgnListFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	val.Repeating1 = make([]PgnListTransmitAndReceiveRepeating1, 0)
	i := 0 
	for {
		var rep PgnListTransmitAndReceiveRepeating1
		if v, err := stream.readUInt32(24); err != nil {
			return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-Pgn: %w", err)
		} else {
			rep.Pgn = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type Seatalk1PilotMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint16
	Command *uint8
	Unknown1 interface{}
	PilotMode SeatalkPilotModeConst
	SubMode *uint8
	PilotModeData interface{}
	Unknown2 interface{}
}
func DecodeSeatalk1PilotMode(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Seatalk1PilotMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for Seatalk1PilotMode-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for Seatalk1PilotMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 33264 {
			return nil, fmt.Errorf("match failed for Seatalk1PilotMode-ProprietaryId: Expected %d != %d", 33264, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-Command: %w", err)
	} else {
		if v != nil && *v != 132 {
			return nil, fmt.Errorf("match failed for Seatalk1PilotMode-Command: Expected %d != %d", 132, *v)
		}
		val.Command = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(24); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-Unknown1: %w", err)
	} else {
		val.Unknown1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-PilotMode: %w", err)
	} else {
		val.PilotMode = SeatalkPilotModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-SubMode: %w", err)
	} else {
		val.SubMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-PilotModeData: %w", err)
	} else {
		val.PilotModeData = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(80); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1PilotMode-Unknown2: %w", err)
	} else {
		val.Unknown2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionMediaControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
	Unknown *uint8
	SourceId *uint8
	Command FusionCommandConst
}
func DecodeFusionMediaControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionMediaControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionMediaControl-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionMediaControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 3 {
			return nil, fmt.Errorf("match failed for FusionMediaControl-ProprietaryId: Expected %d != %d", 3, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMediaControl-Command: %w", err)
	} else {
		val.Command = FusionCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSiriusControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
	Unknown *uint8
	SourceId *uint8
	Command FusionSiriusCommandConst
}
func DecodeFusionSiriusControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSiriusControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSiriusControl-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSiriusControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 30 {
			return nil, fmt.Errorf("match failed for FusionSiriusControl-ProprietaryId: Expected %d != %d", 30, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusControl-Command: %w", err)
	} else {
		val.Command = FusionSiriusCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionRequestStatus struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId FusionMessageIdConst
	Unknown *uint8
}
func DecodeFusionRequestStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionRequestStatus
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionRequestStatus-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionRequestStatus-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionRequestStatus-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionRequestStatus-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionRequestStatus-ProprietaryId: %w", err)
	} else {
		if v != 1 {
			return nil, fmt.Errorf("match failed for FusionRequestStatus-ProprietaryId: Expected %d != %d", 1, v)
		}
		val.ProprietaryId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionRequestStatus-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSetSource struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId FusionMessageIdConst
	Unknown *uint8
	SourceId *uint8
}
func DecodeFusionSetSource(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSetSource
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetSource-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSetSource-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetSource-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSetSource-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetSource-ProprietaryId: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for FusionSetSource-ProprietaryId: Expected %d != %d", 2, v)
		}
		val.ProprietaryId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetSource-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetSource-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSetMute struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId FusionMessageIdConst
	Command FusionMuteCommandConst
}
func DecodeFusionSetMute(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSetMute
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetMute-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSetMute-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetMute-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSetMute-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetMute-ProprietaryId: %w", err)
	} else {
		if v != 23 {
			return nil, fmt.Errorf("match failed for FusionSetMute-ProprietaryId: Expected %d != %d", 23, v)
		}
		val.ProprietaryId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetMute-Command: %w", err)
	} else {
		val.Command = FusionMuteCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSetZoneVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId FusionMessageIdConst
	Unknown *uint8
	Zone *uint8
	Volume *uint8
}
func DecodeFusionSetZoneVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSetZoneVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSetZoneVolume-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSetZoneVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-ProprietaryId: %w", err)
	} else {
		if v != 24 {
			return nil, fmt.Errorf("match failed for FusionSetZoneVolume-ProprietaryId: Expected %d != %d", 24, v)
		}
		val.ProprietaryId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-Zone: %w", err)
	} else {
		val.Zone = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetZoneVolume-Volume: %w", err)
	} else {
		val.Volume = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSetAllVolumes struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId FusionMessageIdConst
	Unknown *uint8
	Zone1 *uint8
	Zone2 *uint8
	Zone3 *uint8
	Zone4 *uint8
}
func DecodeFusionSetAllVolumes(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSetAllVolumes
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSetAllVolumes-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSetAllVolumes-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-ProprietaryId: %w", err)
	} else {
		if v != 25 {
			return nil, fmt.Errorf("match failed for FusionSetAllVolumes-ProprietaryId: Expected %d != %d", 25, v)
		}
		val.ProprietaryId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-Unknown: %w", err)
	} else {
		val.Unknown = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-Zone1: %w", err)
	} else {
		val.Zone1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-Zone2: %w", err)
	} else {
		val.Zone2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-Zone3: %w", err)
	} else {
		val.Zone3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSetAllVolumes-Zone4: %w", err)
	} else {
		val.Zone4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Seatalk1Keystroke struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint16
	Command *uint8
	Device *uint8
	Key SeatalkKeystrokeConst
	Keyinverted *uint8
	UnknownData interface{}
}
func DecodeSeatalk1Keystroke(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Seatalk1Keystroke
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for Seatalk1Keystroke-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for Seatalk1Keystroke-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 33264 {
			return nil, fmt.Errorf("match failed for Seatalk1Keystroke-ProprietaryId: Expected %d != %d", 33264, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-Command: %w", err)
	} else {
		if v != nil && *v != 134 {
			return nil, fmt.Errorf("match failed for Seatalk1Keystroke-Command: Expected %d != %d", 134, *v)
		}
		val.Command = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-Device: %w", err)
	} else {
		val.Device = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-Key: %w", err)
	} else {
		val.Key = SeatalkKeystrokeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-Keyinverted: %w", err)
	} else {
		val.Keyinverted = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(112); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1Keystroke-UnknownData: %w", err)
	} else {
		val.UnknownData = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Seatalk1DeviceIdentification struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint16
	Command *uint8
	Device SeatalkDeviceIdConst
}
func DecodeSeatalk1DeviceIdentification(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Seatalk1DeviceIdentification
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1DeviceIdentification-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for Seatalk1DeviceIdentification-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1DeviceIdentification-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for Seatalk1DeviceIdentification-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1DeviceIdentification-ProprietaryId: %w", err)
	} else {
		if v != nil && *v != 33264 {
			return nil, fmt.Errorf("match failed for Seatalk1DeviceIdentification-ProprietaryId: Expected %d != %d", 33264, *v)
		}
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1DeviceIdentification-Command: %w", err)
	} else {
		if v != nil && *v != 144 {
			return nil, fmt.Errorf("match failed for Seatalk1DeviceIdentification-Command: Expected %d != %d", 144, *v)
		}
		val.Command = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Seatalk1DeviceIdentification-Device: %w", err)
	} else {
		val.Device = SeatalkDeviceIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarAttitudeOffset struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	AzimuthOffset *float32
	PitchOffset *float32
	RollOffset *float32
}
func DecodeAirmarAttitudeOffset(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarAttitudeOffset
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ProprietaryId: %w", err)
	} else {
		if v != 32 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ProprietaryId: Expected %d != %d", 32, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-AzimuthOffset: %w", err)
	} else {
		val.AzimuthOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-PitchOffset: %w", err)
	} else {
		val.PitchOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-RollOffset: %w", err)
	} else {
		val.RollOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarCalibrateCompass struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	CalibrateFunction AirmarCalibrateFunctionConst
	CalibrationStatus AirmarCalibrateStatusConst
	VerifyScore *uint8
	XAxisGainValue *float32
	YAxisGainValue *float32
	ZAxisGainValue *float32
	XAxisLinearOffset *float32
	YAxisLinearOffset *float32
	ZAxisLinearOffset *float32
	XAxisAngularOffset *float32
	PitchAndRollDamping *float32
	CompassRateGyroDamping *float32
}
func DecodeAirmarCalibrateCompass(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarCalibrateCompass
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateCompass-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateCompass-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-ProprietaryId: %w", err)
	} else {
		if v != 33 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateCompass-ProprietaryId: Expected %d != %d", 33, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-CalibrateFunction: %w", err)
	} else {
		val.CalibrateFunction = AirmarCalibrateFunctionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-CalibrationStatus: %w", err)
	} else {
		val.CalibrationStatus = AirmarCalibrateStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-VerifyScore: %w", err)
	} else {
		val.VerifyScore = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-XAxisGainValue: %w", err)
	} else {
		val.XAxisGainValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-YAxisGainValue: %w", err)
	} else {
		val.YAxisGainValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-ZAxisGainValue: %w", err)
	} else {
		val.ZAxisGainValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-XAxisLinearOffset: %w", err)
	} else {
		val.XAxisLinearOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-YAxisLinearOffset: %w", err)
	} else {
		val.YAxisLinearOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-ZAxisLinearOffset: %w", err)
	} else {
		val.ZAxisLinearOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-XAxisAngularOffset: %w", err)
	} else {
		val.XAxisAngularOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.05); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-PitchAndRollDamping: %w", err)
	} else {
		val.PitchAndRollDamping = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.05); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateCompass-CompassRateGyroDamping: %w", err)
	} else {
		val.CompassRateGyroDamping = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarTrueWindOptions struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	CogSubstitutionForHdg YesNoConst
}
func DecodeAirmarTrueWindOptions(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarTrueWindOptions
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTrueWindOptions-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarTrueWindOptions-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTrueWindOptions-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarTrueWindOptions-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTrueWindOptions-ProprietaryId: %w", err)
	} else {
		if v != 34 {
			return nil, fmt.Errorf("match failed for AirmarTrueWindOptions-ProprietaryId: Expected %d != %d", 34, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTrueWindOptions-CogSubstitutionForHdg: %w", err)
	} else {
		val.CogSubstitutionForHdg = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarSimulateMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	SimulateMode OffOnConst
}
func DecodeAirmarSimulateMode(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarSimulateMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ProprietaryId: %w", err)
	} else {
		if v != 35 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-ProprietaryId: Expected %d != %d", 35, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-SimulateMode: %w", err)
	} else {
		val.SimulateMode = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarCalibrateDepth struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	SpeedOfSoundMode *float32
}
func DecodeAirmarCalibrateDepth(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarCalibrateDepth
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ProprietaryId: %w", err)
	} else {
		if v != 40 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ProprietaryId: Expected %d != %d", 40, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-SpeedOfSoundMode: %w", err)
	} else {
		val.SpeedOfSoundMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarCalibrateSpeed struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	NumberOfPairsOfDataPoints *uint8
	Repeating1 []AirmarCalibrateSpeedRepeating1
}
type AirmarCalibrateSpeedRepeating1 struct {
	InputFrequency *float32
	OutputSpeed *float32
}
func DecodeAirmarCalibrateSpeed(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarCalibrateSpeed
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ProprietaryId: %w", err)
	} else {
		if v != 41 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ProprietaryId: Expected %d != %d", 41, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-NumberOfPairsOfDataPoints: %w", err)
	} else {
		val.NumberOfPairsOfDataPoints = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AirmarCalibrateSpeedRepeating1, 0)
	i := 0 
	for {
		var rep AirmarCalibrateSpeedRepeating1
		if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-InputFrequency: %w", err)
		} else {
			rep.InputFrequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-OutputSpeed: %w", err)
		} else {
			rep.OutputSpeed = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AirmarCalibrateTemperature struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	TemperatureInstance AirmarTemperatureInstanceConst
	TemperatureOffset *float32
}
func DecodeAirmarCalibrateTemperature(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarCalibrateTemperature
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ProprietaryId: %w", err)
	} else {
		if v != 42 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ProprietaryId: Expected %d != %d", 42, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureInstance: %w", err)
	} else {
		val.TemperatureInstance = AirmarTemperatureInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureOffset: %w", err)
	} else {
		val.TemperatureOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarSpeedFilterNone struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
}
func DecodeAirmarSpeedFilterNone(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarSpeedFilterNone
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ProprietaryId: %w", err)
	} else {
		if v != 43 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ProprietaryId: Expected %d != %d", 43, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-FilterType: %w", err)
	} else {
		if v != nil && *v != 0 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-FilterType: Expected %d != %d", 0, *v)
		}
		val.FilterType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarSpeedFilterIir struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
	FilterDuration *float32
}
func DecodeAirmarSpeedFilterIir(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarSpeedFilterIir
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ProprietaryId: %w", err)
	} else {
		if v != 43 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ProprietaryId: Expected %d != %d", 43, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterType: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-FilterType: Expected %d != %d", 1, *v)
		}
		val.FilterType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterDuration: %w", err)
	} else {
		val.FilterDuration = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarTemperatureFilterNone struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
}
func DecodeAirmarTemperatureFilterNone(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarTemperatureFilterNone
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ProprietaryId: %w", err)
	} else {
		if v != 44 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ProprietaryId: Expected %d != %d", 44, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-FilterType: %w", err)
	} else {
		if v != nil && *v != 0 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-FilterType: Expected %d != %d", 0, *v)
		}
		val.FilterType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarTemperatureFilterIir struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
	FilterDuration *float32
}
func DecodeAirmarTemperatureFilterIir(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarTemperatureFilterIir
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ProprietaryId: %w", err)
	} else {
		if v != 44 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ProprietaryId: Expected %d != %d", 44, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterType: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-FilterType: Expected %d != %d", 1, *v)
		}
		val.FilterType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterDuration: %w", err)
	} else {
		val.FilterDuration = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarNmea2000Options struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	TransmissionInterval AirmarTransmissionIntervalConst
}
func DecodeAirmarNmea2000Options(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarNmea2000Options
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ProprietaryId: %w", err)
	} else {
		if v != 46 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ProprietaryId: Expected %d != %d", 46, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-TransmissionInterval: %w", err)
	} else {
		val.TransmissionInterval = AirmarTransmissionIntervalConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarAddressableMultiFrame struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId *uint8
}
func DecodeAirmarAddressableMultiFrame(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarAddressableMultiFrame
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAddressableMultiFrame-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAddressableMultiFrame-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAddressableMultiFrame-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAddressableMultiFrame-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAddressableMultiFrame-ProprietaryId: %w", err)
	} else {
		val.ProprietaryId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronSlaveResponse struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProductCode *uint16
	SoftwareCode *uint16
	Command *uint8
	Status *uint8
}
func DecodeMaretronSlaveResponse(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronSlaveResponse
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSlaveResponse-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSlaveResponse-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ProductCode: %w", err)
	} else {
		val.ProductCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-SoftwareCode: %w", err)
	} else {
		val.SoftwareCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Command: %w", err)
	} else {
		val.Command = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Alert struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	TemporarySilenceStatus YesNoConst
	AcknowledgeStatus YesNoConst
	EscalationStatus YesNoConst
	TemporarySilenceSupport YesNoConst
	AcknowledgeSupport YesNoConst
	EscalationSupport YesNoConst
	AcknowledgeSourceNetworkIdName *uint64
	TriggerCondition AlertTriggerConditionConst
	ThresholdStatus AlertThresholdStatusConst
	AlertPriority *uint8
	AlertState AlertStateConst
}
func DecodeAlert(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Alert
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceStatus: %w", err)
	} else {
		val.TemporarySilenceStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeStatus: %w", err)
	} else {
		val.AcknowledgeStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-EscalationStatus: %w", err)
	} else {
		val.EscalationStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceSupport: %w", err)
	} else {
		val.TemporarySilenceSupport = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSupport: %w", err)
	} else {
		val.AcknowledgeSupport = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-EscalationSupport: %w", err)
	} else {
		val.EscalationSupport = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSourceNetworkIdName: %w", err)
	} else {
		val.AcknowledgeSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TriggerCondition: %w", err)
	} else {
		val.TriggerCondition = AlertTriggerConditionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-ThresholdStatus: %w", err)
	} else {
		val.ThresholdStatus = AlertThresholdStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertPriority: %w", err)
	} else {
		val.AlertPriority = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertState: %w", err)
	} else {
		val.AlertState = AlertStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AlertResponse struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	AcknowledgeSourceNetworkIdName *uint64
	ResponseCommand AlertResponseCommandConst
}
func DecodeAlertResponse(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AlertResponse
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AcknowledgeSourceNetworkIdName: %w", err)
	} else {
		val.AcknowledgeSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-ResponseCommand: %w", err)
	} else {
		val.ResponseCommand = AlertResponseCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AlertText struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	LanguageId AlertLanguageIdConst
	AlertTextDescription string
	AlertLocationTextDescription string
}
func DecodeAlertText(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AlertText
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-LanguageId: %w", err)
	} else {
		val.LanguageId = AlertLanguageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertTextDescription: %w", err)
	} else {
		val.AlertTextDescription = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertLocationTextDescription: %w", err)
	} else {
		val.AlertLocationTextDescription = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AlertConfiguration struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	AlertControl *uint8
	UserDefinedAlertAssignment *uint8
	ReactivationPeriod *uint8
	TemporarySilencePeriod *uint8
	EscalationPeriod *uint8
}
func DecodeAlertConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AlertConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-AlertControl: %w", err)
	} else {
		val.AlertControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-UserDefinedAlertAssignment: %w", err)
	} else {
		val.UserDefinedAlertAssignment = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-ReactivationPeriod: %w", err)
	} else {
		val.ReactivationPeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-TemporarySilencePeriod: %w", err)
	} else {
		val.TemporarySilencePeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertConfiguration-EscalationPeriod: %w", err)
	} else {
		val.EscalationPeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AlertThreshold struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	NumberOfParameters *uint8
	Repeating1 []AlertThresholdRepeating1
}
type AlertThresholdRepeating1 struct {
	ParameterNumber *uint8
	TriggerMethod *uint8
	ThresholdDataFormat *uint8
	ThresholdLevel *uint64
}
func DecodeAlertThreshold(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AlertThreshold
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertThreshold-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AlertThresholdRepeating1, 0)
	i := 0 
	for {
		var rep AlertThresholdRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AlertThreshold-ParameterNumber: %w", err)
		} else {
			rep.ParameterNumber = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AlertThreshold-TriggerMethod: %w", err)
		} else {
			rep.TriggerMethod = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AlertThreshold-ThresholdDataFormat: %w", err)
		} else {
			rep.ThresholdDataFormat = v
		}
		if v, err := stream.readUInt64(64); err != nil {
			return nil, fmt.Errorf("parse failed for AlertThreshold-ThresholdLevel: %w", err)
		} else {
			rep.ThresholdLevel = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AlertValue struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	NumberOfParameters *uint8
	Repeating1 []AlertValueRepeating1
}
type AlertValueRepeating1 struct {
	ValueParameterNumber *uint8
	ValueDataFormat *uint8
	ValueData *uint64
}
func DecodeAlertValue(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AlertValue
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertId: %w", err)
	} else {
		val.AlertId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertValue-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AlertValueRepeating1, 0)
	i := 0 
	for {
		var rep AlertValueRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AlertValue-ValueParameterNumber: %w", err)
		} else {
			rep.ValueParameterNumber = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AlertValue-ValueDataFormat: %w", err)
		} else {
			rep.ValueDataFormat = v
		}
		if v, err := stream.readUInt64(64); err != nil {
			return nil, fmt.Errorf("parse failed for AlertValue-ValueData: %w", err)
		} else {
			rep.ValueData = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type SystemTime struct {
	Info MessageInfo
	Sid *uint8
	Source SystemTimeConst
	Date *uint16
	Time *float32
}
func DecodeSystemTime(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SystemTime
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Source: %w", err)
	} else {
		val.Source = SystemTimeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Date: %w", err)
	} else {
		val.Date = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Time: %w", err)
	} else {
		val.Time = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Heartbeat struct {
	Info MessageInfo
	DataTransmitOffset *float32
	SequenceCounter *uint8
	Controller1State ControllerStateConst
	Controller2State ControllerStateConst
	EquipmentStatus EquipmentStatusConst
}
func DecodeHeartbeat(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Heartbeat
	val.Info = Info
	if v, err := stream.readUnsignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-DataTransmitOffset: %w", err)
	} else {
		val.DataTransmitOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-SequenceCounter: %w", err)
	} else {
		val.SequenceCounter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-Controller1State: %w", err)
	} else {
		val.Controller1State = ControllerStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-Controller2State: %w", err)
	} else {
		val.Controller2State = ControllerStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-EquipmentStatus: %w", err)
	} else {
		val.EquipmentStatus = EquipmentStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(34)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ProductInformation struct {
	Info MessageInfo
	Nmea2000Version *float32
	ProductCode *uint16
	ModelId string
	SoftwareVersionCode string
	ModelVersion string
	ModelSerialCode string
	CertificationLevel *uint8
	LoadEquivalency *uint8
}
func DecodeProductInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ProductInformation
	val.Info = Info
	if v, err := stream.readUnsignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-Nmea2000Version: %w", err)
	} else {
		val.Nmea2000Version = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ProductCode: %w", err)
	} else {
		val.ProductCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelId: %w", err)
	} else {
		val.ModelId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-SoftwareVersionCode: %w", err)
	} else {
		val.SoftwareVersionCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelVersion: %w", err)
	} else {
		val.ModelVersion = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelSerialCode: %w", err)
	} else {
		val.ModelSerialCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-CertificationLevel: %w", err)
	} else {
		val.CertificationLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-LoadEquivalency: %w", err)
	} else {
		val.LoadEquivalency = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ConfigurationInformation struct {
	Info MessageInfo
	InstallationDescription1 string
	InstallationDescription2 string
	ManufacturerInformation string
}
func DecodeConfigurationInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ConfigurationInformation
	val.Info = Info
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription1: %w", err)
	} else {
		val.InstallationDescription1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription2: %w", err)
	} else {
		val.InstallationDescription2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-ManufacturerInformation: %w", err)
	} else {
		val.ManufacturerInformation = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ManOverboardNotification struct {
	Info MessageInfo
	Sid *uint8
	MobEmitterId *uint32
	ManOverboardStatus MobStatusConst
	ActivationTime *float32
	PositionSource MobPositionSourceConst
	PositionDate *uint16
	PositionTime *float32
	Latitude *float32
	Longitude *float32
	CogReference DirectionReferenceConst
	Cog *float32
	Sog *float32
	MmsiOfVesselOfOrigin *uint32
	MobEmitterBatteryLowStatus LowBatteryConst
}
func DecodeManOverboardNotification(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ManOverboardNotification
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterId: %w", err)
	} else {
		val.MobEmitterId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-ManOverboardStatus: %w", err)
	} else {
		val.ManOverboardStatus = MobStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-ActivationTime: %w", err)
	} else {
		val.ActivationTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionSource: %w", err)
	} else {
		val.PositionSource = MobPositionSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionDate: %w", err)
	} else {
		val.PositionDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionTime: %w", err)
	} else {
		val.PositionTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-CogReference: %w", err)
	} else {
		val.CogReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MmsiOfVesselOfOrigin: %w", err)
	} else {
		val.MmsiOfVesselOfOrigin = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterBatteryLowStatus: %w", err)
	} else {
		val.MobEmitterBatteryLowStatus = LowBatteryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type HeadingTrackControl struct {
	Info MessageInfo
	RudderLimitExceeded YesNoConst
	OffHeadingLimitExceeded YesNoConst
	OffTrackLimitExceeded YesNoConst
	Override YesNoConst
	SteeringMode SteeringModeConst
	TurnMode TurnModeConst
	HeadingReference DirectionReferenceConst
	CommandedRudderDirection DirectionRudderConst
	CommandedRudderAngle *float32
	HeadingToSteerCourse *float32
	Track *float32
	RudderLimit *float32
	OffHeadingLimit *float32
	RadiusOfTurnOrder *float32
	RateOfTurnOrder *float32
	OffTrackLimit *int16
	VesselHeading *float32
}
func DecodeHeadingTrackControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val HeadingTrackControl
	val.Info = Info
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimitExceeded: %w", err)
	} else {
		val.RudderLimitExceeded = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimitExceeded: %w", err)
	} else {
		val.OffHeadingLimitExceeded = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimitExceeded: %w", err)
	} else {
		val.OffTrackLimitExceeded = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-Override: %w", err)
	} else {
		val.Override = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-SteeringMode: %w", err)
	} else {
		val.SteeringMode = SteeringModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-TurnMode: %w", err)
	} else {
		val.TurnMode = TurnModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingReference: %w", err)
	} else {
		val.HeadingReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderDirection: %w", err)
	} else {
		val.CommandedRudderDirection = DirectionRudderConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderAngle: %w", err)
	} else {
		val.CommandedRudderAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingToSteerCourse: %w", err)
	} else {
		val.HeadingToSteerCourse = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-Track: %w", err)
	} else {
		val.Track = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimit: %w", err)
	} else {
		val.RudderLimit = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimit: %w", err)
	} else {
		val.OffHeadingLimit = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RadiusOfTurnOrder: %w", err)
	} else {
		val.RadiusOfTurnOrder = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 3.125e-05); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RateOfTurnOrder: %w", err)
	} else {
		val.RateOfTurnOrder = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimit: %w", err)
	} else {
		val.OffTrackLimit = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-VesselHeading: %w", err)
	} else {
		val.VesselHeading = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Rudder struct {
	Info MessageInfo
	Instance *uint8
	DirectionOrder DirectionRudderConst
	AngleOrder *float32
	Position *float32
}
func DecodeRudder(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Rudder
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-DirectionOrder: %w", err)
	} else {
		val.DirectionOrder = DirectionRudderConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-AngleOrder: %w", err)
	} else {
		val.AngleOrder = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-Position: %w", err)
	} else {
		val.Position = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type VesselHeading struct {
	Info MessageInfo
	Sid *uint8
	Heading *float32
	Deviation *float32
	Variation *float32
	Reference DirectionReferenceConst
}
func DecodeVesselHeading(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val VesselHeading
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Heading: %w", err)
	} else {
		val.Heading = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Deviation: %w", err)
	} else {
		val.Deviation = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Variation: %w", err)
	} else {
		val.Variation = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Reference: %w", err)
	} else {
		val.Reference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type RateOfTurn struct {
	Info MessageInfo
	Sid *uint8
	Rate *float32
}
func DecodeRateOfTurn(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RateOfTurn
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RateOfTurn-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 3.125e-08); err != nil {
		return nil, fmt.Errorf("parse failed for RateOfTurn-Rate: %w", err)
	} else {
		val.Rate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Heave struct {
	Info MessageInfo
	Sid *uint8
	Heave *float32
}
func DecodeHeave(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Heave
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Heave-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Heave-Heave: %w", err)
	} else {
		val.Heave = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(40)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Attitude struct {
	Info MessageInfo
	Sid *uint8
	Yaw *float32
	Pitch *float32
	Roll *float32
}
func DecodeAttitude(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Attitude
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Yaw: %w", err)
	} else {
		val.Yaw = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Pitch: %w", err)
	} else {
		val.Pitch = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Roll: %w", err)
	} else {
		val.Roll = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type MagneticVariation struct {
	Info MessageInfo
	Sid *uint8
	Source MagneticVariationConst
	AgeOfService *uint16
	Variation *float32
}
func DecodeMagneticVariation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MagneticVariation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Source: %w", err)
	} else {
		val.Source = MagneticVariationConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-AgeOfService: %w", err)
	} else {
		val.AgeOfService = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Variation: %w", err)
	} else {
		val.Variation = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EngineParametersRapidUpdate struct {
	Info MessageInfo
	Instance EngineInstanceConst
	Speed *float32
	BoostPressure *float32
	TiltTrim *int8
}
func DecodeEngineParametersRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val EngineParametersRapidUpdate
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Speed: %w", err)
	} else {
		val.Speed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-BoostPressure: %w", err)
	} else {
		val.BoostPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-TiltTrim: %w", err)
	} else {
		val.TiltTrim = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EngineParametersDynamic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	OilPressure *float32
	OilTemperature *float32
	Temperature *float32
	AlternatorPotential *float32
	FuelRate *float32
	TotalEngineHours *uint32
	CoolantPressure *float32
	FuelPressure *float32
	DiscreteStatus1 EngineStatus1Const
	DiscreteStatus2 EngineStatus2Const
	EngineLoad *int8
	EngineTorque *int8
}
func DecodeEngineParametersDynamic(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val EngineParametersDynamic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilPressure: %w", err)
	} else {
		val.OilPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilTemperature: %w", err)
	} else {
		val.OilTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Temperature: %w", err)
	} else {
		val.Temperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-AlternatorPotential: %w", err)
	} else {
		val.AlternatorPotential = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelRate: %w", err)
	} else {
		val.FuelRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-TotalEngineHours: %w", err)
	} else {
		val.TotalEngineHours = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-CoolantPressure: %w", err)
	} else {
		val.CoolantPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 1000); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelPressure: %w", err)
	} else {
		val.FuelPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus1: %w", err)
	} else {
		val.DiscreteStatus1 = EngineStatus1Const(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus2: %w", err)
	} else {
		val.DiscreteStatus2 = EngineStatus2Const(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineLoad: %w", err)
	} else {
		val.EngineLoad = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineTorque: %w", err)
	} else {
		val.EngineTorque = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ElectricDriveStatusDynamic struct {
	Info MessageInfo
	InverterMotorIdentifier *uint8
	OperatingMode *uint8
	MotorTemperature *float32
	InverterTemperature *float32
	CoolantTemperature *float32
	GearTemperature *float32
	ShaftTorque *uint16
}
func DecodeElectricDriveStatusDynamic(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricDriveStatusDynamic
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-InverterMotorIdentifier: %w", err)
	} else {
		val.InverterMotorIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-OperatingMode: %w", err)
	} else {
		val.OperatingMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-MotorTemperature: %w", err)
	} else {
		val.MotorTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-InverterTemperature: %w", err)
	} else {
		val.InverterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-CoolantTemperature: %w", err)
	} else {
		val.CoolantTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-GearTemperature: %w", err)
	} else {
		val.GearTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusDynamic-ShaftTorque: %w", err)
	} else {
		val.ShaftTorque = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ElectricEnergyStorageStatusDynamic struct {
	Info MessageInfo
	EnergyStorageIdentifier *uint8
	StateOfCharge *uint8
	TimeRemaining *float32
	HighestCellTemperature *float32
	LowestCellTemperature *float32
	AverageCellTemperature *float32
	MaxDischargeCurrent *float32
	MaxChargeCurrent *float32
	CoolingSystemStatus *uint8
	HeatingSystemStatus *uint8
}
func DecodeElectricEnergyStorageStatusDynamic(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricEnergyStorageStatusDynamic
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-EnergyStorageIdentifier: %w", err)
	} else {
		val.EnergyStorageIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-StateOfCharge: %w", err)
	} else {
		val.StateOfCharge = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-TimeRemaining: %w", err)
	} else {
		val.TimeRemaining = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-HighestCellTemperature: %w", err)
	} else {
		val.HighestCellTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-LowestCellTemperature: %w", err)
	} else {
		val.LowestCellTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-AverageCellTemperature: %w", err)
	} else {
		val.AverageCellTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-MaxDischargeCurrent: %w", err)
	} else {
		val.MaxDischargeCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-MaxChargeCurrent: %w", err)
	} else {
		val.MaxChargeCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-CoolingSystemStatus: %w", err)
	} else {
		val.CoolingSystemStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusDynamic-HeatingSystemStatus: %w", err)
	} else {
		val.HeatingSystemStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TransmissionParametersDynamic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	TransmissionGear GearStatusConst
	OilPressure *float32
	OilTemperature *float32
	DiscreteStatus1 *uint8
}
func DecodeTransmissionParametersDynamic(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TransmissionParametersDynamic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-TransmissionGear: %w", err)
	} else {
		val.TransmissionGear = GearStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilPressure: %w", err)
	} else {
		val.OilPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilTemperature: %w", err)
	} else {
		val.OilTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-DiscreteStatus1: %w", err)
	} else {
		val.DiscreteStatus1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ElectricDriveInformation struct {
	Info MessageInfo
	InverterMotorIdentifier *uint8
	MotorType *uint8
	MotorVoltageRating *float32
	MaximumContinuousMotorPower *uint32
	MaximumBoostMotorPower *uint32
	MaximumMotorTemperatureRating *float32
	RatedMotorSpeed *float32
	MaximumControllerTemperatureRating *float32
	MotorShaftTorqueRating *uint16
	MotorDcVoltageDeratingThreshold *float32
	MotorDcVoltageCutOffThreshold *float32
	DriveMotorHours *uint32
}
func DecodeElectricDriveInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricDriveInformation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-InverterMotorIdentifier: %w", err)
	} else {
		val.InverterMotorIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MotorType: %w", err)
	} else {
		val.MotorType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MotorVoltageRating: %w", err)
	} else {
		val.MotorVoltageRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MaximumContinuousMotorPower: %w", err)
	} else {
		val.MaximumContinuousMotorPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MaximumBoostMotorPower: %w", err)
	} else {
		val.MaximumBoostMotorPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MaximumMotorTemperatureRating: %w", err)
	} else {
		val.MaximumMotorTemperatureRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-RatedMotorSpeed: %w", err)
	} else {
		val.RatedMotorSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MaximumControllerTemperatureRating: %w", err)
	} else {
		val.MaximumControllerTemperatureRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MotorShaftTorqueRating: %w", err)
	} else {
		val.MotorShaftTorqueRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MotorDcVoltageDeratingThreshold: %w", err)
	} else {
		val.MotorDcVoltageDeratingThreshold = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-MotorDcVoltageCutOffThreshold: %w", err)
	} else {
		val.MotorDcVoltageCutOffThreshold = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveInformation-DriveMotorHours: %w", err)
	} else {
		val.DriveMotorHours = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ElectricEnergyStorageInformation struct {
	Info MessageInfo
	EnergyStorageIdentifier *uint8
	MotorType *uint8
	StorageChemistryConversion *uint8
	MaximumTemperatureDerating *float32
	MaximumTemperatureShutOff *float32
	MinimumTemperatureDerating *float32
	MinimumTemperatureShutOff *float32
	UsableBatteryEnergy *uint32
	StateOfHealth *uint8
	BatteryCycleCounter *uint16
	BatteryFullStatus *uint8
	BatteryEmptyStatus *uint8
	MaximumChargeSoc *uint8
	MinimumChargeSoc *uint8
}
func DecodeElectricEnergyStorageInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricEnergyStorageInformation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-EnergyStorageIdentifier: %w", err)
	} else {
		val.EnergyStorageIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MotorType: %w", err)
	} else {
		val.MotorType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-StorageChemistryConversion: %w", err)
	} else {
		val.StorageChemistryConversion = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MaximumTemperatureDerating: %w", err)
	} else {
		val.MaximumTemperatureDerating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MaximumTemperatureShutOff: %w", err)
	} else {
		val.MaximumTemperatureShutOff = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MinimumTemperatureDerating: %w", err)
	} else {
		val.MinimumTemperatureDerating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MinimumTemperatureShutOff: %w", err)
	} else {
		val.MinimumTemperatureShutOff = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-UsableBatteryEnergy: %w", err)
	} else {
		val.UsableBatteryEnergy = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-StateOfHealth: %w", err)
	} else {
		val.StateOfHealth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-BatteryCycleCounter: %w", err)
	} else {
		val.BatteryCycleCounter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-BatteryFullStatus: %w", err)
	} else {
		val.BatteryFullStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-BatteryEmptyStatus: %w", err)
	} else {
		val.BatteryEmptyStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MaximumChargeSoc: %w", err)
	} else {
		val.MaximumChargeSoc = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageInformation-MinimumChargeSoc: %w", err)
	} else {
		val.MinimumChargeSoc = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TripParametersVessel struct {
	Info MessageInfo
	TimeToEmpty *float32
	DistanceToEmpty *float32
	EstimatedFuelRemaining *uint16
	TripRunTime *float32
}
func DecodeTripParametersVessel(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TripParametersVessel
	val.Info = Info
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-TimeToEmpty: %w", err)
	} else {
		val.TimeToEmpty = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-DistanceToEmpty: %w", err)
	} else {
		val.DistanceToEmpty = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-EstimatedFuelRemaining: %w", err)
	} else {
		val.EstimatedFuelRemaining = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-TripRunTime: %w", err)
	} else {
		val.TripRunTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TripParametersEngine struct {
	Info MessageInfo
	Instance EngineInstanceConst
	TripFuelUsed *uint16
	FuelRateAverage *float32
	FuelRateEconomy *float32
	InstantaneousFuelEconomy *float32
}
func DecodeTripParametersEngine(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TripParametersEngine
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-TripFuelUsed: %w", err)
	} else {
		val.TripFuelUsed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateAverage: %w", err)
	} else {
		val.FuelRateAverage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateEconomy: %w", err)
	} else {
		val.FuelRateEconomy = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-InstantaneousFuelEconomy: %w", err)
	} else {
		val.InstantaneousFuelEconomy = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type EngineParametersStatic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	RatedEngineSpeed *float32
	Vin string
	SoftwareId string
}
func DecodeEngineParametersStatic(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val EngineParametersStatic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-RatedEngineSpeed: %w", err)
	} else {
		val.RatedEngineSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(136); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-Vin: %w", err)
	} else {
		val.Vin = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-SoftwareId: %w", err)
	} else {
		val.SoftwareId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LoadControllerConnectionStateControl struct {
	Info MessageInfo
	SequenceId *uint8
	ConnectionId *uint8
	State *uint8
	Status *uint8
	OperationalStatusControl *uint8
	PwmDutyCycle *uint8
	Timeon *uint8
	Timeoff *uint8
}
func DecodeLoadControllerConnectionStateControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LoadControllerConnectionStateControl
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-SequenceId: %w", err)
	} else {
		val.SequenceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-ConnectionId: %w", err)
	} else {
		val.ConnectionId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-State: %w", err)
	} else {
		val.State = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-OperationalStatusControl: %w", err)
	} else {
		val.OperationalStatusControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-PwmDutyCycle: %w", err)
	} else {
		val.PwmDutyCycle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeon: %w", err)
	} else {
		val.Timeon = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeoff: %w", err)
	} else {
		val.Timeoff = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BinarySwitchBankStatus struct {
	Info MessageInfo
	Instance *uint8
	Indicator1 OffOnConst
	Indicator2 OffOnConst
	Indicator3 OffOnConst
	Indicator4 OffOnConst
	Indicator5 OffOnConst
	Indicator6 OffOnConst
	Indicator7 OffOnConst
	Indicator8 OffOnConst
	Indicator9 OffOnConst
	Indicator10 OffOnConst
	Indicator11 OffOnConst
	Indicator12 OffOnConst
	Indicator13 OffOnConst
	Indicator14 OffOnConst
	Indicator15 OffOnConst
	Indicator16 OffOnConst
	Indicator17 OffOnConst
	Indicator18 OffOnConst
	Indicator19 OffOnConst
	Indicator20 OffOnConst
	Indicator21 OffOnConst
	Indicator22 OffOnConst
	Indicator23 OffOnConst
	Indicator24 OffOnConst
	Indicator25 OffOnConst
	Indicator26 OffOnConst
	Indicator27 OffOnConst
	Indicator28 OffOnConst
}
func DecodeBinarySwitchBankStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BinarySwitchBankStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator1: %w", err)
	} else {
		val.Indicator1 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator2: %w", err)
	} else {
		val.Indicator2 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator3: %w", err)
	} else {
		val.Indicator3 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator4: %w", err)
	} else {
		val.Indicator4 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator5: %w", err)
	} else {
		val.Indicator5 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator6: %w", err)
	} else {
		val.Indicator6 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator7: %w", err)
	} else {
		val.Indicator7 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator8: %w", err)
	} else {
		val.Indicator8 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator9: %w", err)
	} else {
		val.Indicator9 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator10: %w", err)
	} else {
		val.Indicator10 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator11: %w", err)
	} else {
		val.Indicator11 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator12: %w", err)
	} else {
		val.Indicator12 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator13: %w", err)
	} else {
		val.Indicator13 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator14: %w", err)
	} else {
		val.Indicator14 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator15: %w", err)
	} else {
		val.Indicator15 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator16: %w", err)
	} else {
		val.Indicator16 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator17: %w", err)
	} else {
		val.Indicator17 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator18: %w", err)
	} else {
		val.Indicator18 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator19: %w", err)
	} else {
		val.Indicator19 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator20: %w", err)
	} else {
		val.Indicator20 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator21: %w", err)
	} else {
		val.Indicator21 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator22: %w", err)
	} else {
		val.Indicator22 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator23: %w", err)
	} else {
		val.Indicator23 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator24: %w", err)
	} else {
		val.Indicator24 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator25: %w", err)
	} else {
		val.Indicator25 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator26: %w", err)
	} else {
		val.Indicator26 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator27: %w", err)
	} else {
		val.Indicator27 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator28: %w", err)
	} else {
		val.Indicator28 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SwitchBankControl struct {
	Info MessageInfo
	Instance *uint8
	Switch1 OffOnConst
	Switch2 OffOnConst
	Switch3 OffOnConst
	Switch4 OffOnConst
	Switch5 OffOnConst
	Switch6 OffOnConst
	Switch7 OffOnConst
	Switch8 OffOnConst
	Switch9 OffOnConst
	Switch10 OffOnConst
	Switch11 OffOnConst
	Switch12 OffOnConst
	Switch13 OffOnConst
	Switch14 OffOnConst
	Switch15 OffOnConst
	Switch16 OffOnConst
	Switch17 OffOnConst
	Switch18 OffOnConst
	Switch19 OffOnConst
	Switch20 OffOnConst
	Switch21 OffOnConst
	Switch22 OffOnConst
	Switch23 OffOnConst
	Switch24 OffOnConst
	Switch25 OffOnConst
	Switch26 OffOnConst
	Switch27 OffOnConst
	Switch28 OffOnConst
}
func DecodeSwitchBankControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SwitchBankControl
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch1: %w", err)
	} else {
		val.Switch1 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch2: %w", err)
	} else {
		val.Switch2 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch3: %w", err)
	} else {
		val.Switch3 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch4: %w", err)
	} else {
		val.Switch4 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch5: %w", err)
	} else {
		val.Switch5 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch6: %w", err)
	} else {
		val.Switch6 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch7: %w", err)
	} else {
		val.Switch7 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch8: %w", err)
	} else {
		val.Switch8 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch9: %w", err)
	} else {
		val.Switch9 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch10: %w", err)
	} else {
		val.Switch10 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch11: %w", err)
	} else {
		val.Switch11 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch12: %w", err)
	} else {
		val.Switch12 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch13: %w", err)
	} else {
		val.Switch13 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch14: %w", err)
	} else {
		val.Switch14 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch15: %w", err)
	} else {
		val.Switch15 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch16: %w", err)
	} else {
		val.Switch16 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch17: %w", err)
	} else {
		val.Switch17 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch18: %w", err)
	} else {
		val.Switch18 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch19: %w", err)
	} else {
		val.Switch19 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch20: %w", err)
	} else {
		val.Switch20 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch21: %w", err)
	} else {
		val.Switch21 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch22: %w", err)
	} else {
		val.Switch22 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch23: %w", err)
	} else {
		val.Switch23 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch24: %w", err)
	} else {
		val.Switch24 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch25: %w", err)
	} else {
		val.Switch25 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch26: %w", err)
	} else {
		val.Switch26 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch27: %w", err)
	} else {
		val.Switch27 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch28: %w", err)
	} else {
		val.Switch28 = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcInputStatus struct {
	Info MessageInfo
	Instance *uint8
	NumberOfLines *uint8
	Repeating1 []AcInputStatusRepeating1
}
type AcInputStatusRepeating1 struct {
	Line *uint8
	Acceptability AcceptabilityConst
	Voltage *float32
	Current *float32
	Frequency *float32
	BreakerSize *float32
	RealPower *uint32
	ReactivePower *uint32
	PowerFactor *float32
}
func DecodeAcInputStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AcInputStatus
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcInputStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcInputStatus-NumberOfLines: %w", err)
	} else {
		val.NumberOfLines = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AcInputStatusRepeating1, 0)
	i := 0 
	for {
		var rep AcInputStatusRepeating1
		if v, err := stream.readUInt8(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Line: %w", err)
		} else {
			rep.Line = v
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Acceptability: %w", err)
		} else {
			rep.Acceptability = AcceptabilityConst(v)
		}
		stream.skipBits(4)
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AcOutputStatus struct {
	Info MessageInfo
	Instance *uint8
	NumberOfLines *uint8
	Repeating1 []AcOutputStatusRepeating1
}
type AcOutputStatusRepeating1 struct {
	Line LineConst
	Waveform WaveformConst
	Voltage *float32
	Current *float32
	Frequency *float32
	BreakerSize *float32
	RealPower *uint32
	ReactivePower *uint32
	PowerFactor *float32
}
func DecodeAcOutputStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AcOutputStatus
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcOutputStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcOutputStatus-NumberOfLines: %w", err)
	} else {
		val.NumberOfLines = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AcOutputStatusRepeating1, 0)
	i := 0 
	for {
		var rep AcOutputStatusRepeating1
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Line: %w", err)
		} else {
			rep.Line = LineConst(v)
		}
		if v, err := stream.readLookupField(3); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Waveform: %w", err)
		} else {
			rep.Waveform = WaveformConst(v)
		}
		stream.skipBits(3)
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type FluidLevel struct {
	Info MessageInfo
	Instance *uint8
	Type TankTypeConst
	Level *float32
	Capacity *float32
}
func DecodeFluidLevel(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FluidLevel
	val.Info = Info
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Type: %w", err)
	} else {
		val.Type = TankTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.004); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Level: %w", err)
	} else {
		val.Level = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Capacity: %w", err)
	} else {
		val.Capacity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type DcDetailedStatus struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	DcType DcSourceConst
	StateOfCharge *uint8
	StateOfHealth *uint8
	TimeRemaining *float32
	RippleVoltage *float32
	RemainingCapacity *uint16
}
func DecodeDcDetailedStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DcDetailedStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-DcType: %w", err)
	} else {
		val.DcType = DcSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfCharge: %w", err)
	} else {
		val.StateOfCharge = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfHealth: %w", err)
	} else {
		val.StateOfHealth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-TimeRemaining: %w", err)
	} else {
		val.TimeRemaining = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-RippleVoltage: %w", err)
	} else {
		val.RippleVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-RemainingCapacity: %w", err)
	} else {
		val.RemainingCapacity = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ChargerStatus struct {
	Info MessageInfo
	Instance *uint8
	BatteryInstance *uint8
	OperatingState ChargerStateConst
	ChargeMode ChargerModeConst
	Enabled OffOnConst
	EqualizationPending OffOnConst
	EqualizationTimeRemaining *float32
}
func DecodeChargerStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ChargerStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-BatteryInstance: %w", err)
	} else {
		val.BatteryInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = ChargerStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-ChargeMode: %w", err)
	} else {
		val.ChargeMode = ChargerModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-Enabled: %w", err)
	} else {
		val.Enabled = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationPending: %w", err)
	} else {
		val.EqualizationPending = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationTimeRemaining: %w", err)
	} else {
		val.EqualizationTimeRemaining = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BatteryStatus struct {
	Info MessageInfo
	Instance *uint8
	Voltage *float32
	Current *float32
	Temperature *float32
	Sid *uint8
}
func DecodeBatteryStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BatteryStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Voltage: %w", err)
	} else {
		val.Voltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Current: %w", err)
	} else {
		val.Current = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Temperature: %w", err)
	} else {
		val.Temperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type InverterStatus struct {
	Info MessageInfo
	Instance *uint8
	AcInstance *uint8
	DcInstance *uint8
	OperatingState InverterStateConst
	InverterEnable OffOnConst
}
func DecodeInverterStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val InverterStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-AcInstance: %w", err)
	} else {
		val.AcInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-DcInstance: %w", err)
	} else {
		val.DcInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = InverterStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-InverterEnable: %w", err)
	} else {
		val.InverterEnable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(34)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ChargerConfigurationStatus struct {
	Info MessageInfo
	Instance *uint8
	BatteryInstance *uint8
	ChargerEnableDisable OffOnConst
	ChargeCurrentLimit *uint8
	ChargingAlgorithm ChargingAlgorithmConst
	ChargerMode ChargerModeConst
	EstimatedTemperature DeviceTempStateConst
	EqualizeOneTimeEnableDisable OffOnConst
	OverChargeEnableDisable OffOnConst
	EqualizeTime *float32
}
func DecodeChargerConfigurationStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ChargerConfigurationStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-BatteryInstance: %w", err)
	} else {
		val.BatteryInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-ChargerEnableDisable: %w", err)
	} else {
		val.ChargerEnableDisable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-ChargeCurrentLimit: %w", err)
	} else {
		val.ChargeCurrentLimit = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-ChargingAlgorithm: %w", err)
	} else {
		val.ChargingAlgorithm = ChargingAlgorithmConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-ChargerMode: %w", err)
	} else {
		val.ChargerMode = ChargerModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-EstimatedTemperature: %w", err)
	} else {
		val.EstimatedTemperature = DeviceTempStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-EqualizeOneTimeEnableDisable: %w", err)
	} else {
		val.EqualizeOneTimeEnableDisable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-OverChargeEnableDisable: %w", err)
	} else {
		val.OverChargeEnableDisable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerConfigurationStatus-EqualizeTime: %w", err)
	} else {
		val.EqualizeTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type InverterConfigurationStatus struct {
	Info MessageInfo
	Instance *uint8
	AcInstance *uint8
	DcInstance *uint8
	InverterEnableDisable *uint8
	InverterMode *uint8
	LoadSenseEnableDisable *uint8
	LoadSensePowerThreshold *uint8
	LoadSenseInterval *uint8
}
func DecodeInverterConfigurationStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val InverterConfigurationStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-AcInstance: %w", err)
	} else {
		val.AcInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-DcInstance: %w", err)
	} else {
		val.DcInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-InverterEnableDisable: %w", err)
	} else {
		val.InverterEnableDisable = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-InverterMode: %w", err)
	} else {
		val.InverterMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-LoadSenseEnableDisable: %w", err)
	} else {
		val.LoadSenseEnableDisable = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-LoadSensePowerThreshold: %w", err)
	} else {
		val.LoadSensePowerThreshold = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterConfigurationStatus-LoadSenseInterval: %w", err)
	} else {
		val.LoadSenseInterval = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AgsConfigurationStatus struct {
	Info MessageInfo
	Instance *uint8
	GeneratorInstance *uint8
	AgsMode *uint8
}
func DecodeAgsConfigurationStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AgsConfigurationStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsConfigurationStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsConfigurationStatus-GeneratorInstance: %w", err)
	} else {
		val.GeneratorInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsConfigurationStatus-AgsMode: %w", err)
	} else {
		val.AgsMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(40)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type BatteryConfigurationStatus struct {
	Info MessageInfo
	Instance *uint8
	BatteryType BatteryTypeConst
	SupportsEqualization YesNoConst
	NominalVoltage BatteryVoltageConst
	Chemistry BatteryChemistryConst
	Capacity *uint16
	TemperatureCoefficient *int8
	PeukertExponent *float32
	ChargeEfficiencyFactor *int8
}
func DecodeBatteryConfigurationStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BatteryConfigurationStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-BatteryType: %w", err)
	} else {
		val.BatteryType = BatteryTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-SupportsEqualization: %w", err)
	} else {
		val.SupportsEqualization = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-NominalVoltage: %w", err)
	} else {
		val.NominalVoltage = BatteryVoltageConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-Chemistry: %w", err)
	} else {
		val.Chemistry = BatteryChemistryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-Capacity: %w", err)
	} else {
		val.Capacity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-TemperatureCoefficient: %w", err)
	} else {
		val.TemperatureCoefficient = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.002); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-PeukertExponent: %w", err)
	} else {
		val.PeukertExponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryConfigurationStatus-ChargeEfficiencyFactor: %w", err)
	} else {
		val.ChargeEfficiencyFactor = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AgsStatus struct {
	Info MessageInfo
	Instance *uint8
	GeneratorInstance *uint8
	AgsOperatingState *uint8
	GeneratorState *uint8
	GeneratorOnReason *uint8
	GeneratorOffReason *uint8
}
func DecodeAgsStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AgsStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-GeneratorInstance: %w", err)
	} else {
		val.GeneratorInstance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-AgsOperatingState: %w", err)
	} else {
		val.AgsOperatingState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-GeneratorState: %w", err)
	} else {
		val.GeneratorState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-GeneratorOnReason: %w", err)
	} else {
		val.GeneratorOnReason = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AgsStatus-GeneratorOffReason: %w", err)
	} else {
		val.GeneratorOffReason = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AcPowerCurrentPhaseA struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func DecodeAcPowerCurrentPhaseA(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AcPowerCurrentPhaseA
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Power: %w", err)
	} else {
		val.Power = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcPowerCurrentPhaseB struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func DecodeAcPowerCurrentPhaseB(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AcPowerCurrentPhaseB
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Power: %w", err)
	} else {
		val.Power = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcPowerCurrentPhaseC struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func DecodeAcPowerCurrentPhaseC(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AcPowerCurrentPhaseC
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Power: %w", err)
	} else {
		val.Power = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ConverterStatus struct {
	Info MessageInfo
	Sid interface{}
	ConnectionNumber *uint8
	OperatingState ConverterStateConst
	TemperatureState GoodWarningErrorConst
	OverloadState GoodWarningErrorConst
	LowDcVoltageState GoodWarningErrorConst
	RippleState GoodWarningErrorConst
}
func DecodeConverterStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ConverterStatus
	val.Info = Info
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = ConverterStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-TemperatureState: %w", err)
	} else {
		val.TemperatureState = GoodWarningErrorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-OverloadState: %w", err)
	} else {
		val.OverloadState = GoodWarningErrorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-LowDcVoltageState: %w", err)
	} else {
		val.LowDcVoltageState = GoodWarningErrorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-RippleState: %w", err)
	} else {
		val.RippleState = GoodWarningErrorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type DcVoltageCurrent struct {
	Info MessageInfo
	Sid interface{}
	ConnectionNumber *uint8
	DcVoltage *float32
	DcCurrent *float32
}
func DecodeDcVoltageCurrent(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DcVoltageCurrent
	val.Info = Info
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcVoltage: %w", err)
	} else {
		val.DcVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(24, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcCurrent: %w", err)
	} else {
		val.DcCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LeewayAngle struct {
	Info MessageInfo
	Sid *uint8
	LeewayAngle *float32
}
func DecodeLeewayAngle(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LeewayAngle
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LeewayAngle-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for LeewayAngle-LeewayAngle: %w", err)
	} else {
		val.LeewayAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(40)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type VesselAcceleration struct {
	Info MessageInfo
	Sid *uint8
	LongitudinalAcceleration *int16
	TransverseAcceleration *int16
	VerticalAcceleration *int16
}
func DecodeVesselAcceleration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val VesselAcceleration
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for VesselAcceleration-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for VesselAcceleration-LongitudinalAcceleration: %w", err)
	} else {
		val.LongitudinalAcceleration = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for VesselAcceleration-TransverseAcceleration: %w", err)
	} else {
		val.TransverseAcceleration = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for VesselAcceleration-VerticalAcceleration: %w", err)
	} else {
		val.VerticalAcceleration = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ElectricDriveStatusRapidUpdate struct {
	Info MessageInfo
	InverterMotorController *uint8
	ActiveMotorMode *uint8
	BrakeMode *uint8
	RotationalShaftSpeed *float32
	MotorDcVoltage *float32
	MotorDcCurrent *float32
}
func DecodeElectricDriveStatusRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricDriveStatusRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-InverterMotorController: %w", err)
	} else {
		val.InverterMotorController = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-ActiveMotorMode: %w", err)
	} else {
		val.ActiveMotorMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-BrakeMode: %w", err)
	} else {
		val.BrakeMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.25); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-RotationalShaftSpeed: %w", err)
	} else {
		val.RotationalShaftSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-MotorDcVoltage: %w", err)
	} else {
		val.MotorDcVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricDriveStatusRapidUpdate-MotorDcCurrent: %w", err)
	} else {
		val.MotorDcCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ElectricEnergyStorageStatusRapidUpdate struct {
	Info MessageInfo
	EnergyStorageIdentifier *uint8
	BatteryStatus *uint8
	IsolationStatus *uint8
	BatteryError *uint8
	BatteryVoltage *float32
	BatteryCurrent *float32
}
func DecodeElectricEnergyStorageStatusRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElectricEnergyStorageStatusRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-EnergyStorageIdentifier: %w", err)
	} else {
		val.EnergyStorageIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-BatteryStatus: %w", err)
	} else {
		val.BatteryStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-IsolationStatus: %w", err)
	} else {
		val.IsolationStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-BatteryError: %w", err)
	} else {
		val.BatteryError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-BatteryVoltage: %w", err)
	} else {
		val.BatteryVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ElectricEnergyStorageStatusRapidUpdate-BatteryCurrent: %w", err)
	} else {
		val.BatteryCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ThrusterControlStatus struct {
	Info MessageInfo
	Sid *uint8
	Identifier *uint8
	DirectionControl ThrusterDirectionControlConst
	PowerEnabled OffOnConst
	RetractControl ThrusterRetractControlConst
	SpeedControl *uint8
	ControlEvents ThrusterControlEventsConst
	CommandTimeout *float32
	AzimuthControl *float32
}
func DecodeThrusterControlStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ThrusterControlStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Identifier: %w", err)
	} else {
		val.Identifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-DirectionControl: %w", err)
	} else {
		val.DirectionControl = ThrusterDirectionControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-PowerEnabled: %w", err)
	} else {
		val.PowerEnabled = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-RetractControl: %w", err)
	} else {
		val.RetractControl = ThrusterRetractControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-SpeedControl: %w", err)
	} else {
		val.SpeedControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-ControlEvents: %w", err)
	} else {
		val.ControlEvents = ThrusterControlEventsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.005); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-CommandTimeout: %w", err)
	} else {
		val.CommandTimeout = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-AzimuthControl: %w", err)
	} else {
		val.AzimuthControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ThrusterInformation struct {
	Info MessageInfo
	Identifier *uint8
	MotorType ThrusterMotorTypeConst
	PowerRating *uint16
	MaximumTemperatureRating *float32
	MaximumRotationalSpeed *float32
}
func DecodeThrusterInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ThrusterInformation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-Identifier: %w", err)
	} else {
		val.Identifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MotorType: %w", err)
	} else {
		val.MotorType = ThrusterMotorTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-PowerRating: %w", err)
	} else {
		val.PowerRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumTemperatureRating: %w", err)
	} else {
		val.MaximumTemperatureRating = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumRotationalSpeed: %w", err)
	} else {
		val.MaximumRotationalSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ThrusterMotorStatus struct {
	Info MessageInfo
	Sid *uint8
	Identifier *uint8
	MotorEvents ThrusterMotorEventsConst
	Current *uint8
	Temperature *float32
	OperatingTime *float32
}
func DecodeThrusterMotorStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ThrusterMotorStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Identifier: %w", err)
	} else {
		val.Identifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-MotorEvents: %w", err)
	} else {
		val.MotorEvents = ThrusterMotorEventsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Current: %w", err)
	} else {
		val.Current = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Temperature: %w", err)
	} else {
		val.Temperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-OperatingTime: %w", err)
	} else {
		val.OperatingTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Speed struct {
	Info MessageInfo
	Sid *uint8
	SpeedWaterReferenced *float32
	SpeedGroundReferenced *float32
	SpeedWaterReferencedType WaterReferenceConst
	SpeedDirection *uint8
}
func DecodeSpeed(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Speed
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferenced: %w", err)
	} else {
		val.SpeedWaterReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedGroundReferenced: %w", err)
	} else {
		val.SpeedGroundReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferencedType: %w", err)
	} else {
		val.SpeedWaterReferencedType = WaterReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedDirection: %w", err)
	} else {
		val.SpeedDirection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(12)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type WaterDepth struct {
	Info MessageInfo
	Sid *uint8
	Depth *float32
	Offset *float32
	Range *float32
}
func DecodeWaterDepth(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val WaterDepth
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Depth: %w", err)
	} else {
		val.Depth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Offset: %w", err)
	} else {
		val.Offset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 10); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Range: %w", err)
	} else {
		val.Range = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type DistanceLog struct {
	Info MessageInfo
	Date *uint16
	Time *float32
	Log *uint32
	TripLog *uint32
}
func DecodeDistanceLog(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DistanceLog
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Date: %w", err)
	} else {
		val.Date = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Time: %w", err)
	} else {
		val.Time = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Log: %w", err)
	} else {
		val.Log = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-TripLog: %w", err)
	} else {
		val.TripLog = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TrackedTargetData struct {
	Info MessageInfo
	Sid *uint8
	TargetId *uint8
	TrackStatus TrackingConst
	ReportedTarget YesNoConst
	TargetAcquisition TargetAcquisitionConst
	BearingReference DirectionReferenceConst
	Bearing *float32
	Distance *float32
	Course *float32
	Speed *float32
	Cpa *float32
	Tcpa *float32
	UtcOfFix *float32
	Name string
}
func DecodeTrackedTargetData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TrackedTargetData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-TargetId: %w", err)
	} else {
		val.TargetId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-TrackStatus: %w", err)
	} else {
		val.TrackStatus = TrackingConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-ReportedTarget: %w", err)
	} else {
		val.ReportedTarget = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-TargetAcquisition: %w", err)
	} else {
		val.TargetAcquisition = TargetAcquisitionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-BearingReference: %w", err)
	} else {
		val.BearingReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Bearing: %w", err)
	} else {
		val.Bearing = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Distance: %w", err)
	} else {
		val.Distance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Course: %w", err)
	} else {
		val.Course = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Speed: %w", err)
	} else {
		val.Speed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Cpa: %w", err)
	} else {
		val.Cpa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Tcpa: %w", err)
	} else {
		val.Tcpa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-UtcOfFix: %w", err)
	} else {
		val.UtcOfFix = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(1784); err != nil {
		return nil, fmt.Errorf("parse failed for TrackedTargetData-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ElevatorCarStatus struct {
	Info MessageInfo
	Sid *uint8
	ElevatorCarId *uint8
	ElevatorCarUsage *uint8
	SmokeSensorStatus *uint8
	LimitSwitchSensorStatus *uint8
	ProximitySwitchSensorStatus *uint8
	InertialMeasurementUnitImuSensorStatus *uint8
	ElevatorLoadLimitStatus *uint8
	ElevatorLoadBalanceStatus *uint8
	ElevatorLoadSensor1Status *uint8
	ElevatorLoadSensor2Status *uint8
	ElevatorLoadSensor3Status *uint8
	ElevatorLoadSensor4Status *uint8
	ElevatorCarMotionStatus *uint8
	ElevatorCarDoorStatus *uint8
	ElevatorCarEmergencyButtonStatus *uint8
	ElevatorCarBuzzerStatus *uint8
	OpenDoorButtonStatus *uint8
	CloseDoorButtonStatus *uint8
	CurrentDeck *uint8
	DestinationDeck *uint8
	TotalNumberOfDecks *uint8
	WeightOfLoadCell1 *uint16
	WeightOfLoadCell2 *uint16
	WeightOfLoadCell3 *uint16
	WeightOfLoadCell4 *uint16
	SpeedOfElevatorCar *float32
	ElevatorBrakeStatus *uint8
	ElevatorMotorRotationControlStatus *uint8
}
func DecodeElevatorCarStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElevatorCarStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarId: %w", err)
	} else {
		val.ElevatorCarId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarUsage: %w", err)
	} else {
		val.ElevatorCarUsage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-SmokeSensorStatus: %w", err)
	} else {
		val.SmokeSensorStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-LimitSwitchSensorStatus: %w", err)
	} else {
		val.LimitSwitchSensorStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ProximitySwitchSensorStatus: %w", err)
	} else {
		val.ProximitySwitchSensorStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-InertialMeasurementUnitImuSensorStatus: %w", err)
	} else {
		val.InertialMeasurementUnitImuSensorStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadLimitStatus: %w", err)
	} else {
		val.ElevatorLoadLimitStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadBalanceStatus: %w", err)
	} else {
		val.ElevatorLoadBalanceStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadSensor1Status: %w", err)
	} else {
		val.ElevatorLoadSensor1Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadSensor2Status: %w", err)
	} else {
		val.ElevatorLoadSensor2Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadSensor3Status: %w", err)
	} else {
		val.ElevatorLoadSensor3Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorLoadSensor4Status: %w", err)
	} else {
		val.ElevatorLoadSensor4Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarMotionStatus: %w", err)
	} else {
		val.ElevatorCarMotionStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarDoorStatus: %w", err)
	} else {
		val.ElevatorCarDoorStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarEmergencyButtonStatus: %w", err)
	} else {
		val.ElevatorCarEmergencyButtonStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorCarBuzzerStatus: %w", err)
	} else {
		val.ElevatorCarBuzzerStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-OpenDoorButtonStatus: %w", err)
	} else {
		val.OpenDoorButtonStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-CloseDoorButtonStatus: %w", err)
	} else {
		val.CloseDoorButtonStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-CurrentDeck: %w", err)
	} else {
		val.CurrentDeck = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-DestinationDeck: %w", err)
	} else {
		val.DestinationDeck = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-TotalNumberOfDecks: %w", err)
	} else {
		val.TotalNumberOfDecks = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-WeightOfLoadCell1: %w", err)
	} else {
		val.WeightOfLoadCell1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-WeightOfLoadCell2: %w", err)
	} else {
		val.WeightOfLoadCell2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-WeightOfLoadCell3: %w", err)
	} else {
		val.WeightOfLoadCell3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-WeightOfLoadCell4: %w", err)
	} else {
		val.WeightOfLoadCell4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-SpeedOfElevatorCar: %w", err)
	} else {
		val.SpeedOfElevatorCar = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorBrakeStatus: %w", err)
	} else {
		val.ElevatorBrakeStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorCarStatus-ElevatorMotorRotationControlStatus: %w", err)
	} else {
		val.ElevatorMotorRotationControlStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ElevatorMotorControl struct {
	Info MessageInfo
	Sid *uint8
	ElevatorCarId *uint8
	ElevatorCarUsage *uint8
	MotorAccelerationDecelerationProfileSelection *uint8
	MotorRotationalControlStatus *uint8
}
func DecodeElevatorMotorControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElevatorMotorControl
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorMotorControl-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorMotorControl-ElevatorCarId: %w", err)
	} else {
		val.ElevatorCarId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorMotorControl-ElevatorCarUsage: %w", err)
	} else {
		val.ElevatorCarUsage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorMotorControl-MotorAccelerationDecelerationProfileSelection: %w", err)
	} else {
		val.MotorAccelerationDecelerationProfileSelection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorMotorControl-MotorRotationalControlStatus: %w", err)
	} else {
		val.MotorRotationalControlStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(34)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ElevatorDeckPushButton struct {
	Info MessageInfo
	Sid *uint8
	ElevatorCallButtonId *uint8
	DeckButtonId *uint8
	ElevatorCarUsage *uint8
	ElevatorCarButtonSelection *uint8
}
func DecodeElevatorDeckPushButton(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ElevatorDeckPushButton
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorDeckPushButton-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorDeckPushButton-ElevatorCallButtonId: %w", err)
	} else {
		val.ElevatorCallButtonId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorDeckPushButton-DeckButtonId: %w", err)
	} else {
		val.DeckButtonId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorDeckPushButton-ElevatorCarUsage: %w", err)
	} else {
		val.ElevatorCarUsage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ElevatorDeckPushButton-ElevatorCarButtonSelection: %w", err)
	} else {
		val.ElevatorCarButtonSelection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type WindlassControlStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassDirectionControl WindlassDirectionConst
	AnchorDockingControl OffOnConst
	SpeedControlType SpeedTypeConst
	SpeedControl interface{}
	PowerEnable OffOnConst
	MechanicalLock OffOnConst
	DeckAndAnchorWash OffOnConst
	AnchorLight OffOnConst
	CommandTimeout *float32
	WindlassControlEvents WindlassControlConst
}
func DecodeWindlassControlStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val WindlassControlStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassDirectionControl: %w", err)
	} else {
		val.WindlassDirectionControl = WindlassDirectionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorDockingControl: %w", err)
	} else {
		val.AnchorDockingControl = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControlType: %w", err)
	} else {
		val.SpeedControlType = SpeedTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControl: %w", err)
	} else {
		val.SpeedControl = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-PowerEnable: %w", err)
	} else {
		val.PowerEnable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-MechanicalLock: %w", err)
	} else {
		val.MechanicalLock = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-DeckAndAnchorWash: %w", err)
	} else {
		val.DeckAndAnchorWash = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorLight: %w", err)
	} else {
		val.AnchorLight = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.005); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-CommandTimeout: %w", err)
	} else {
		val.CommandTimeout = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassControlEvents: %w", err)
	} else {
		val.WindlassControlEvents = WindlassControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(12)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AnchorWindlassOperatingStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassDirectionControl WindlassDirectionConst
	WindlassMotionStatus WindlassMotionConst
	RodeTypeStatus RodeTypeConst
	RodeCounterValue *float32
	WindlassLineSpeed *float32
	AnchorDockingStatus DockingStatusConst
	WindlassOperatingEvents WindlassOperationConst
}
func DecodeAnchorWindlassOperatingStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AnchorWindlassOperatingStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassDirectionControl: %w", err)
	} else {
		val.WindlassDirectionControl = WindlassDirectionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassMotionStatus: %w", err)
	} else {
		val.WindlassMotionStatus = WindlassMotionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeTypeStatus: %w", err)
	} else {
		val.RodeTypeStatus = RodeTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeCounterValue: %w", err)
	} else {
		val.RodeCounterValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassLineSpeed: %w", err)
	} else {
		val.WindlassLineSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-AnchorDockingStatus: %w", err)
	} else {
		val.AnchorDockingStatus = DockingStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassOperatingEvents: %w", err)
	} else {
		val.WindlassOperatingEvents = WindlassOperationConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AnchorWindlassMonitoringStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassMonitoringEvents WindlassMonitoringConst
	ControllerVoltage *float32
	MotorCurrent *uint8
	TotalMotorTime *float32
}
func DecodeAnchorWindlassMonitoringStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AnchorWindlassMonitoringStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassMonitoringEvents: %w", err)
	} else {
		val.WindlassMonitoringEvents = WindlassMonitoringConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-ControllerVoltage: %w", err)
	} else {
		val.ControllerVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-MotorCurrent: %w", err)
	} else {
		val.MotorCurrent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-TotalMotorTime: %w", err)
	} else {
		val.TotalMotorTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LinearActuatorControlStatus struct {
	Info MessageInfo
	ActuatorIdentifier *uint8
	CommandedDevicePosition *uint8
	DevicePosition *uint8
	MaximumDeviceTravel *uint16
	DirectionOfTravel *uint8
}
func DecodeLinearActuatorControlStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LinearActuatorControlStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LinearActuatorControlStatus-ActuatorIdentifier: %w", err)
	} else {
		val.ActuatorIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LinearActuatorControlStatus-CommandedDevicePosition: %w", err)
	} else {
		val.CommandedDevicePosition = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LinearActuatorControlStatus-DevicePosition: %w", err)
	} else {
		val.DevicePosition = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LinearActuatorControlStatus-MaximumDeviceTravel: %w", err)
	} else {
		val.MaximumDeviceTravel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LinearActuatorControlStatus-DirectionOfTravel: %w", err)
	} else {
		val.DirectionOfTravel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type PositionRapidUpdate struct {
	Info MessageInfo
	Latitude *float32
	Longitude *float32
}
func DecodePositionRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val PositionRapidUpdate
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CogSogRapidUpdate struct {
	Info MessageInfo
	Sid *uint8
	CogReference DirectionReferenceConst
	Cog *float32
	Sog *float32
}
func DecodeCogSogRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val CogSogRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-CogReference: %w", err)
	} else {
		val.CogReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type PositionDeltaRapidUpdate struct {
	Info MessageInfo
	Sid *uint8
	TimeDelta *uint16
	LatitudeDelta *int16
	LongitudeDelta *int16
}
func DecodePositionDeltaRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val PositionDeltaRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for PositionDeltaRapidUpdate-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for PositionDeltaRapidUpdate-TimeDelta: %w", err)
	} else {
		val.TimeDelta = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for PositionDeltaRapidUpdate-LatitudeDelta: %w", err)
	} else {
		val.LatitudeDelta = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for PositionDeltaRapidUpdate-LongitudeDelta: %w", err)
	} else {
		val.LongitudeDelta = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AltitudeDeltaRapidUpdate struct {
	Info MessageInfo
	Sid *uint8
	TimeDelta *int16
	GnssQuality *uint8
	Direction *uint8
	Cog *float32
	AltitudeDelta *int16
}
func DecodeAltitudeDeltaRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AltitudeDeltaRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-TimeDelta: %w", err)
	} else {
		val.TimeDelta = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-GnssQuality: %w", err)
	} else {
		val.GnssQuality = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-Direction: %w", err)
	} else {
		val.Direction = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AltitudeDeltaRapidUpdate-AltitudeDelta: %w", err)
	} else {
		val.AltitudeDelta = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssPositionData struct {
	Info MessageInfo
	Sid *uint8
	Date *uint16
	Time *float32
	Latitude *float32
	Longitude *float32
	Altitude *float32
	GnssType GnsConst
	Method GnsMethodConst
	Integrity GnsIntegrityConst
	NumberOfSvs *uint8
	Hdop *float32
	Pdop *float32
	GeoidalSeparation *float32
	ReferenceStations *uint8
	Repeating1 []GnssPositionDataRepeating1
}
type GnssPositionDataRepeating1 struct {
	ReferenceStationType GnsConst
	ReferenceStationId *uint16
	AgeOfDgnssCorrections *float32
}
func DecodeGnssPositionData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssPositionData
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Date: %w", err)
	} else {
		val.Date = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Time: %w", err)
	} else {
		val.Time = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(64, 1e-16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(64, 1e-16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(64, 1e-06); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Altitude: %w", err)
	} else {
		val.Altitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-GnssType: %w", err)
	} else {
		val.GnssType = GnsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Method: %w", err)
	} else {
		val.Method = GnsMethodConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Integrity: %w", err)
	} else {
		val.Integrity = GnsIntegrityConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-NumberOfSvs: %w", err)
	} else {
		val.NumberOfSvs = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Hdop: %w", err)
	} else {
		val.Hdop = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Pdop: %w", err)
	} else {
		val.Pdop = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-GeoidalSeparation: %w", err)
	} else {
		val.GeoidalSeparation = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStations: %w", err)
	} else {
		val.ReferenceStations = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]GnssPositionDataRepeating1, 0)
	i := 0 
	for {
		var rep GnssPositionDataRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationType: %w", err)
		} else {
			rep.ReferenceStationType = GnsConst(v)
		}
		if v, err := stream.readUInt16(12); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationId: %w", err)
		} else {
			rep.ReferenceStationId = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-AgeOfDgnssCorrections: %w", err)
		} else {
			rep.AgeOfDgnssCorrections = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type TimeDate struct {
	Info MessageInfo
	Date *uint16
	Time *float32
	LocalOffset *float32
}
func DecodeTimeDate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TimeDate
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-Date: %w", err)
	} else {
		val.Date = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-Time: %w", err)
	} else {
		val.Time = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 60); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-LocalOffset: %w", err)
	} else {
		val.LocalOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassAPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *float32
	CommunicationState interface{}
	AisTransceiverInformation AisTransceiverConst
	Heading *float32
	RateOfTurn *float32
	NavStatus NavStatusConst
	SpecialManeuverIndicator AisSpecialManeuverConst
	SequenceId *uint8
}
func DecodeAisClassAPositionReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassAPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Heading: %w", err)
	} else {
		val.Heading = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 3.125e-05); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RateOfTurn: %w", err)
	} else {
		val.RateOfTurn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-NavStatus: %w", err)
	} else {
		val.NavStatus = NavStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SpecialManeuverIndicator: %w", err)
	} else {
		val.SpecialManeuverIndicator = AisSpecialManeuverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SequenceId: %w", err)
	} else {
		val.SequenceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *float32
	CommunicationState interface{}
	AisTransceiverInformation AisTransceiverConst
	Heading *float32
	UnitType AisTypeConst
	IntegratedDisplay YesNoConst
	Dsc YesNoConst
	Band AisBandConst
	CanHandleMsg22 YesNoConst
	AisMode AisModeConst
	AisCommunicationState AisCommunicationStateConst
}
func DecodeAisClassBPositionReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassBPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Heading: %w", err)
	} else {
		val.Heading = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UnitType: %w", err)
	} else {
		val.UnitType = AisTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-IntegratedDisplay: %w", err)
	} else {
		val.IntegratedDisplay = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Dsc: %w", err)
	} else {
		val.Dsc = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Band: %w", err)
	} else {
		val.Band = AisBandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CanHandleMsg22: %w", err)
	} else {
		val.CanHandleMsg22 = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisMode: %w", err)
	} else {
		val.AisMode = AisModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisCommunicationState: %w", err)
	} else {
		val.AisCommunicationState = AisCommunicationStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(15)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisClassBExtendedPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *float32
	TypeOfShip ShipTypeConst
	TrueHeading *float32
	GnssType PositionFixDeviceConst
	Length *float32
	Beam *float32
	PositionReferenceFromStarboard *float32
	PositionReferenceFromBow *float32
	Name string
	Dte AvailableConst
	AisMode AisModeConst
	AisTransceiverInformation AisTransceiverConst
}
func DecodeAisClassBExtendedPositionReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassBExtendedPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-TrueHeading: %w", err)
	} else {
		val.TrueHeading = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-GnssType: %w", err)
	} else {
		val.GnssType = PositionFixDeviceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Beam: %w", err)
	} else {
		val.Beam = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-Dte: %w", err)
	} else {
		val.Dte = AvailableConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-AisMode: %w", err)
	} else {
		val.AisMode = AisModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBExtendedPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisAidsToNavigationAtonReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	LengthDiameter *float32
	BeamDiameter *float32
	PositionReferenceFromStarboardEdge *float32
	PositionReferenceFromTrueNorthFacingEdge *float32
	AtonType AtonTypeConst
	OffPositionIndicator YesNoConst
	VirtualAtonFlag YesNoConst
	AssignedModeFlag AisAssignedModeConst
	PositionFixingDeviceType PositionFixDeviceConst
	AtonStatus interface{}
	AisTransceiverInformation AisTransceiverConst
	AtonName string
}
func DecodeAisAidsToNavigationAtonReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisAidsToNavigationAtonReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-LengthDiameter: %w", err)
	} else {
		val.LengthDiameter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-BeamDiameter: %w", err)
	} else {
		val.BeamDiameter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromStarboardEdge: %w", err)
	} else {
		val.PositionReferenceFromStarboardEdge = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromTrueNorthFacingEdge: %w", err)
	} else {
		val.PositionReferenceFromTrueNorthFacingEdge = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonType: %w", err)
	} else {
		val.AtonType = AtonTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-OffPositionIndicator: %w", err)
	} else {
		val.OffPositionIndicator = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-VirtualAtonFlag: %w", err)
	} else {
		val.VirtualAtonFlag = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AssignedModeFlag: %w", err)
	} else {
		val.AssignedModeFlag = AisAssignedModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionFixingDeviceType: %w", err)
	} else {
		val.PositionFixingDeviceType = PositionFixDeviceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonStatus: %w", err)
	} else {
		val.AtonStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonName: %w", err)
	} else {
		val.AtonName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Datum struct {
	Info MessageInfo
	LocalDatum string
	DeltaLatitude *float32
	DeltaLongitude *float32
	DeltaAltitude *float32
	ReferenceDatum string
}
func DecodeDatum(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Datum
	val.Info = Info
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-LocalDatum: %w", err)
	} else {
		val.LocalDatum = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaLatitude: %w", err)
	} else {
		val.DeltaLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaLongitude: %w", err)
	} else {
		val.DeltaLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaAltitude: %w", err)
	} else {
		val.DeltaAltitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-ReferenceDatum: %w", err)
	} else {
		val.ReferenceDatum = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UserDatum struct {
	Info MessageInfo
	DeltaX *float32
	DeltaY *float32
	DeltaZ *float32
	RotationInX *float32
	RotationInY *float32
	RotationInZ *float32
	Scale *float32
	EllipsoidSemiMajorAxis *float32
	EllipsoidFlatteningInverse *float32
	DatumName string
}
func DecodeUserDatum(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val UserDatum
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaX: %w", err)
	} else {
		val.DeltaX = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaY: %w", err)
	} else {
		val.DeltaY = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaZ: %w", err)
	} else {
		val.DeltaZ = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInX: %w", err)
	} else {
		val.RotationInX = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInY: %w", err)
	} else {
		val.RotationInY = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInZ: %w", err)
	} else {
		val.RotationInZ = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-Scale: %w", err)
	} else {
		val.Scale = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidSemiMajorAxis: %w", err)
	} else {
		val.EllipsoidSemiMajorAxis = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidFlatteningInverse: %w", err)
	} else {
		val.EllipsoidFlatteningInverse = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DatumName: %w", err)
	} else {
		val.DatumName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CrossTrackError struct {
	Info MessageInfo
	Sid *uint8
	XteMode ResidualModeConst
	NavigationTerminated YesNoConst
	Xte *float32
}
func DecodeCrossTrackError(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val CrossTrackError
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-XteMode: %w", err)
	} else {
		val.XteMode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-NavigationTerminated: %w", err)
	} else {
		val.NavigationTerminated = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-Xte: %w", err)
	} else {
		val.Xte = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NavigationData struct {
	Info MessageInfo
	Sid *uint8
	DistanceToWaypoint *float32
	CourseBearingReference DirectionReferenceConst
	PerpendicularCrossed YesNoConst
	ArrivalCircleEntered YesNoConst
	CalculationType BearingModeConst
	EtaTime *float32
	EtaDate *uint16
	BearingOriginToDestinationWaypoint *float32
	BearingPositionToDestinationWaypoint *float32
	OriginWaypointNumber *uint32
	DestinationWaypointNumber *uint32
	DestinationLatitude *float32
	DestinationLongitude *float32
	WaypointClosingVelocity *float32
}
func DecodeNavigationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavigationData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DistanceToWaypoint: %w", err)
	} else {
		val.DistanceToWaypoint = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-CourseBearingReference: %w", err)
	} else {
		val.CourseBearingReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-PerpendicularCrossed: %w", err)
	} else {
		val.PerpendicularCrossed = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-ArrivalCircleEntered: %w", err)
	} else {
		val.ArrivalCircleEntered = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-CalculationType: %w", err)
	} else {
		val.CalculationType = BearingModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-EtaTime: %w", err)
	} else {
		val.EtaTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-EtaDate: %w", err)
	} else {
		val.EtaDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-BearingOriginToDestinationWaypoint: %w", err)
	} else {
		val.BearingOriginToDestinationWaypoint = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-BearingPositionToDestinationWaypoint: %w", err)
	} else {
		val.BearingPositionToDestinationWaypoint = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-OriginWaypointNumber: %w", err)
	} else {
		val.OriginWaypointNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationWaypointNumber: %w", err)
	} else {
		val.DestinationWaypointNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationLatitude: %w", err)
	} else {
		val.DestinationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationLongitude: %w", err)
	} else {
		val.DestinationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-WaypointClosingVelocity: %w", err)
	} else {
		val.WaypointClosingVelocity = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type NavigationRouteWpInformation struct {
	Info MessageInfo
	StartRps *uint16
	Nitems *uint16
	DatabaseId *uint16
	RouteId *uint16
	NavigationDirectionInRoute DirectionConst
	SupplementaryRouteWpDataAvailable OffOnConst
	RouteName string
	Repeating1 []NavigationRouteWpInformationRepeating1
}
type NavigationRouteWpInformationRepeating1 struct {
	WpId *uint16
	WpName string
	WpLatitude *float32
	WpLongitude *float32
}
func DecodeNavigationRouteWpInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavigationRouteWpInformation
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-StartRps: %w", err)
	} else {
		val.StartRps = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-NavigationDirectionInRoute: %w", err)
	} else {
		val.NavigationDirectionInRoute = DirectionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-SupplementaryRouteWpDataAvailable: %w", err)
	} else {
		val.SupplementaryRouteWpDataAvailable = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteName: %w", err)
	} else {
		val.RouteName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NavigationRouteWpInformationRepeating1, 0)
	i := 0 
	for {
		var rep NavigationRouteWpInformationRepeating1
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLatitude: %w", err)
		} else {
			rep.WpLatitude = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLongitude: %w", err)
		} else {
			rep.WpLongitude = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type SetDriftRapidUpdate struct {
	Info MessageInfo
	Sid *uint8
	SetReference DirectionReferenceConst
	Set *float32
	Drift *float32
}
func DecodeSetDriftRapidUpdate(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SetDriftRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetDriftRapidUpdate-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SetDriftRapidUpdate-SetReference: %w", err)
	} else {
		val.SetReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SetDriftRapidUpdate-Set: %w", err)
	} else {
		val.Set = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for SetDriftRapidUpdate-Drift: %w", err)
	} else {
		val.Drift = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NavigationRouteTimeToFromMark struct {
	Info MessageInfo
	Sid *uint8
	TimeToMark *float32
	MarkType MarkTypeConst
	MarkId *uint32
}
func DecodeNavigationRouteTimeToFromMark(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavigationRouteTimeToFromMark
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteTimeToFromMark-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteTimeToFromMark-TimeToMark: %w", err)
	} else {
		val.TimeToMark = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteTimeToFromMark-MarkType: %w", err)
	} else {
		val.MarkType = MarkTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteTimeToFromMark-MarkId: %w", err)
	} else {
		val.MarkId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BearingAndDistanceBetweenTwoMarks struct {
	Info MessageInfo
	Sid *uint8
	BearingReference DirectionReferenceConst
	CalculationType BearingModeConst
	BearingOriginToDestination *float32
	Distance *float32
	OriginMarkType MarkTypeConst
	DestinationMarkType MarkTypeConst
	OriginMarkId *uint32
	DestinationMarkId *uint32
}
func DecodeBearingAndDistanceBetweenTwoMarks(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BearingAndDistanceBetweenTwoMarks
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-BearingReference: %w", err)
	} else {
		val.BearingReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-CalculationType: %w", err)
	} else {
		val.CalculationType = BearingModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-BearingOriginToDestination: %w", err)
	} else {
		val.BearingOriginToDestination = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-Distance: %w", err)
	} else {
		val.Distance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-OriginMarkType: %w", err)
	} else {
		val.OriginMarkType = MarkTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-DestinationMarkType: %w", err)
	} else {
		val.DestinationMarkType = MarkTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-OriginMarkId: %w", err)
	} else {
		val.OriginMarkId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for BearingAndDistanceBetweenTwoMarks-DestinationMarkId: %w", err)
	} else {
		val.DestinationMarkId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssControlStatus struct {
	Info MessageInfo
	SvElevationMask *uint16
	PdopMask *float32
	PdopSwitch *float32
	SnrMask *float32
	GnssModeDesired GnssModeConst
	DgnssModeDesired DgnssModeConst
	PositionVelocityFilter *uint8
	MaxCorrectionAge *uint16
	AntennaAltitudeFor2dMode *float32
	UseAntennaAltitudeFor2dMode YesNoConst
}
func DecodeGnssControlStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssControlStatus
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-SvElevationMask: %w", err)
	} else {
		val.SvElevationMask = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-PdopMask: %w", err)
	} else {
		val.PdopMask = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-PdopSwitch: %w", err)
	} else {
		val.PdopSwitch = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-SnrMask: %w", err)
	} else {
		val.SnrMask = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-GnssModeDesired: %w", err)
	} else {
		val.GnssModeDesired = GnssModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-DgnssModeDesired: %w", err)
	} else {
		val.DgnssModeDesired = DgnssModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-PositionVelocityFilter: %w", err)
	} else {
		val.PositionVelocityFilter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-MaxCorrectionAge: %w", err)
	} else {
		val.MaxCorrectionAge = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-AntennaAltitudeFor2dMode: %w", err)
	} else {
		val.AntennaAltitudeFor2dMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssControlStatus-UseAntennaAltitudeFor2dMode: %w", err)
	} else {
		val.UseAntennaAltitudeFor2dMode = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GnssDops struct {
	Info MessageInfo
	Sid *uint8
	DesiredMode GnssModeConst
	ActualMode GnssModeConst
	Hdop *float32
	Vdop *float32
	Tdop *float32
}
func DecodeGnssDops(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssDops
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-DesiredMode: %w", err)
	} else {
		val.DesiredMode = GnssModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-ActualMode: %w", err)
	} else {
		val.ActualMode = GnssModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Hdop: %w", err)
	} else {
		val.Hdop = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Vdop: %w", err)
	} else {
		val.Vdop = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Tdop: %w", err)
	} else {
		val.Tdop = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssSatsInView struct {
	Info MessageInfo
	Sid *uint8
	RangeResidualMode RangeResidualModeConst
	SatsInView *uint8
	Repeating1 []GnssSatsInViewRepeating1
}
type GnssSatsInViewRepeating1 struct {
	Prn *uint8
	Elevation *float32
	Azimuth *float32
	Snr *float32
	RangeResiduals *int32
	Status SatelliteStatusConst
}
func DecodeGnssSatsInView(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssSatsInView
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResidualMode: %w", err)
	} else {
		val.RangeResidualMode = RangeResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-SatsInView: %w", err)
	} else {
		val.SatsInView = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]GnssSatsInViewRepeating1, 0)
	i := 0 
	for {
		var rep GnssSatsInViewRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Prn: %w", err)
		} else {
			rep.Prn = v
		}
		if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Elevation: %w", err)
		} else {
			rep.Elevation = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Azimuth: %w", err)
		} else {
			rep.Azimuth = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Snr: %w", err)
		} else {
			rep.Snr = v
		}
		if v, err := stream.readInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResiduals: %w", err)
		} else {
			rep.RangeResiduals = v
		}
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Status: %w", err)
		} else {
			rep.Status = SatelliteStatusConst(v)
		}
		stream.skipBits(4)
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type GpsAlmanacData struct {
	Info MessageInfo
	Prn *uint8
	GpsWeekNumber *uint16
	SvHealthBits interface{}
	Eccentricity *float32
	AlmanacReferenceTime *float32
	InclinationAngle *float32
	RateOfRightAscension *float32
	RootOfSemiMajorAxis *float32
	ArgumentOfPerigee *float32
	LongitudeOfAscensionNode *float32
	MeanAnomaly *float32
	ClockParameter1 *float32
	ClockParameter2 *float32
}
func DecodeGpsAlmanacData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GpsAlmanacData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-Prn: %w", err)
	} else {
		val.Prn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-GpsWeekNumber: %w", err)
	} else {
		val.GpsWeekNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-SvHealthBits: %w", err)
	} else {
		val.SvHealthBits = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 4.76837e-07); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-Eccentricity: %w", err)
	} else {
		val.Eccentricity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 4096); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-AlmanacReferenceTime: %w", err)
	} else {
		val.AlmanacReferenceTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 1.90735e-06); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-InclinationAngle: %w", err)
	} else {
		val.InclinationAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 3.63798e-12); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-RateOfRightAscension: %w", err)
	} else {
		val.RateOfRightAscension = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.000488281); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-RootOfSemiMajorAxis: %w", err)
	} else {
		val.RootOfSemiMajorAxis = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(24, 1.19209e-07); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-ArgumentOfPerigee: %w", err)
	} else {
		val.ArgumentOfPerigee = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(24, 1.19209e-07); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-LongitudeOfAscensionNode: %w", err)
	} else {
		val.LongitudeOfAscensionNode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(24, 1.19209e-07); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-MeanAnomaly: %w", err)
	} else {
		val.MeanAnomaly = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(11, 9.53674e-07); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-ClockParameter1: %w", err)
	} else {
		val.ClockParameter1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(11, 3.63798e-12); err != nil {
		return nil, fmt.Errorf("parse failed for GpsAlmanacData-ClockParameter2: %w", err)
	} else {
		val.ClockParameter2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GnssPseudorangeNoiseStatistics struct {
	Info MessageInfo
	Sid *uint8
	RmsOfPositionUncertainty *uint16
	StdOfMajorAxis *uint8
	StdOfMinorAxis *uint8
	OrientationOfMajorAxis *uint8
	StdOfLatError *uint8
	StdOfLonError *uint8
	StdOfAltError *uint8
}
func DecodeGnssPseudorangeNoiseStatistics(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssPseudorangeNoiseStatistics
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-RmsOfPositionUncertainty: %w", err)
	} else {
		val.RmsOfPositionUncertainty = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-StdOfMajorAxis: %w", err)
	} else {
		val.StdOfMajorAxis = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-StdOfMinorAxis: %w", err)
	} else {
		val.StdOfMinorAxis = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-OrientationOfMajorAxis: %w", err)
	} else {
		val.OrientationOfMajorAxis = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-StdOfLatError: %w", err)
	} else {
		val.StdOfLatError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-StdOfLonError: %w", err)
	} else {
		val.StdOfLonError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeNoiseStatistics-StdOfAltError: %w", err)
	} else {
		val.StdOfAltError = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssRaimOutput struct {
	Info MessageInfo
	Sid *uint8
	IntegrityFlag *uint8
	LatitudeExpectedError *uint8
	LongitudeExpectedError *uint8
	AltitudeExpectedError *uint8
	SvIdOfMostLikelyFailedSat *uint8
	ProbabilityOfMissedDetection *uint8
	EstimateOfPseudorangeBias *uint8
	StdDeviationOfBias *uint8
}
func DecodeGnssRaimOutput(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssRaimOutput
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-IntegrityFlag: %w", err)
	} else {
		val.IntegrityFlag = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-LatitudeExpectedError: %w", err)
	} else {
		val.LatitudeExpectedError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-LongitudeExpectedError: %w", err)
	} else {
		val.LongitudeExpectedError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-AltitudeExpectedError: %w", err)
	} else {
		val.AltitudeExpectedError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-SvIdOfMostLikelyFailedSat: %w", err)
	} else {
		val.SvIdOfMostLikelyFailedSat = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-ProbabilityOfMissedDetection: %w", err)
	} else {
		val.ProbabilityOfMissedDetection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-EstimateOfPseudorangeBias: %w", err)
	} else {
		val.EstimateOfPseudorangeBias = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimOutput-StdDeviationOfBias: %w", err)
	} else {
		val.StdDeviationOfBias = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssRaimSettings struct {
	Info MessageInfo
	RadialPositionErrorMaximumThreshold *uint8
	ProbabilityOfFalseAlarm *uint8
	ProbabilityOfMissedDetection *uint8
	PseudorangeResidualFilteringTimeConstant *uint8
}
func DecodeGnssRaimSettings(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssRaimSettings
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimSettings-RadialPositionErrorMaximumThreshold: %w", err)
	} else {
		val.RadialPositionErrorMaximumThreshold = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimSettings-ProbabilityOfFalseAlarm: %w", err)
	} else {
		val.ProbabilityOfFalseAlarm = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimSettings-ProbabilityOfMissedDetection: %w", err)
	} else {
		val.ProbabilityOfMissedDetection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssRaimSettings-PseudorangeResidualFilteringTimeConstant: %w", err)
	} else {
		val.PseudorangeResidualFilteringTimeConstant = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GnssPseudorangeErrorStatistics struct {
	Info MessageInfo
	Sid *uint8
	RmsStdDevOfRangeInputs *uint16
	StdDevOfMajorErrorEllipse *uint8
	StdDevOfMinorErrorEllipse *uint8
	OrientationOfErrorEllipse *uint8
	StdDevLatError *uint8
	StdDevLonError *uint8
	StdDevAltError *uint8
}
func DecodeGnssPseudorangeErrorStatistics(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssPseudorangeErrorStatistics
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-RmsStdDevOfRangeInputs: %w", err)
	} else {
		val.RmsStdDevOfRangeInputs = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevOfMajorErrorEllipse: %w", err)
	} else {
		val.StdDevOfMajorErrorEllipse = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevOfMinorErrorEllipse: %w", err)
	} else {
		val.StdDevOfMinorErrorEllipse = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-OrientationOfErrorEllipse: %w", err)
	} else {
		val.OrientationOfErrorEllipse = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevLatError: %w", err)
	} else {
		val.StdDevLatError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevLonError: %w", err)
	} else {
		val.StdDevLonError = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevAltError: %w", err)
	} else {
		val.StdDevAltError = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type DgnssCorrections struct {
	Info MessageInfo
	Sid *uint8
	ReferenceStationId *uint16
	ReferenceStationType *uint16
	TimeOfCorrections *uint8
	StationHealth *uint8
	SatelliteId *uint8
	Prc *uint8
	Rrc *uint8
	Udre *uint8
	Iod *uint8
}
func DecodeDgnssCorrections(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DgnssCorrections
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-ReferenceStationId: %w", err)
	} else {
		val.ReferenceStationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-ReferenceStationType: %w", err)
	} else {
		val.ReferenceStationType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-TimeOfCorrections: %w", err)
	} else {
		val.TimeOfCorrections = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-StationHealth: %w", err)
	} else {
		val.StationHealth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-SatelliteId: %w", err)
	} else {
		val.SatelliteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-Prc: %w", err)
	} else {
		val.Prc = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-Rrc: %w", err)
	} else {
		val.Rrc = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-Udre: %w", err)
	} else {
		val.Udre = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DgnssCorrections-Iod: %w", err)
	} else {
		val.Iod = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssDifferentialCorrectionReceiverInterface struct {
	Info MessageInfo
	Channel *uint8
	Frequency *uint8
	SerialInterfaceBitRate *uint8
	SerialInterfaceDetectionMode *uint8
	DifferentialSource *uint8
	DifferentialOperationMode *uint8
}
func DecodeGnssDifferentialCorrectionReceiverInterface(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssDifferentialCorrectionReceiverInterface
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-Channel: %w", err)
	} else {
		val.Channel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-Frequency: %w", err)
	} else {
		val.Frequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-SerialInterfaceBitRate: %w", err)
	} else {
		val.SerialInterfaceBitRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-SerialInterfaceDetectionMode: %w", err)
	} else {
		val.SerialInterfaceDetectionMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-DifferentialSource: %w", err)
	} else {
		val.DifferentialSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-DifferentialOperationMode: %w", err)
	} else {
		val.DifferentialOperationMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssDifferentialCorrectionReceiverSignal struct {
	Info MessageInfo
	Sid *uint8
	Channel *uint8
	SignalStrength *uint8
	SignalSnr *uint8
	Frequency *uint8
	StationType *uint8
	StationId *uint8
	DifferentialSignalBitRate *uint8
	DifferentialSignalDetectionMode *uint8
	UsedAsCorrectionSource *uint8
	DifferentialSource *uint8
	TimeSinceLastSatDifferentialSync *uint8
	SatelliteServiceIdNo *uint8
}
func DecodeGnssDifferentialCorrectionReceiverSignal(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GnssDifferentialCorrectionReceiverSignal
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Channel: %w", err)
	} else {
		val.Channel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SignalStrength: %w", err)
	} else {
		val.SignalStrength = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SignalSnr: %w", err)
	} else {
		val.SignalSnr = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Frequency: %w", err)
	} else {
		val.Frequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-StationType: %w", err)
	} else {
		val.StationType = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSignalBitRate: %w", err)
	} else {
		val.DifferentialSignalBitRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSignalDetectionMode: %w", err)
	} else {
		val.DifferentialSignalDetectionMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-UsedAsCorrectionSource: %w", err)
	} else {
		val.UsedAsCorrectionSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSource: %w", err)
	} else {
		val.DifferentialSource = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-TimeSinceLastSatDifferentialSync: %w", err)
	} else {
		val.TimeSinceLastSatDifferentialSync = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SatelliteServiceIdNo: %w", err)
	} else {
		val.SatelliteServiceIdNo = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GlonassAlmanacData struct {
	Info MessageInfo
	Prn *uint8
	Na *uint16
	Cna *uint8
	Hna *uint8
	EpsilonNa *uint16
	DeltatnaDot *uint8
	OmegaNa *uint16
	DeltaTna *uint32
	Tna *uint32
	LambdaNa *uint32
	DeltaIna *uint32
	TauCa *uint32
	TauNa *uint16
}
func DecodeGlonassAlmanacData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val GlonassAlmanacData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Prn: %w", err)
	} else {
		val.Prn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Na: %w", err)
	} else {
		val.Na = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Cna: %w", err)
	} else {
		val.Cna = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(5); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Hna: %w", err)
	} else {
		val.Hna = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-EpsilonNa: %w", err)
	} else {
		val.EpsilonNa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltatnaDot: %w", err)
	} else {
		val.DeltatnaDot = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-OmegaNa: %w", err)
	} else {
		val.OmegaNa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltaTna: %w", err)
	} else {
		val.DeltaTna = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Tna: %w", err)
	} else {
		val.Tna = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-LambdaNa: %w", err)
	} else {
		val.LambdaNa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltaIna: %w", err)
	} else {
		val.DeltaIna = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(28); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-TauCa: %w", err)
	} else {
		val.TauCa = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(12); err != nil {
		return nil, fmt.Errorf("parse failed for GlonassAlmanacData-TauNa: %w", err)
	} else {
		val.TauNa = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisDgnssBroadcastBinaryMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator *uint8
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	Longitude *float32
	Latitude *float32
	NumberOfBitsInBinaryDataField *uint16
	BinaryData interface{}
}
func DecodeAisDgnssBroadcastBinaryMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisDgnssBroadcastBinaryMessage
	val.Info = Info
		var binaryLength uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-NumberOfBitsInBinaryDataField: %w", err)
	} else {
		val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(binaryLength); err != nil {
		return nil, fmt.Errorf("parse failed for AisDgnssBroadcastBinaryMessage-BinaryData: %w", err)
	} else {
		val.BinaryData = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisUtcAndDateReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	PositionTime *float32
	CommunicationState interface{}
	AisTransceiverInformation AisTransceiverConst
	PositionDate *uint16
	GnssType PositionFixDeviceConst
}
func DecodeAisUtcAndDateReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisUtcAndDateReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-PositionTime: %w", err)
	} else {
		val.PositionTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-PositionDate: %w", err)
	} else {
		val.PositionDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcAndDateReport-GnssType: %w", err)
	} else {
		val.GnssType = PositionFixDeviceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisClassAStaticAndVoyageRelatedData struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	ImoNumber *uint32
	Callsign string
	Name string
	TypeOfShip ShipTypeConst
	Length *float32
	Beam *float32
	PositionReferenceFromStarboard *float32
	PositionReferenceFromBow *float32
	EtaDate *uint16
	EtaTime *float32
	Draft *float32
	Destination string
	AisVersionIndicator AisVersionConst
	GnssType PositionFixDeviceConst
	Dte AvailableConst
	AisTransceiverInformation AisTransceiverConst
}
func DecodeAisClassAStaticAndVoyageRelatedData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassAStaticAndVoyageRelatedData
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-ImoNumber: %w", err)
	} else {
		val.ImoNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Callsign: %w", err)
	} else {
		val.Callsign = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Beam: %w", err)
	} else {
		val.Beam = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaDate: %w", err)
	} else {
		val.EtaDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaTime: %w", err)
	} else {
		val.EtaTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Draft: %w", err)
	} else {
		val.Draft = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Destination: %w", err)
	} else {
		val.Destination = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisVersionIndicator: %w", err)
	} else {
		val.AisVersionIndicator = AisVersionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-GnssType: %w", err)
	} else {
		val.GnssType = PositionFixDeviceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Dte: %w", err)
	} else {
		val.Dte = AvailableConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisAddressedBinaryMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	SequenceNumber *uint8
	DestinationId *uint32
	RetransmitFlag *uint8
	NumberOfBitsInBinaryDataField *uint16
	BinaryData interface{}
}
func DecodeAisAddressedBinaryMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisAddressedBinaryMessage
	val.Info = Info
		var binaryLength uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SequenceNumber: %w", err)
	} else {
		val.SequenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-DestinationId: %w", err)
	} else {
		val.DestinationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RetransmitFlag: %w", err)
	} else {
		val.RetransmitFlag = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-NumberOfBitsInBinaryDataField: %w", err)
	} else {
		val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(binaryLength); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-BinaryData: %w", err)
	} else {
		val.BinaryData = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisAcknowledge struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	DestinationId1 *uint32
	SequenceNumberForId1 interface{}
	SequenceNumberForIdN interface{}
}
func DecodeAisAcknowledge(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisAcknowledge
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-DestinationId1: %w", err)
	} else {
		val.DestinationId1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForId1: %w", err)
	} else {
		val.SequenceNumberForId1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForIdN: %w", err)
	} else {
		val.SequenceNumberForIdN = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisBinaryBroadcastMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	NumberOfBitsInBinaryDataField *uint16
	BinaryData interface{}
}
func DecodeAisBinaryBroadcastMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisBinaryBroadcastMessage
	val.Info = Info
		var binaryLength uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-NumberOfBitsInBinaryDataField: %w", err)
	} else {
		val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(binaryLength); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-BinaryData: %w", err)
	} else {
		val.BinaryData = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisSarAircraftPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float32
	Latitude *float32
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *float32
	CommunicationState interface{}
	AisTransceiverInformation AisTransceiverConst
	Altitude *float32
	ReservedForRegionalApplications interface{}
	Dte AvailableConst
}
func DecodeAisSarAircraftPositionReport(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisSarAircraftPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Altitude: %w", err)
	} else {
		val.Altitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-ReservedForRegionalApplications: %w", err)
	} else {
		val.ReservedForRegionalApplications = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisSarAircraftPositionReport-Dte: %w", err)
	} else {
		val.Dte = AvailableConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(7)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type RadioFrequencyModePower struct {
	Info MessageInfo
	RxFrequency *float32
	TxFrequency *float32
	RadioChannel *uint8
	TxPower *uint8
	Mode *uint8
	ChannelBandwidth *uint8
}
func DecodeRadioFrequencyModePower(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RadioFrequencyModePower
	val.Info = Info
	if v, err := stream.readUnsignedResolution(32, 10); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-RxFrequency: %w", err)
	} else {
		val.RxFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 10); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-TxFrequency: %w", err)
	} else {
		val.TxFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-RadioChannel: %w", err)
	} else {
		val.RadioChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-TxPower: %w", err)
	} else {
		val.TxPower = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-Mode: %w", err)
	} else {
		val.Mode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RadioFrequencyModePower-ChannelBandwidth: %w", err)
	} else {
		val.ChannelBandwidth = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisUtcDateInquiry struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	DestinationId *uint32
}
func DecodeAisUtcDateInquiry(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisUtcDateInquiry
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcDateInquiry-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcDateInquiry-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcDateInquiry-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcDateInquiry-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisUtcDateInquiry-DestinationId: %w", err)
	} else {
		val.DestinationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisAddressedSafetyRelatedMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	SequenceNumber *uint8
	DestinationId *uint32
	RetransmitFlag *uint8
	SafetyRelatedText string
}
func DecodeAisAddressedSafetyRelatedMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisAddressedSafetyRelatedMessage
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-SequenceNumber: %w", err)
	} else {
		val.SequenceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-DestinationId: %w", err)
	} else {
		val.DestinationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-RetransmitFlag: %w", err)
	} else {
		val.RetransmitFlag = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(7)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readFixedString(936); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedSafetyRelatedMessage-SafetyRelatedText: %w", err)
	} else {
		val.SafetyRelatedText = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisSafetyRelatedBroadcastMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	SafetyRelatedText string
}
func DecodeAisSafetyRelatedBroadcastMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisSafetyRelatedBroadcastMessage
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisSafetyRelatedBroadcastMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisSafetyRelatedBroadcastMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisSafetyRelatedBroadcastMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisSafetyRelatedBroadcastMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readFixedString(1296); err != nil {
		return nil, fmt.Errorf("parse failed for AisSafetyRelatedBroadcastMessage-SafetyRelatedText: %w", err)
	} else {
		val.SafetyRelatedText = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisInterrogation struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	DestinationId1 *uint32
	MessageId11 AisMessageIdConst
	SlotOffset11 *uint16
	MessageId12 AisMessageIdConst
	SlotOffset12 *uint16
	DestinationId2 *uint32
	MessageId21 AisMessageIdConst
	SlotOffset21 *uint16
	Sid *uint8
}
func DecodeAisInterrogation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisInterrogation
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-DestinationId1: %w", err)
	} else {
		val.DestinationId1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-MessageId11: %w", err)
	} else {
		val.MessageId11 = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(12); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-SlotOffset11: %w", err)
	} else {
		val.SlotOffset11 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-MessageId12: %w", err)
	} else {
		val.MessageId12 = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(12); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-SlotOffset12: %w", err)
	} else {
		val.SlotOffset12 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-DestinationId2: %w", err)
	} else {
		val.DestinationId2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-MessageId21: %w", err)
	} else {
		val.MessageId21 = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(12); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-SlotOffset21: %w", err)
	} else {
		val.SlotOffset21 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisInterrogation-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisAssignmentModeCommand struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	DestinationIdA *uint32
	OffsetA *uint16
	IncrementA *uint16
	DestinationIdB *uint32
	OffsetB *uint16
	IncrementB *uint16
}
func DecodeAisAssignmentModeCommand(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisAssignmentModeCommand
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-DestinationIdA: %w", err)
	} else {
		val.DestinationIdA = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-OffsetA: %w", err)
	} else {
		val.OffsetA = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-IncrementA: %w", err)
	} else {
		val.IncrementA = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-DestinationIdB: %w", err)
	} else {
		val.DestinationIdB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-OffsetB: %w", err)
	} else {
		val.OffsetB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAssignmentModeCommand-IncrementB: %w", err)
	} else {
		val.IncrementB = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisDataLinkManagementMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	Repeating1 []AisDataLinkManagementMessageRepeating1
}
type AisDataLinkManagementMessageRepeating1 struct {
	Offset *uint16
	NumberOfSlots *uint8
	Timeout *uint8
	Increment *uint16
}
func DecodeAisDataLinkManagementMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisDataLinkManagementMessage
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	val.Repeating1 = make([]AisDataLinkManagementMessageRepeating1, 0)
	i := 0 
	for {
		var rep AisDataLinkManagementMessageRepeating1
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-Offset: %w", err)
		} else {
			rep.Offset = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-NumberOfSlots: %w", err)
		} else {
			rep.NumberOfSlots = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-Timeout: %w", err)
		} else {
			rep.Timeout = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for AisDataLinkManagementMessage-Increment: %w", err)
		} else {
			rep.Increment = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AisChannelManagement struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	ChannelA *uint8
	ChannelB *uint8
	Power *uint8
	TxRxMode *uint8
	NorthEastLongitudeCorner1 *float32
	NorthEastLatitudeCorner1 *float32
	SouthWestLongitudeCorner1 *float32
	SouthWestLatitudeCorner2 *float32
	AddressedOrBroadcastMessageIndicator *uint8
	ChannelABandwidth *uint8
	ChannelBBandwidth *uint8
	TransitionalZoneSize *uint8
}
func DecodeAisChannelManagement(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisChannelManagement
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(7); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-ChannelA: %w", err)
	} else {
		val.ChannelA = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(7); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-ChannelB: %w", err)
	} else {
		val.ChannelB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-Power: %w", err)
	} else {
		val.Power = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-TxRxMode: %w", err)
	} else {
		val.TxRxMode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-NorthEastLongitudeCorner1: %w", err)
	} else {
		val.NorthEastLongitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-NorthEastLatitudeCorner1: %w", err)
	} else {
		val.NorthEastLatitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-SouthWestLongitudeCorner1: %w", err)
	} else {
		val.SouthWestLongitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-SouthWestLatitudeCorner2: %w", err)
	} else {
		val.SouthWestLatitudeCorner2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-AddressedOrBroadcastMessageIndicator: %w", err)
	} else {
		val.AddressedOrBroadcastMessageIndicator = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(7); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-ChannelABandwidth: %w", err)
	} else {
		val.ChannelABandwidth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(7); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-ChannelBBandwidth: %w", err)
	} else {
		val.ChannelBBandwidth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisChannelManagement-TransitionalZoneSize: %w", err)
	} else {
		val.TransitionalZoneSize = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBGroupAssignment struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	TxRxMode TxRxModeConst
	NorthEastLongitudeCorner1 *float32
	NorthEastLatitudeCorner1 *float32
	SouthWestLongitudeCorner1 *float32
	SouthWestLatitudeCorner2 *float32
	StationType StationTypeConst
	ShipAndCargoFilter *uint8
	ReportingInterval ReportingIntervalConst
	QuietTime *uint8
}
func DecodeAisClassBGroupAssignment(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassBGroupAssignment
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-TxRxMode: %w", err)
	} else {
		val.TxRxMode = TxRxModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-NorthEastLongitudeCorner1: %w", err)
	} else {
		val.NorthEastLongitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-NorthEastLatitudeCorner1: %w", err)
	} else {
		val.NorthEastLatitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-SouthWestLongitudeCorner1: %w", err)
	} else {
		val.SouthWestLongitudeCorner1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-SouthWestLatitudeCorner2: %w", err)
	} else {
		val.SouthWestLatitudeCorner2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-StationType: %w", err)
	} else {
		val.StationType = StationTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-ShipAndCargoFilter: %w", err)
	} else {
		val.ShipAndCargoFilter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-ReportingInterval: %w", err)
	} else {
		val.ReportingInterval = ReportingIntervalConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBGroupAssignment-QuietTime: %w", err)
	} else {
		val.QuietTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type DscDistressCallInformation struct {
	Info MessageInfo
	DscFormat DscFormatConst
	DscCategory *uint8
	DscMessageAddress []uint8
	NatureOfDistress DscNatureConst
	SubsequentCommunicationModeOr2ndTelecommand DscSecondTelecommandConst
	ProposedRxFrequencyChannel string
	ProposedTxFrequencyChannel string
	TelephoneNumber string
	LatitudeOfVesselReported *float32
	LongitudeOfVesselReported *float32
	TimeOfPosition *float32
	MmsiOfShipInDistress []uint8
	DscEosSymbol *uint8
	ExpansionEnabled YesNoConst
	CallingRxFrequencyChannel string
	CallingTxFrequencyChannel string
	TimeOfReceipt *float32
	DateOfReceipt *uint16
	DscEquipmentAssignedMessageId *uint16
	Repeating1 []DscDistressCallInformationRepeating1
}
type DscDistressCallInformationRepeating1 struct {
	DscExpansionFieldSymbol DscExpansionDataConst
	DscExpansionFieldData string
}
func DecodeDscDistressCallInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DscDistressCallInformation
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscFormat: %w", err)
	} else {
		val.DscFormat = DscFormatConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscCategory: %w", err)
	} else {
		if v != nil && *v != 112 {
			return nil, fmt.Errorf("match failed for DscDistressCallInformation-DscCategory: Expected %d != %d", 112, *v)
		}
		val.DscCategory = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(40); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscMessageAddress: %w", err)
	} else {
		val.DscMessageAddress = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-NatureOfDistress: %w", err)
	} else {
		val.NatureOfDistress = DscNatureConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-SubsequentCommunicationModeOr2ndTelecommand: %w", err)
	} else {
		val.SubsequentCommunicationModeOr2ndTelecommand = DscSecondTelecommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-ProposedRxFrequencyChannel: %w", err)
	} else {
		val.ProposedRxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-ProposedTxFrequencyChannel: %w", err)
	} else {
		val.ProposedTxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-TelephoneNumber: %w", err)
	} else {
		val.TelephoneNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-LatitudeOfVesselReported: %w", err)
	} else {
		val.LatitudeOfVesselReported = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-LongitudeOfVesselReported: %w", err)
	} else {
		val.LongitudeOfVesselReported = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-TimeOfPosition: %w", err)
	} else {
		val.TimeOfPosition = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(40); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-MmsiOfShipInDistress: %w", err)
	} else {
		val.MmsiOfShipInDistress = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscEosSymbol: %w", err)
	} else {
		val.DscEosSymbol = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-ExpansionEnabled: %w", err)
	} else {
		val.ExpansionEnabled = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-CallingRxFrequencyChannel: %w", err)
	} else {
		val.CallingRxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-CallingTxFrequencyChannel: %w", err)
	} else {
		val.CallingTxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-TimeOfReceipt: %w", err)
	} else {
		val.TimeOfReceipt = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DateOfReceipt: %w", err)
	} else {
		val.DateOfReceipt = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscEquipmentAssignedMessageId: %w", err)
	} else {
		val.DscEquipmentAssignedMessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	val.Repeating1 = make([]DscDistressCallInformationRepeating1, 0)
	i := 0 
	for {
		var rep DscDistressCallInformationRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscExpansionFieldSymbol: %w", err)
		} else {
			rep.DscExpansionFieldSymbol = DscExpansionDataConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for DscDistressCallInformation-DscExpansionFieldData: %w", err)
		} else {
			rep.DscExpansionFieldData = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type DscCallInformation struct {
	Info MessageInfo
	DscFormatSymbol DscFormatConst
	DscCategorySymbol DscCategoryConst
	DscMessageAddress []uint8
	FirstTelecommand DscFirstTelecommandConst
	SubsequentCommunicationModeOr2ndTelecommand DscSecondTelecommandConst
	ProposedRxFrequencyChannel string
	ProposedTxFrequencyChannel string
	TelephoneNumber string
	LatitudeOfVesselReported *float32
	LongitudeOfVesselReported *float32
	TimeOfPosition *float32
	MmsiOfShipInDistress []uint8
	DscEosSymbol *uint8
	ExpansionEnabled YesNoConst
	CallingRxFrequencyChannel string
	CallingTxFrequencyChannel string
	TimeOfReceipt *float32
	DateOfReceipt *uint16
	DscEquipmentAssignedMessageId *uint16
	Repeating1 []DscCallInformationRepeating1
}
type DscCallInformationRepeating1 struct {
	DscExpansionFieldSymbol DscExpansionDataConst
	DscExpansionFieldData string
}
func DecodeDscCallInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DscCallInformation
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DscFormatSymbol: %w", err)
	} else {
		val.DscFormatSymbol = DscFormatConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DscCategorySymbol: %w", err)
	} else {
		val.DscCategorySymbol = DscCategoryConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(40); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DscMessageAddress: %w", err)
	} else {
		val.DscMessageAddress = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-FirstTelecommand: %w", err)
	} else {
		val.FirstTelecommand = DscFirstTelecommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-SubsequentCommunicationModeOr2ndTelecommand: %w", err)
	} else {
		val.SubsequentCommunicationModeOr2ndTelecommand = DscSecondTelecommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-ProposedRxFrequencyChannel: %w", err)
	} else {
		val.ProposedRxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-ProposedTxFrequencyChannel: %w", err)
	} else {
		val.ProposedTxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-TelephoneNumber: %w", err)
	} else {
		val.TelephoneNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-LatitudeOfVesselReported: %w", err)
	} else {
		val.LatitudeOfVesselReported = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-LongitudeOfVesselReported: %w", err)
	} else {
		val.LongitudeOfVesselReported = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-TimeOfPosition: %w", err)
	} else {
		val.TimeOfPosition = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(40); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-MmsiOfShipInDistress: %w", err)
	} else {
		val.MmsiOfShipInDistress = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DscEosSymbol: %w", err)
	} else {
		val.DscEosSymbol = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-ExpansionEnabled: %w", err)
	} else {
		val.ExpansionEnabled = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-CallingRxFrequencyChannel: %w", err)
	} else {
		val.CallingRxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(48); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-CallingTxFrequencyChannel: %w", err)
	} else {
		val.CallingTxFrequencyChannel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-TimeOfReceipt: %w", err)
	} else {
		val.TimeOfReceipt = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DateOfReceipt: %w", err)
	} else {
		val.DateOfReceipt = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DscCallInformation-DscEquipmentAssignedMessageId: %w", err)
	} else {
		val.DscEquipmentAssignedMessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	val.Repeating1 = make([]DscCallInformationRepeating1, 0)
	i := 0 
	for {
		var rep DscCallInformationRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for DscCallInformation-DscExpansionFieldSymbol: %w", err)
		} else {
			rep.DscExpansionFieldSymbol = DscExpansionDataConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for DscCallInformation-DscExpansionFieldData: %w", err)
		} else {
			rep.DscExpansionFieldData = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AisClassBStaticDataMsg24PartA struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Name string
	AisTransceiverInformation AisTransceiverConst
	SequenceId *uint8
}
func DecodeAisClassBStaticDataMsg24PartA(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassBStaticDataMsg24PartA
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-SequenceId: %w", err)
	} else {
		val.SequenceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBStaticDataMsg24PartB struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	TypeOfShip ShipTypeConst
	VendorId string
	Callsign string
	Length *float32
	Beam *float32
	PositionReferenceFromStarboard *float32
	PositionReferenceFromBow *float32
	MothershipUserId *uint32
	AisTransceiverInformation AisTransceiverConst
	SequenceId *uint8
}
func DecodeAisClassBStaticDataMsg24PartB(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AisClassBStaticDataMsg24PartB
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-VendorId: %w", err)
	} else {
		val.VendorId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Callsign: %w", err)
	} else {
		val.Callsign = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Beam: %w", err)
	} else {
		val.Beam = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MothershipUserId: %w", err)
	} else {
		val.MothershipUserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-SequenceId: %w", err)
	} else {
		val.SequenceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LoranCTdData struct {
	Info MessageInfo
	GroupRepetitionIntervalGri *int32
	MasterRange *int32
	VSecondaryTd *int32
	WSecondaryTd *int32
	XSecondaryTd *int32
	YSecondaryTd *int32
	ZSecondaryTd *int32
	StationStatusMaster StationStatusConst
	StationStatusV StationStatusConst
	StationStatusW StationStatusConst
	StationStatusX StationStatusConst
	StationStatusY StationStatusConst
	StationStatusZ StationStatusConst
	Mode ResidualModeConst
}
func DecodeLoranCTdData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LoranCTdData
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-GroupRepetitionIntervalGri: %w", err)
	} else {
		val.GroupRepetitionIntervalGri = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-MasterRange: %w", err)
	} else {
		val.MasterRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-VSecondaryTd: %w", err)
	} else {
		val.VSecondaryTd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-WSecondaryTd: %w", err)
	} else {
		val.WSecondaryTd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-XSecondaryTd: %w", err)
	} else {
		val.XSecondaryTd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-YSecondaryTd: %w", err)
	} else {
		val.YSecondaryTd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-ZSecondaryTd: %w", err)
	} else {
		val.ZSecondaryTd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusMaster: %w", err)
	} else {
		val.StationStatusMaster = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusV: %w", err)
	} else {
		val.StationStatusV = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusW: %w", err)
	} else {
		val.StationStatusW = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusX: %w", err)
	} else {
		val.StationStatusX = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusY: %w", err)
	} else {
		val.StationStatusY = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-StationStatusZ: %w", err)
	} else {
		val.StationStatusZ = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCTdData-Mode: %w", err)
	} else {
		val.Mode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LoranCRangeData struct {
	Info MessageInfo
	GroupRepetitionIntervalGri *int32
	MasterRange *int32
	VSecondaryRange *int32
	WSecondaryRange *int32
	XSecondaryRange *int32
	YSecondaryRange *int32
	ZSecondaryRange *int32
	StationStatusMaster StationStatusConst
	StationStatusV StationStatusConst
	StationStatusW StationStatusConst
	StationStatusX StationStatusConst
	StationStatusY StationStatusConst
	StationStatusZ StationStatusConst
	Mode ResidualModeConst
}
func DecodeLoranCRangeData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LoranCRangeData
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-GroupRepetitionIntervalGri: %w", err)
	} else {
		val.GroupRepetitionIntervalGri = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-MasterRange: %w", err)
	} else {
		val.MasterRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-VSecondaryRange: %w", err)
	} else {
		val.VSecondaryRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-WSecondaryRange: %w", err)
	} else {
		val.WSecondaryRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-XSecondaryRange: %w", err)
	} else {
		val.XSecondaryRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-YSecondaryRange: %w", err)
	} else {
		val.YSecondaryRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-ZSecondaryRange: %w", err)
	} else {
		val.ZSecondaryRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusMaster: %w", err)
	} else {
		val.StationStatusMaster = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusV: %w", err)
	} else {
		val.StationStatusV = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusW: %w", err)
	} else {
		val.StationStatusW = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusX: %w", err)
	} else {
		val.StationStatusX = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusY: %w", err)
	} else {
		val.StationStatusY = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-StationStatusZ: %w", err)
	} else {
		val.StationStatusZ = StationStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCRangeData-Mode: %w", err)
	} else {
		val.Mode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LoranCSignalData struct {
	Info MessageInfo
	GroupRepetitionIntervalGri *int32
	StationIdentifier string
	StationSnr *float32
	StationEcd *int32
	StationAsf *int32
}
func DecodeLoranCSignalData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LoranCSignalData
	val.Info = Info
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCSignalData-GroupRepetitionIntervalGri: %w", err)
	} else {
		val.GroupRepetitionIntervalGri = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCSignalData-StationIdentifier: %w", err)
	} else {
		val.StationIdentifier = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCSignalData-StationSnr: %w", err)
	} else {
		val.StationSnr = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCSignalData-StationEcd: %w", err)
	} else {
		val.StationEcd = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LoranCSignalData-StationAsf: %w", err)
	} else {
		val.StationAsf = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Label struct {
	Info MessageInfo
	HardwareChannelId *uint8
	Pgn *uint32
	DataSourceInstanceFieldNumber *uint8
	DataSourceInstanceValue *uint8
	SecondaryEnumerationFieldNumber *uint8
	SecondaryEnumerationFieldValue *uint8
	ParameterFieldNumber *uint8
	Label string
}
func DecodeLabel(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Label
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-HardwareChannelId: %w", err)
	} else {
		val.HardwareChannelId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for Label-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-DataSourceInstanceFieldNumber: %w", err)
	} else {
		val.DataSourceInstanceFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-DataSourceInstanceValue: %w", err)
	} else {
		val.DataSourceInstanceValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-SecondaryEnumerationFieldNumber: %w", err)
	} else {
		val.SecondaryEnumerationFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-SecondaryEnumerationFieldValue: %w", err)
	} else {
		val.SecondaryEnumerationFieldValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Label-ParameterFieldNumber: %w", err)
	} else {
		val.ParameterFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for Label-Label: %w", err)
	} else {
		val.Label = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ChannelSourceConfiguration struct {
	Info MessageInfo
	DataSourceChannelId *uint8
	SourceSelectionStatus *uint8
	NameSelectionCriteriaMask interface{}
	SourceName *uint64
	Pgn *uint32
	DataSourceInstanceFieldNumber *uint8
	DataSourceInstanceValue *uint8
	SecondaryEnumerationFieldNumber *uint8
	SecondaryEnumerationFieldValue *uint8
	ParameterFieldNumber *uint8
}
func DecodeChannelSourceConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ChannelSourceConfiguration
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-DataSourceChannelId: %w", err)
	} else {
		val.DataSourceChannelId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-SourceSelectionStatus: %w", err)
	} else {
		val.SourceSelectionStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(12); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-NameSelectionCriteriaMask: %w", err)
	} else {
		val.NameSelectionCriteriaMask = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-SourceName: %w", err)
	} else {
		val.SourceName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-Pgn: %w", err)
	} else {
		val.Pgn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-DataSourceInstanceFieldNumber: %w", err)
	} else {
		val.DataSourceInstanceFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-DataSourceInstanceValue: %w", err)
	} else {
		val.DataSourceInstanceValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-SecondaryEnumerationFieldNumber: %w", err)
	} else {
		val.SecondaryEnumerationFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-SecondaryEnumerationFieldValue: %w", err)
	} else {
		val.SecondaryEnumerationFieldValue = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChannelSourceConfiguration-ParameterFieldNumber: %w", err)
	} else {
		val.ParameterFieldNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type RouteAndWpServiceDatabaseList struct {
	Info MessageInfo
	StartDatabaseId *uint8
	Nitems *uint8
	NumberOfDatabasesAvailable *uint8
	Repeating1 []RouteAndWpServiceDatabaseListRepeating1
}
type RouteAndWpServiceDatabaseListRepeating1 struct {
	DatabaseId *uint8
	DatabaseName string
	DatabaseTimestamp *float32
	DatabaseDatestamp *uint16
	WpPositionResolution *uint8
	NumberOfRoutesInDatabase *uint16
	NumberOfWpsInDatabase *uint16
	NumberOfBytesInDatabase *uint16
}
func DecodeRouteAndWpServiceDatabaseList(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceDatabaseList
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-StartDatabaseId: %w", err)
	} else {
		val.StartDatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-NumberOfDatabasesAvailable: %w", err)
	} else {
		val.NumberOfDatabasesAvailable = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceDatabaseListRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceDatabaseListRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-DatabaseId: %w", err)
		} else {
			rep.DatabaseId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-DatabaseName: %w", err)
		} else {
			rep.DatabaseName = v
		}
		if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-DatabaseTimestamp: %w", err)
		} else {
			rep.DatabaseTimestamp = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-DatabaseDatestamp: %w", err)
		} else {
			rep.DatabaseDatestamp = v
		}
		if v, err := stream.readUInt8(6); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-WpPositionResolution: %w", err)
		} else {
			rep.WpPositionResolution = v
		}
		stream.skipBits(2)
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-NumberOfRoutesInDatabase: %w", err)
		} else {
			rep.NumberOfRoutesInDatabase = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-NumberOfWpsInDatabase: %w", err)
		} else {
			rep.NumberOfWpsInDatabase = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseList-NumberOfBytesInDatabase: %w", err)
		} else {
			rep.NumberOfBytesInDatabase = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceRouteList struct {
	Info MessageInfo
	StartRouteId *uint8
	Nitems *uint8
	NumberOfRoutesInDatabase *uint8
	DatabaseId *uint8
	Repeating1 []RouteAndWpServiceRouteListRepeating1
}
type RouteAndWpServiceRouteListRepeating1 struct {
	RouteId *uint8
	RouteName string
	WpIdentificationMethod *uint8
	RouteStatus *uint8
}
func DecodeRouteAndWpServiceRouteList(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRouteList
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-StartRouteId: %w", err)
	} else {
		val.StartRouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-NumberOfRoutesInDatabase: %w", err)
	} else {
		val.NumberOfRoutesInDatabase = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceRouteListRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceRouteListRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-RouteId: %w", err)
		} else {
			rep.RouteId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-RouteName: %w", err)
		} else {
			rep.RouteName = v
		}
		stream.skipBits(4)
		if v, err := stream.readUInt8(2); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-WpIdentificationMethod: %w", err)
		} else {
			rep.WpIdentificationMethod = v
		}
		if v, err := stream.readUInt8(2); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteList-RouteStatus: %w", err)
		} else {
			rep.RouteStatus = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceRouteWpListAttributes struct {
	Info MessageInfo
	DatabaseId *uint8
	RouteId *uint8
	RouteWpListName string
	RouteWpListTimestamp *float32
	RouteWpListDatestamp *uint16
	ChangeAtLastTimestamp *uint8
	NumberOfWpsInTheRouteWpList *uint16
	CriticalSupplementaryParameters *uint8
	NavigationMethod *uint8
	WpIdentificationMethod *uint8
	RouteStatus *uint8
	XteLimitForTheRoute *uint16
}
func DecodeRouteAndWpServiceRouteWpListAttributes(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRouteWpListAttributes
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-RouteWpListName: %w", err)
	} else {
		val.RouteWpListName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-RouteWpListTimestamp: %w", err)
	} else {
		val.RouteWpListTimestamp = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-RouteWpListDatestamp: %w", err)
	} else {
		val.RouteWpListDatestamp = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-ChangeAtLastTimestamp: %w", err)
	} else {
		val.ChangeAtLastTimestamp = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-NumberOfWpsInTheRouteWpList: %w", err)
	} else {
		val.NumberOfWpsInTheRouteWpList = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-CriticalSupplementaryParameters: %w", err)
	} else {
		val.CriticalSupplementaryParameters = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-NavigationMethod: %w", err)
	} else {
		val.NavigationMethod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-WpIdentificationMethod: %w", err)
	} else {
		val.WpIdentificationMethod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-RouteStatus: %w", err)
	} else {
		val.RouteStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpListAttributes-XteLimitForTheRoute: %w", err)
	} else {
		val.XteLimitForTheRoute = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type RouteAndWpServiceRouteWpNamePosition struct {
	Info MessageInfo
	StartRps *uint8
	Nitems *uint8
	NumberOfWpsInTheRouteWpList *uint16
	DatabaseId *uint8
	RouteId *uint8
	Repeating1 []RouteAndWpServiceRouteWpNamePositionRepeating1
}
type RouteAndWpServiceRouteWpNamePositionRepeating1 struct {
	WpId *uint8
	WpName string
	WpLatitude *float32
	WpLongitude *float32
}
func DecodeRouteAndWpServiceRouteWpNamePosition(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRouteWpNamePosition
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-StartRps: %w", err)
	} else {
		val.StartRps = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-NumberOfWpsInTheRouteWpList: %w", err)
	} else {
		val.NumberOfWpsInTheRouteWpList = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceRouteWpNamePositionRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceRouteWpNamePositionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-WpLatitude: %w", err)
		} else {
			rep.WpLatitude = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpNamePosition-WpLongitude: %w", err)
		} else {
			rep.WpLongitude = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceRouteWpName struct {
	Info MessageInfo
	StartRps *uint8
	Nitems *uint8
	NumberOfWpsInTheRouteWpList *uint16
	DatabaseId *uint8
	RouteId *uint8
	Repeating1 []RouteAndWpServiceRouteWpNameRepeating1
}
type RouteAndWpServiceRouteWpNameRepeating1 struct {
	WpId *uint8
	WpName string
}
func DecodeRouteAndWpServiceRouteWpName(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRouteWpName
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-StartRps: %w", err)
	} else {
		val.StartRps = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-NumberOfWpsInTheRouteWpList: %w", err)
	} else {
		val.NumberOfWpsInTheRouteWpList = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceRouteWpNameRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceRouteWpNameRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteWpName-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceXteLimitNavigationMethod struct {
	Info MessageInfo
	StartRps *uint8
	Nitems *uint8
	NumberOfWpsWithASpecificXteLimitOrNavMethod *uint16
	Repeating1 []RouteAndWpServiceXteLimitNavigationMethodRepeating1
}
type RouteAndWpServiceXteLimitNavigationMethodRepeating1 struct {
	DatabaseId *uint8
	RouteId *uint8
	Rps *uint8
	XteLimitInTheLegAfterWp *uint16
	NavMethodInTheLegAfterWp *uint8
}
func DecodeRouteAndWpServiceXteLimitNavigationMethod(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceXteLimitNavigationMethod
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-StartRps: %w", err)
	} else {
		val.StartRps = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-NumberOfWpsWithASpecificXteLimitOrNavMethod: %w", err)
	} else {
		val.NumberOfWpsWithASpecificXteLimitOrNavMethod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceXteLimitNavigationMethodRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceXteLimitNavigationMethodRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-DatabaseId: %w", err)
		} else {
			rep.DatabaseId = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-RouteId: %w", err)
		} else {
			rep.RouteId = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-Rps: %w", err)
		} else {
			rep.Rps = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-XteLimitInTheLegAfterWp: %w", err)
		} else {
			rep.XteLimitInTheLegAfterWp = v
		}
		if v, err := stream.readUInt8(4); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceXteLimitNavigationMethod-NavMethodInTheLegAfterWp: %w", err)
		} else {
			rep.NavMethodInTheLegAfterWp = v
		}
		stream.skipBits(4)
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceWpComment struct {
	Info MessageInfo
	StartId *uint8
	Nitems *uint8
	NumberOfWpsWithComments *uint16
	DatabaseId *uint8
	RouteId *uint8
	Repeating1 []RouteAndWpServiceWpCommentRepeating1
}
type RouteAndWpServiceWpCommentRepeating1 struct {
	WpIdRps *uint8
	Comment string
}
func DecodeRouteAndWpServiceWpComment(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceWpComment
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-StartId: %w", err)
	} else {
		val.StartId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-NumberOfWpsWithComments: %w", err)
	} else {
		val.NumberOfWpsWithComments = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceWpCommentRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceWpCommentRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-WpIdRps: %w", err)
		} else {
			rep.WpIdRps = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpComment-Comment: %w", err)
		} else {
			rep.Comment = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceRouteComment struct {
	Info MessageInfo
	StartRouteId *uint8
	Nitems *uint8
	NumberOfRoutesWithComments *uint16
	DatabaseId *uint8
	Repeating1 []RouteAndWpServiceRouteCommentRepeating1
}
type RouteAndWpServiceRouteCommentRepeating1 struct {
	RouteId *uint8
	Comment string
}
func DecodeRouteAndWpServiceRouteComment(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRouteComment
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-StartRouteId: %w", err)
	} else {
		val.StartRouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-NumberOfRoutesWithComments: %w", err)
	} else {
		val.NumberOfRoutesWithComments = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceRouteCommentRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceRouteCommentRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-RouteId: %w", err)
		} else {
			rep.RouteId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRouteComment-Comment: %w", err)
		} else {
			rep.Comment = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceDatabaseComment struct {
	Info MessageInfo
	StartDatabaseId *uint8
	Nitems *uint8
	NumberOfDatabasesWithComments *uint16
	Repeating1 []RouteAndWpServiceDatabaseCommentRepeating1
}
type RouteAndWpServiceDatabaseCommentRepeating1 struct {
	DatabaseId *uint8
	Comment string
}
func DecodeRouteAndWpServiceDatabaseComment(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceDatabaseComment
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseComment-StartDatabaseId: %w", err)
	} else {
		val.StartDatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseComment-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseComment-NumberOfDatabasesWithComments: %w", err)
	} else {
		val.NumberOfDatabasesWithComments = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceDatabaseCommentRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceDatabaseCommentRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseComment-DatabaseId: %w", err)
		} else {
			rep.DatabaseId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceDatabaseComment-Comment: %w", err)
		} else {
			rep.Comment = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceRadiusOfTurn struct {
	Info MessageInfo
	StartRps *uint8
	Nitems *uint8
	NumberOfWpsWithASpecificRadiusOfTurn *uint16
	DatabaseId *uint8
	RouteId *uint8
	Repeating1 []RouteAndWpServiceRadiusOfTurnRepeating1
}
type RouteAndWpServiceRadiusOfTurnRepeating1 struct {
	Rps *uint8
	RadiusOfTurn *uint16
}
func DecodeRouteAndWpServiceRadiusOfTurn(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceRadiusOfTurn
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-StartRps: %w", err)
	} else {
		val.StartRps = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-NumberOfWpsWithASpecificRadiusOfTurn: %w", err)
	} else {
		val.NumberOfWpsWithASpecificRadiusOfTurn = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-RouteId: %w", err)
	} else {
		val.RouteId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceRadiusOfTurnRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceRadiusOfTurnRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-Rps: %w", err)
		} else {
			rep.Rps = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceRadiusOfTurn-RadiusOfTurn: %w", err)
		} else {
			rep.RadiusOfTurn = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type RouteAndWpServiceWpListWpNamePosition struct {
	Info MessageInfo
	StartWpId *uint8
	Nitems *uint8
	NumberOfValidWpsInTheWpList *uint16
	DatabaseId *uint8
	Repeating1 []RouteAndWpServiceWpListWpNamePositionRepeating1
}
type RouteAndWpServiceWpListWpNamePositionRepeating1 struct {
	WpId *uint8
	WpName string
	WpLatitude *float32
	WpLongitude *float32
}
func DecodeRouteAndWpServiceWpListWpNamePosition(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val RouteAndWpServiceWpListWpNamePosition
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-StartWpId: %w", err)
	} else {
		val.StartWpId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-NumberOfValidWpsInTheWpList: %w", err)
	} else {
		val.NumberOfValidWpsInTheWpList = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]RouteAndWpServiceWpListWpNamePositionRepeating1, 0)
	i := 0 
	for {
		var rep RouteAndWpServiceWpListWpNamePositionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-WpLatitude: %w", err)
		} else {
			rep.WpLatitude = v
		}
		if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for RouteAndWpServiceWpListWpNamePosition-WpLongitude: %w", err)
		} else {
			rep.WpLongitude = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type WindData struct {
	Info MessageInfo
	Sid *uint8
	WindSpeed *float32
	WindAngle *float32
	Reference WindReferenceConst
}
func DecodeWindData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val WindData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-WindSpeed: %w", err)
	} else {
		val.WindSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-WindAngle: %w", err)
	} else {
		val.WindAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-Reference: %w", err)
	} else {
		val.Reference = WindReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(21)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EnvironmentalParametersObsolete struct {
	Info MessageInfo
	Sid *uint8
	WaterTemperature *float32
	OutsideAmbientAirTemperature *float32
	AtmosphericPressure *float32
}
func DecodeEnvironmentalParametersObsolete(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val EnvironmentalParametersObsolete
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-WaterTemperature: %w", err)
	} else {
		val.WaterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-OutsideAmbientAirTemperature: %w", err)
	} else {
		val.OutsideAmbientAirTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EnvironmentalParameters struct {
	Info MessageInfo
	Sid *uint8
	TemperatureSource TemperatureSourceConst
	HumiditySource HumiditySourceConst
	Temperature *float32
	Humidity *float32
	AtmosphericPressure *float32
}
func DecodeEnvironmentalParameters(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val EnvironmentalParameters
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-TemperatureSource: %w", err)
	} else {
		val.TemperatureSource = TemperatureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-HumiditySource: %w", err)
	} else {
		val.HumiditySource = HumiditySourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Temperature: %w", err)
	} else {
		val.Temperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.004); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Humidity: %w", err)
	} else {
		val.Humidity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Temperature struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	ActualTemperature *float32
	SetTemperature *float32
}
func DecodeTemperature(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Temperature
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-SetTemperature: %w", err)
	} else {
		val.SetTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Humidity struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source HumiditySourceConst
	ActualHumidity *float32
	SetHumidity *float32
}
func DecodeHumidity(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val Humidity
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Source: %w", err)
	} else {
		val.Source = HumiditySourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.004); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-ActualHumidity: %w", err)
	} else {
		val.ActualHumidity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.004); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-SetHumidity: %w", err)
	} else {
		val.SetHumidity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ActualPressure struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source PressureSourceConst
	Pressure *float32
}
func DecodeActualPressure(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ActualPressure
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Source: %w", err)
	} else {
		val.Source = PressureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Pressure: %w", err)
	} else {
		val.Pressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SetPressure struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source PressureSourceConst
	Pressure *float32
}
func DecodeSetPressure(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SetPressure
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Source: %w", err)
	} else {
		val.Source = PressureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Pressure: %w", err)
	} else {
		val.Pressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type TemperatureExtendedRange struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	Temperature *float32
	SetTemperature *float32
}
func DecodeTemperatureExtendedRange(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TemperatureExtendedRange
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Temperature: %w", err)
	} else {
		val.Temperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-SetTemperature: %w", err)
	} else {
		val.SetTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TideStationData struct {
	Info MessageInfo
	Mode ResidualModeConst
	TideTendency TideConst
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float32
	StationLongitude *float32
	TideLevel *float32
	TideLevelStandardDeviation *float32
	StationId string
	StationName string
}
func DecodeTideStationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val TideStationData
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-Mode: %w", err)
	} else {
		val.Mode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideTendency: %w", err)
	} else {
		val.TideTendency = TideConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideLevel: %w", err)
	} else {
		val.TideLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideLevelStandardDeviation: %w", err)
	} else {
		val.TideLevelStandardDeviation = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationName: %w", err)
	} else {
		val.StationName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SalinityStationData struct {
	Info MessageInfo
	Mode ResidualModeConst
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float32
	StationLongitude *float32
	Salinity *float32
	WaterTemperature *float32
	StationId string
	StationName string
}
func DecodeSalinityStationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SalinityStationData
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-Mode: %w", err)
	} else {
		val.Mode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-Salinity: %w", err)
	} else {
		val.Salinity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-WaterTemperature: %w", err)
	} else {
		val.WaterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for SalinityStationData-StationName: %w", err)
	} else {
		val.StationName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CurrentStationData struct {
	Info MessageInfo
	Mode *uint8
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float32
	StationLongitude *float32
	MeasurementDepth *float32
	CurrentSpeed *float32
	CurrentFlowDirection *float32
	WaterTemperature *float32
	StationId string
	StationName string
}
func DecodeCurrentStationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val CurrentStationData
	val.Info = Info
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-Mode: %w", err)
	} else {
		val.Mode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-MeasurementDepth: %w", err)
	} else {
		val.MeasurementDepth = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-CurrentSpeed: %w", err)
	} else {
		val.CurrentSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-CurrentFlowDirection: %w", err)
	} else {
		val.CurrentFlowDirection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-WaterTemperature: %w", err)
	} else {
		val.WaterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStationData-StationName: %w", err)
	} else {
		val.StationName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MeteorologicalStationData struct {
	Info MessageInfo
	Mode *uint8
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float32
	StationLongitude *float32
	WindSpeed *float32
	WindDirection *float32
	WindReference WindReferenceConst
	WindGusts *float32
	AtmosphericPressure *float32
	AmbientTemperature *float32
	StationId string
	StationName string
}
func DecodeMeteorologicalStationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MeteorologicalStationData
	val.Info = Info
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-Mode: %w", err)
	} else {
		val.Mode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-WindSpeed: %w", err)
	} else {
		val.WindSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-WindDirection: %w", err)
	} else {
		val.WindDirection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-WindReference: %w", err)
	} else {
		val.WindReference = WindReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-WindGusts: %w", err)
	} else {
		val.WindGusts = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-AmbientTemperature: %w", err)
	} else {
		val.AmbientTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for MeteorologicalStationData-StationName: %w", err)
	} else {
		val.StationName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MooredBuoyStationData struct {
	Info MessageInfo
	Mode *uint8
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float32
	StationLongitude *float32
	WindSpeed *float32
	WindDirection *float32
	WindReference WindReferenceConst
	WindGusts *float32
	WaveHeight *uint16
	DominantWavePeriod *uint16
	AtmosphericPressure *float32
	PressureTendencyRate *int16
	AirTemperature *float32
	WaterTemperature *float32
	StationId string
}
func DecodeMooredBuoyStationData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MooredBuoyStationData
	val.Info = Info
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-Mode: %w", err)
	} else {
		val.Mode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WindSpeed: %w", err)
	} else {
		val.WindSpeed = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WindDirection: %w", err)
	} else {
		val.WindDirection = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WindReference: %w", err)
	} else {
		val.WindReference = WindReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WindGusts: %w", err)
	} else {
		val.WindGusts = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WaveHeight: %w", err)
	} else {
		val.WaveHeight = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-DominantWavePeriod: %w", err)
	} else {
		val.DominantWavePeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-PressureTendencyRate: %w", err)
	} else {
		val.PressureTendencyRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-AirTemperature: %w", err)
	} else {
		val.AirTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-WaterTemperature: %w", err)
	} else {
		val.WaterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(64); err != nil {
		return nil, fmt.Errorf("parse failed for MooredBuoyStationData-StationId: %w", err)
	} else {
		val.StationId = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LightingSystemSettings struct {
	Info MessageInfo
	GlobalEnable *uint8
	DefaultSettingsCommand LightingCommandConst
	NameOfTheLightingController string
	MaxScenes *uint8
	MaxSceneConfigurationCount *uint8
	MaxZones *uint8
	MaxColorSequences *uint8
	MaxColorSequenceColorCount *uint8
	NumberOfPrograms *uint8
	ControllerCapabilities *uint8
	IdentifyDevice *uint32
}
func DecodeLightingSystemSettings(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingSystemSettings
	val.Info = Info
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-GlobalEnable: %w", err)
	} else {
		val.GlobalEnable = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-DefaultSettingsCommand: %w", err)
	} else {
		val.DefaultSettingsCommand = LightingCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-NameOfTheLightingController: %w", err)
	} else {
		val.NameOfTheLightingController = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-MaxScenes: %w", err)
	} else {
		val.MaxScenes = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-MaxSceneConfigurationCount: %w", err)
	} else {
		val.MaxSceneConfigurationCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-MaxZones: %w", err)
	} else {
		val.MaxZones = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-MaxColorSequences: %w", err)
	} else {
		val.MaxColorSequences = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-MaxColorSequenceColorCount: %w", err)
	} else {
		val.MaxColorSequenceColorCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-NumberOfPrograms: %w", err)
	} else {
		val.NumberOfPrograms = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-ControllerCapabilities: %w", err)
	} else {
		val.ControllerCapabilities = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LightingSystemSettings-IdentifyDevice: %w", err)
	} else {
		val.IdentifyDevice = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type PayloadMass struct {
	Info MessageInfo
	Sid *uint8
	MeasurementStatus *uint8
	MeasurementId *uint8
	PayloadMass *uint32
}
func DecodePayloadMass(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val PayloadMass
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for PayloadMass-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(3); err != nil {
		return nil, fmt.Errorf("parse failed for PayloadMass-MeasurementStatus: %w", err)
	} else {
		val.MeasurementStatus = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for PayloadMass-MeasurementId: %w", err)
	} else {
		val.MeasurementId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for PayloadMass-PayloadMass: %w", err)
	} else {
		val.PayloadMass = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LightingZone struct {
	Info MessageInfo
	ZoneIndex *uint8
	ZoneName string
	RedComponent *uint8
	GreenComponent *uint8
	BlueComponent *uint8
	ColorTemperature *uint16
	Intensity *uint8
	ProgramId *uint8
	ProgramColorSequenceIndex *uint8
	ProgramIntensity *uint8
	ProgramRate *uint8
	ProgramColorSequence *uint8
	ZoneEnabled OffOnConst
}
func DecodeLightingZone(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingZone
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ZoneIndex: %w", err)
	} else {
		val.ZoneIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ZoneName: %w", err)
	} else {
		val.ZoneName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-RedComponent: %w", err)
	} else {
		val.RedComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-GreenComponent: %w", err)
	} else {
		val.GreenComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-BlueComponent: %w", err)
	} else {
		val.BlueComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ColorTemperature: %w", err)
	} else {
		val.ColorTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-Intensity: %w", err)
	} else {
		val.Intensity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ProgramId: %w", err)
	} else {
		val.ProgramId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ProgramColorSequenceIndex: %w", err)
	} else {
		val.ProgramColorSequenceIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ProgramIntensity: %w", err)
	} else {
		val.ProgramIntensity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ProgramRate: %w", err)
	} else {
		val.ProgramRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ProgramColorSequence: %w", err)
	} else {
		val.ProgramColorSequence = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for LightingZone-ZoneEnabled: %w", err)
	} else {
		val.ZoneEnabled = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LightingScene struct {
	Info MessageInfo
	SceneIndex *uint8
	ZoneName string
	Control *uint8
	ConfigurationCount *uint8
	Repeating1 []LightingSceneRepeating1
}
type LightingSceneRepeating1 struct {
	ConfigurationIndex *uint8
	ZoneIndex *uint8
	DevicesId *uint32
	ProgramIndex *uint8
	ProgramColorSequenceIndex *uint8
	ProgramIntensity *uint8
	ProgramRate *uint8
	ProgramColorSequenceRate *uint8
}
func DecodeLightingScene(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingScene
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingScene-SceneIndex: %w", err)
	} else {
		val.SceneIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingScene-ZoneName: %w", err)
	} else {
		val.ZoneName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingScene-Control: %w", err)
	} else {
		val.Control = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingScene-ConfigurationCount: %w", err)
	} else {
		val.ConfigurationCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]LightingSceneRepeating1, 0)
	i := 0 
	for {
		var rep LightingSceneRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ConfigurationIndex: %w", err)
		} else {
			rep.ConfigurationIndex = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ZoneIndex: %w", err)
		} else {
			rep.ZoneIndex = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-DevicesId: %w", err)
		} else {
			rep.DevicesId = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ProgramIndex: %w", err)
		} else {
			rep.ProgramIndex = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ProgramColorSequenceIndex: %w", err)
		} else {
			rep.ProgramColorSequenceIndex = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ProgramIntensity: %w", err)
		} else {
			rep.ProgramIntensity = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ProgramRate: %w", err)
		} else {
			rep.ProgramRate = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingScene-ProgramColorSequenceRate: %w", err)
		} else {
			rep.ProgramColorSequenceRate = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type LightingDevice struct {
	Info MessageInfo
	DeviceId *uint32
	DeviceCapabilities *uint8
	ColorCapabilities *uint8
	ZoneIndex *uint8
	NameOfLightingDevice string
	Status *uint8
	RedComponent *uint8
	GreenComponent *uint8
	BlueComponent *uint8
	ColorTemperature *uint16
	Intensity *uint8
	ProgramId *uint8
	ProgramColorSequenceIndex *uint8
	ProgramIntensity *uint8
	ProgramRate *uint8
	ProgramColorSequenceRate *uint8
	Enabled OffOnConst
}
func DecodeLightingDevice(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingDevice
	val.Info = Info
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-DeviceId: %w", err)
	} else {
		val.DeviceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-DeviceCapabilities: %w", err)
	} else {
		val.DeviceCapabilities = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ColorCapabilities: %w", err)
	} else {
		val.ColorCapabilities = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ZoneIndex: %w", err)
	} else {
		val.ZoneIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-NameOfLightingDevice: %w", err)
	} else {
		val.NameOfLightingDevice = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-RedComponent: %w", err)
	} else {
		val.RedComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-GreenComponent: %w", err)
	} else {
		val.GreenComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-BlueComponent: %w", err)
	} else {
		val.BlueComponent = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ColorTemperature: %w", err)
	} else {
		val.ColorTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-Intensity: %w", err)
	} else {
		val.Intensity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ProgramId: %w", err)
	} else {
		val.ProgramId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ProgramColorSequenceIndex: %w", err)
	} else {
		val.ProgramColorSequenceIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ProgramIntensity: %w", err)
	} else {
		val.ProgramIntensity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ProgramRate: %w", err)
	} else {
		val.ProgramRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-ProgramColorSequenceRate: %w", err)
	} else {
		val.ProgramColorSequenceRate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDevice-Enabled: %w", err)
	} else {
		val.Enabled = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LightingDeviceEnumeration struct {
	Info MessageInfo
	IndexOfFirstDevice *uint16
	TotalNumberOfDevices *uint16
	NumberOfDevices *uint16
	Repeating1 []LightingDeviceEnumerationRepeating1
}
type LightingDeviceEnumerationRepeating1 struct {
	DeviceId *uint32
	Status *uint8
}
func DecodeLightingDeviceEnumeration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingDeviceEnumeration
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDeviceEnumeration-IndexOfFirstDevice: %w", err)
	} else {
		val.IndexOfFirstDevice = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDeviceEnumeration-TotalNumberOfDevices: %w", err)
	} else {
		val.TotalNumberOfDevices = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LightingDeviceEnumeration-NumberOfDevices: %w", err)
	} else {
		val.NumberOfDevices = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]LightingDeviceEnumerationRepeating1, 0)
	i := 0 
	for {
		var rep LightingDeviceEnumerationRepeating1
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for LightingDeviceEnumeration-DeviceId: %w", err)
		} else {
			rep.DeviceId = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingDeviceEnumeration-Status: %w", err)
		} else {
			rep.Status = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type LightingColorSequence struct {
	Info MessageInfo
	SequenceIndex *uint8
	ColorCount *uint8
	Repeating1 []LightingColorSequenceRepeating1
}
type LightingColorSequenceRepeating1 struct {
	ColorIndex *uint8
	RedComponent *uint8
	GreenComponent *uint8
	BlueComponent *uint8
	ColorTemperature *uint16
}
func DecodeLightingColorSequence(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingColorSequence
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingColorSequence-SequenceIndex: %w", err)
	} else {
		val.SequenceIndex = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingColorSequence-ColorCount: %w", err)
	} else {
		val.ColorCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]LightingColorSequenceRepeating1, 0)
	i := 0 
	for {
		var rep LightingColorSequenceRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingColorSequence-ColorIndex: %w", err)
		} else {
			rep.ColorIndex = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingColorSequence-RedComponent: %w", err)
		} else {
			rep.RedComponent = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingColorSequence-GreenComponent: %w", err)
		} else {
			rep.GreenComponent = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for LightingColorSequence-BlueComponent: %w", err)
		} else {
			rep.BlueComponent = v
		}
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for LightingColorSequence-ColorTemperature: %w", err)
		} else {
			rep.ColorTemperature = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type LightingProgram struct {
	Info MessageInfo
	ProgramId *uint8
	NameOfProgram string
	Description string
	ProgramCapabilities *uint8
}
func DecodeLightingProgram(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LightingProgram
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LightingProgram-ProgramId: %w", err)
	} else {
		val.ProgramId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingProgram-NameOfProgram: %w", err)
	} else {
		val.NameOfProgram = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LightingProgram-Description: %w", err)
	} else {
		val.Description = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for LightingProgram-ProgramCapabilities: %w", err)
	} else {
		val.ProgramCapabilities = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type WatermakerInputSettingAndStatus struct {
	Info MessageInfo
	WatermakerOperatingState WatermakerStateConst
	ProductionStartStop YesNoConst
	RinseStartStop YesNoConst
	LowPressurePumpStatus YesNoConst
	HighPressurePumpStatus YesNoConst
	EmergencyStop YesNoConst
	ProductSolenoidValveStatus OkWarningConst
	FlushModeStatus YesNoConst
	SalinityStatus OkWarningConst
	SensorStatus OkWarningConst
	OilChangeIndicatorStatus OkWarningConst
	FilterStatus OkWarningConst
	SystemStatus OkWarningConst
	Salinity *uint16
	ProductWaterTemperature *float32
	PreFilterPressure *float32
	PostFilterPressure *float32
	FeedPressure *float32
	SystemHighPressure *float32
	ProductWaterFlow *float32
	BrineWaterFlow *float32
	RunTime *uint32
}
func DecodeWatermakerInputSettingAndStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val WatermakerInputSettingAndStatus
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-WatermakerOperatingState: %w", err)
	} else {
		val.WatermakerOperatingState = WatermakerStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductionStartStop: %w", err)
	} else {
		val.ProductionStartStop = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RinseStartStop: %w", err)
	} else {
		val.RinseStartStop = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-LowPressurePumpStatus: %w", err)
	} else {
		val.LowPressurePumpStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-HighPressurePumpStatus: %w", err)
	} else {
		val.HighPressurePumpStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-EmergencyStop: %w", err)
	} else {
		val.EmergencyStop = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductSolenoidValveStatus: %w", err)
	} else {
		val.ProductSolenoidValveStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FlushModeStatus: %w", err)
	} else {
		val.FlushModeStatus = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SalinityStatus: %w", err)
	} else {
		val.SalinityStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SensorStatus: %w", err)
	} else {
		val.SensorStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-OilChangeIndicatorStatus: %w", err)
	} else {
		val.OilChangeIndicatorStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FilterStatus: %w", err)
	} else {
		val.FilterStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemStatus: %w", err)
	} else {
		val.SystemStatus = OkWarningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-Salinity: %w", err)
	} else {
		val.Salinity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterTemperature: %w", err)
	} else {
		val.ProductWaterTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PreFilterPressure: %w", err)
	} else {
		val.PreFilterPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PostFilterPressure: %w", err)
	} else {
		val.PostFilterPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 1000); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FeedPressure: %w", err)
	} else {
		val.FeedPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 1000); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemHighPressure: %w", err)
	} else {
		val.SystemHighPressure = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterFlow: %w", err)
	} else {
		val.ProductWaterFlow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-BrineWaterFlow: %w", err)
	} else {
		val.BrineWaterFlow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RunTime: %w", err)
	} else {
		val.RunTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CurrentStatusAndFile struct {
	Info MessageInfo
	Zone EntertainmentZoneConst
	Source EntertainmentSourceConst
	Number *uint8
	Id *uint32
	PlayStatus EntertainmentPlayStatusConst
	ElapsedTrackTime *uint16
	TrackTime *uint16
	RepeatStatus EntertainmentRepeatStatusConst
	ShuffleStatus EntertainmentShuffleStatusConst
	SaveFavoriteNumber *uint8
	PlayFavoriteNumber *uint16
	ThumbsUpDown EntertainmentLikeStatusConst
	SignalStrength *uint8
	RadioFrequency *float32
	HdFrequencyMulticast *uint8
	DeleteFavoriteNumber *uint8
	TotalNumberOfTracks *uint16
}
func DecodeCurrentStatusAndFile(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val CurrentStatusAndFile
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-Zone: %w", err)
	} else {
		val.Zone = EntertainmentZoneConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-Source: %w", err)
	} else {
		val.Source = EntertainmentSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-Number: %w", err)
	} else {
		val.Number = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-Id: %w", err)
	} else {
		val.Id = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-PlayStatus: %w", err)
	} else {
		val.PlayStatus = EntertainmentPlayStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-ElapsedTrackTime: %w", err)
	} else {
		val.ElapsedTrackTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-TrackTime: %w", err)
	} else {
		val.TrackTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-RepeatStatus: %w", err)
	} else {
		val.RepeatStatus = EntertainmentRepeatStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-ShuffleStatus: %w", err)
	} else {
		val.ShuffleStatus = EntertainmentShuffleStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-SaveFavoriteNumber: %w", err)
	} else {
		val.SaveFavoriteNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-PlayFavoriteNumber: %w", err)
	} else {
		val.PlayFavoriteNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-ThumbsUpDown: %w", err)
	} else {
		val.ThumbsUpDown = EntertainmentLikeStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-SignalStrength: %w", err)
	} else {
		val.SignalStrength = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 10); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-RadioFrequency: %w", err)
	} else {
		val.RadioFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-HdFrequencyMulticast: %w", err)
	} else {
		val.HdFrequencyMulticast = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-DeleteFavoriteNumber: %w", err)
	} else {
		val.DeleteFavoriteNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for CurrentStatusAndFile-TotalNumberOfTracks: %w", err)
	} else {
		val.TotalNumberOfTracks = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LibraryDataFile struct {
	Info MessageInfo
	Source EntertainmentSourceConst
	Number *uint8
	Id *uint32
	Type EntertainmentTypeConst
	Name string
	Track *uint16
	Station *uint16
	Favorite *uint8
	RadioFrequency *float32
	HdFrequency *uint8
	Zone EntertainmentZoneConst
	InPlayQueue YesNoConst
	Locked YesNoConst
	ArtistName string
	AlbumName string
	StationName string
}
func DecodeLibraryDataFile(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LibraryDataFile
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Source: %w", err)
	} else {
		val.Source = EntertainmentSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Number: %w", err)
	} else {
		val.Number = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Id: %w", err)
	} else {
		val.Id = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Type: %w", err)
	} else {
		val.Type = EntertainmentTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Track: %w", err)
	} else {
		val.Track = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Station: %w", err)
	} else {
		val.Station = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Favorite: %w", err)
	} else {
		val.Favorite = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 10); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-RadioFrequency: %w", err)
	} else {
		val.RadioFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-HdFrequency: %w", err)
	} else {
		val.HdFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Zone: %w", err)
	} else {
		val.Zone = EntertainmentZoneConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-InPlayQueue: %w", err)
	} else {
		val.InPlayQueue = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-Locked: %w", err)
	} else {
		val.Locked = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-ArtistName: %w", err)
	} else {
		val.ArtistName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-AlbumName: %w", err)
	} else {
		val.AlbumName = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataFile-StationName: %w", err)
	} else {
		val.StationName = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LibraryDataGroup struct {
	Info MessageInfo
	Source EntertainmentSourceConst
	Number *uint8
	Type EntertainmentTypeConst
	Zone EntertainmentZoneConst
	GroupId *uint32
	IdOffset *uint16
	IdCount *uint16
	TotalIdCount *uint16
	Repeating1 []LibraryDataGroupRepeating1
}
type LibraryDataGroupRepeating1 struct {
	IdType EntertainmentIdTypeConst
	Id *uint32
	Name string
}
func DecodeLibraryDataGroup(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LibraryDataGroup
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-Source: %w", err)
	} else {
		val.Source = EntertainmentSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-Number: %w", err)
	} else {
		val.Number = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-Type: %w", err)
	} else {
		val.Type = EntertainmentTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-Zone: %w", err)
	} else {
		val.Zone = EntertainmentZoneConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-GroupId: %w", err)
	} else {
		val.GroupId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-IdOffset: %w", err)
	} else {
		val.IdOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-IdCount: %w", err)
	} else {
		val.IdCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataGroup-TotalIdCount: %w", err)
	} else {
		val.TotalIdCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]LibraryDataGroupRepeating1, 0)
	i := 0 
	for {
		var rep LibraryDataGroupRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for LibraryDataGroup-IdType: %w", err)
		} else {
			rep.IdType = EntertainmentIdTypeConst(v)
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for LibraryDataGroup-Id: %w", err)
		} else {
			rep.Id = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for LibraryDataGroup-Name: %w", err)
		} else {
			rep.Name = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type LibraryDataSearch struct {
	Info MessageInfo
	Source EntertainmentSourceConst
	Number *uint8
	GroupId *uint32
	GroupType1 EntertainmentGroupConst
	GroupName1 string
	GroupType2 EntertainmentGroupConst
	GroupName2 string
	GroupType3 EntertainmentGroupConst
	GroupName3 string
}
func DecodeLibraryDataSearch(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LibraryDataSearch
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-Source: %w", err)
	} else {
		val.Source = EntertainmentSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-Number: %w", err)
	} else {
		val.Number = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupId: %w", err)
	} else {
		val.GroupId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupType1: %w", err)
	} else {
		val.GroupType1 = EntertainmentGroupConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupName1: %w", err)
	} else {
		val.GroupName1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupType2: %w", err)
	} else {
		val.GroupType2 = EntertainmentGroupConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupName2: %w", err)
	} else {
		val.GroupName2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupType3: %w", err)
	} else {
		val.GroupType3 = EntertainmentGroupConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for LibraryDataSearch-GroupName3: %w", err)
	} else {
		val.GroupName3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SupportedSourceData struct {
	Info MessageInfo
	IdOffset *uint16
	IdCount *uint16
	TotalIdCount *uint16
	Repeating1 []SupportedSourceDataRepeating1
}
type SupportedSourceDataRepeating1 struct {
	Id *uint8
	Source EntertainmentSourceConst
	Number *uint8
	Name string
	PlaySupport EntertainmentPlayStatusBitfieldConst
	BrowseSupport EntertainmentGroupBitfieldConst
	ThumbsSupport YesNoConst
	Connected YesNoConst
	RepeatSupport EntertainmentRepeatBitfieldConst
	ShuffleSupport EntertainmentShuffleBitfieldConst
}
func DecodeSupportedSourceData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SupportedSourceData
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedSourceData-IdOffset: %w", err)
	} else {
		val.IdOffset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedSourceData-IdCount: %w", err)
	} else {
		val.IdCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedSourceData-TotalIdCount: %w", err)
	} else {
		val.TotalIdCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]SupportedSourceDataRepeating1, 0)
	i := 0 
	for {
		var rep SupportedSourceDataRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-Id: %w", err)
		} else {
			rep.Id = v
		}
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-Source: %w", err)
		} else {
			rep.Source = EntertainmentSourceConst(v)
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-Number: %w", err)
		} else {
			rep.Number = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-Name: %w", err)
		} else {
			rep.Name = v
		}
		if v, err := stream.readLookupField(32); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-PlaySupport: %w", err)
		} else {
			rep.PlaySupport = EntertainmentPlayStatusBitfieldConst(v)
		}
		if v, err := stream.readLookupField(16); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-BrowseSupport: %w", err)
		} else {
			rep.BrowseSupport = EntertainmentGroupBitfieldConst(v)
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-ThumbsSupport: %w", err)
		} else {
			rep.ThumbsSupport = YesNoConst(v)
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-Connected: %w", err)
		} else {
			rep.Connected = YesNoConst(v)
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-RepeatSupport: %w", err)
		} else {
			rep.RepeatSupport = EntertainmentRepeatBitfieldConst(v)
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedSourceData-ShuffleSupport: %w", err)
		} else {
			rep.ShuffleSupport = EntertainmentShuffleBitfieldConst(v)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type SupportedZoneData struct {
	Info MessageInfo
	FirstZoneId *uint8
	ZoneCount *uint8
	TotalZoneCount *uint8
	Repeating1 []SupportedZoneDataRepeating1
}
type SupportedZoneDataRepeating1 struct {
	ZoneId EntertainmentZoneConst
	Name string
}
func DecodeSupportedZoneData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SupportedZoneData
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedZoneData-FirstZoneId: %w", err)
	} else {
		val.FirstZoneId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedZoneData-ZoneCount: %w", err)
	} else {
		val.ZoneCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SupportedZoneData-TotalZoneCount: %w", err)
	} else {
		val.TotalZoneCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]SupportedZoneDataRepeating1, 0)
	i := 0 
	for {
		var rep SupportedZoneDataRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedZoneData-ZoneId: %w", err)
		} else {
			rep.ZoneId = EntertainmentZoneConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for SupportedZoneData-Name: %w", err)
		} else {
			rep.Name = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type SmallCraftStatus struct {
	Info MessageInfo
	PortTrimTab *int8
	StarboardTrimTab *int8
}
func DecodeSmallCraftStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SmallCraftStatus
	val.Info = Info
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SmallCraftStatus-PortTrimTab: %w", err)
	} else {
		val.PortTrimTab = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SmallCraftStatus-StarboardTrimTab: %w", err)
	} else {
		val.StarboardTrimTab = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type DirectionData struct {
	Info MessageInfo
	DataMode ResidualModeConst
	CogReference DirectionReferenceConst
	Sid *uint8
	Cog *float32
	Sog *float32
	Heading *float32
	SpeedThroughWater *float32
	Set *float32
	Drift *float32
}
func DecodeDirectionData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val DirectionData
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-DataMode: %w", err)
	} else {
		val.DataMode = ResidualModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-CogReference: %w", err)
	} else {
		val.CogReference = DirectionReferenceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Cog: %w", err)
	} else {
		val.Cog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Sog: %w", err)
	} else {
		val.Sog = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Heading: %w", err)
	} else {
		val.Heading = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-SpeedThroughWater: %w", err)
	} else {
		val.SpeedThroughWater = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Set: %w", err)
	} else {
		val.Set = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for DirectionData-Drift: %w", err)
	} else {
		val.Drift = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type VesselSpeedComponents struct {
	Info MessageInfo
	LongitudinalSpeedWaterReferenced *float32
	TransverseSpeedWaterReferenced *float32
	LongitudinalSpeedGroundReferenced *float32
	TransverseSpeedGroundReferenced *float32
	SternSpeedWaterReferenced *float32
	SternSpeedGroundReferenced *float32
}
func DecodeVesselSpeedComponents(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val VesselSpeedComponents
	val.Info = Info
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedWaterReferenced: %w", err)
	} else {
		val.LongitudinalSpeedWaterReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedWaterReferenced: %w", err)
	} else {
		val.TransverseSpeedWaterReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedGroundReferenced: %w", err)
	} else {
		val.LongitudinalSpeedGroundReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedGroundReferenced: %w", err)
	} else {
		val.TransverseSpeedGroundReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedWaterReferenced: %w", err)
	} else {
		val.SternSpeedWaterReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedGroundReferenced: %w", err)
	} else {
		val.SternSpeedGroundReferenced = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SystemConfiguration struct {
	Info MessageInfo
	Power YesNoConst
	DefaultSettings EntertainmentDefaultSettingsConst
	TunerRegions EntertainmentRegionsConst
	MaxFavorites *uint8
	VideoProtocols VideoProtocolsConst
}
func DecodeSystemConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SystemConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfiguration-Power: %w", err)
	} else {
		val.Power = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfiguration-DefaultSettings: %w", err)
	} else {
		val.DefaultSettings = EntertainmentDefaultSettingsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfiguration-TunerRegions: %w", err)
	} else {
		val.TunerRegions = EntertainmentRegionsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfiguration-MaxFavorites: %w", err)
	} else {
		val.MaxFavorites = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfiguration-VideoProtocols: %w", err)
	} else {
		val.VideoProtocols = VideoProtocolsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(44)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SystemConfigurationDeprecated struct {
	Info MessageInfo
	Power YesNoConst
	DefaultSettings EntertainmentDefaultSettingsConst
	TunerRegions EntertainmentRegionsConst
	MaxFavorites *uint8
}
func DecodeSystemConfigurationDeprecated(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SystemConfigurationDeprecated
	val.Info = Info
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfigurationDeprecated-Power: %w", err)
	} else {
		val.Power = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfigurationDeprecated-DefaultSettings: %w", err)
	} else {
		val.DefaultSettings = EntertainmentDefaultSettingsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfigurationDeprecated-TunerRegions: %w", err)
	} else {
		val.TunerRegions = EntertainmentRegionsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SystemConfigurationDeprecated-MaxFavorites: %w", err)
	} else {
		val.MaxFavorites = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ZoneConfigurationDeprecated struct {
	Info MessageInfo
	FirstZoneId *uint8
	ZoneCount *uint8
	TotalZoneCount *uint8
	Repeating1 []ZoneConfigurationDeprecatedRepeating1
}
type ZoneConfigurationDeprecatedRepeating1 struct {
	ZoneId EntertainmentZoneConst
	ZoneName string
}
func DecodeZoneConfigurationDeprecated(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ZoneConfigurationDeprecated
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfigurationDeprecated-FirstZoneId: %w", err)
	} else {
		val.FirstZoneId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfigurationDeprecated-ZoneCount: %w", err)
	} else {
		val.ZoneCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfigurationDeprecated-TotalZoneCount: %w", err)
	} else {
		val.TotalZoneCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]ZoneConfigurationDeprecatedRepeating1, 0)
	i := 0 
	for {
		var rep ZoneConfigurationDeprecatedRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for ZoneConfigurationDeprecated-ZoneId: %w", err)
		} else {
			rep.ZoneId = EntertainmentZoneConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for ZoneConfigurationDeprecated-ZoneName: %w", err)
		} else {
			rep.ZoneName = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type ZoneVolume struct {
	Info MessageInfo
	ZoneId EntertainmentZoneConst
	Volume *uint8
	VolumeChange EntertainmentVolumeControlConst
	Mute YesNoConst
	Channel EntertainmentChannelConst
}
func DecodeZoneVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ZoneVolume
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneVolume-ZoneId: %w", err)
	} else {
		val.ZoneId = EntertainmentZoneConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneVolume-Volume: %w", err)
	} else {
		val.Volume = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneVolume-VolumeChange: %w", err)
	} else {
		val.VolumeChange = EntertainmentVolumeControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneVolume-Mute: %w", err)
	} else {
		val.Mute = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneVolume-Channel: %w", err)
	} else {
		val.Channel = EntertainmentChannelConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AvailableAudioEqPresets struct {
	Info MessageInfo
	FirstPreset *uint8
	PresetCount *uint8
	TotalPresetCount *uint8
	Repeating1 []AvailableAudioEqPresetsRepeating1
}
type AvailableAudioEqPresetsRepeating1 struct {
	PresetType EntertainmentEqConst
	PresetName string
}
func DecodeAvailableAudioEqPresets(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AvailableAudioEqPresets
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableAudioEqPresets-FirstPreset: %w", err)
	} else {
		val.FirstPreset = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableAudioEqPresets-PresetCount: %w", err)
	} else {
		val.PresetCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableAudioEqPresets-TotalPresetCount: %w", err)
	} else {
		val.TotalPresetCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AvailableAudioEqPresetsRepeating1, 0)
	i := 0 
	for {
		var rep AvailableAudioEqPresetsRepeating1
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableAudioEqPresets-PresetType: %w", err)
		} else {
			rep.PresetType = EntertainmentEqConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableAudioEqPresets-PresetName: %w", err)
		} else {
			rep.PresetName = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AvailableBluetoothAddresses struct {
	Info MessageInfo
	FirstAddress *uint8
	AddressCount *uint8
	TotalAddressCount *uint8
	Repeating1 []AvailableBluetoothAddressesRepeating1
}
type AvailableBluetoothAddressesRepeating1 struct {
	BluetoothAddress interface{}
	Status BluetoothStatusConst
	DeviceName string
	SignalStrength *uint8
}
func DecodeAvailableBluetoothAddresses(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AvailableBluetoothAddresses
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-FirstAddress: %w", err)
	} else {
		val.FirstAddress = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-AddressCount: %w", err)
	} else {
		val.AddressCount = v
		if v != nil {
			repeat1Count = uint16(*v)
		}
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-TotalAddressCount: %w", err)
	} else {
		val.TotalAddressCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AvailableBluetoothAddressesRepeating1, 0)
	i := 0 
	for {
		var rep AvailableBluetoothAddressesRepeating1
		if v, err := stream.readBinaryData(48); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-BluetoothAddress: %w", err)
		} else {
			rep.BluetoothAddress = v
		}
		if v, err := stream.readLookupField(8); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-Status: %w", err)
		} else {
			rep.Status = BluetoothStatusConst(v)
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-DeviceName: %w", err)
		} else {
			rep.DeviceName = v
		}
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for AvailableBluetoothAddresses-SignalStrength: %w", err)
		} else {
			rep.SignalStrength = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type BluetoothSourceStatus struct {
	Info MessageInfo
	SourceNumber *uint8
	Status BluetoothSourceStatusConst
	ForgetDevice YesNoConst
	Discovering YesNoConst
	BluetoothAddress interface{}
}
func DecodeBluetoothSourceStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BluetoothSourceStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BluetoothSourceStatus-SourceNumber: %w", err)
	} else {
		val.SourceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for BluetoothSourceStatus-Status: %w", err)
	} else {
		val.Status = BluetoothSourceStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BluetoothSourceStatus-ForgetDevice: %w", err)
	} else {
		val.ForgetDevice = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BluetoothSourceStatus-Discovering: %w", err)
	} else {
		val.Discovering = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(48); err != nil {
		return nil, fmt.Errorf("parse failed for BluetoothSourceStatus-BluetoothAddress: %w", err)
	} else {
		val.BluetoothAddress = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ZoneConfiguration struct {
	Info MessageInfo
	ZoneId EntertainmentZoneConst
	VolumeLimit *uint8
	Fade *int8
	Balance *int8
	SubVolume *uint8
	EqTreble *int8
	EqMidRange *int8
	EqBass *int8
	PresetType EntertainmentEqConst
	AudioFilter EntertainmentFilterConst
	HighPassFilterFrequency *uint16
	LowPassFilterFrequency *uint16
	Channel EntertainmentChannelConst
}
func DecodeZoneConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val ZoneConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-ZoneId: %w", err)
	} else {
		val.ZoneId = EntertainmentZoneConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-VolumeLimit: %w", err)
	} else {
		val.VolumeLimit = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-Fade: %w", err)
	} else {
		val.Fade = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-Balance: %w", err)
	} else {
		val.Balance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-SubVolume: %w", err)
	} else {
		val.SubVolume = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-EqTreble: %w", err)
	} else {
		val.EqTreble = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-EqMidRange: %w", err)
	} else {
		val.EqMidRange = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-EqBass: %w", err)
	} else {
		val.EqBass = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-PresetType: %w", err)
	} else {
		val.PresetType = EntertainmentEqConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-AudioFilter: %w", err)
	} else {
		val.AudioFilter = EntertainmentFilterConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-HighPassFilterFrequency: %w", err)
	} else {
		val.HighPassFilterFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-LowPassFilterFrequency: %w", err)
	} else {
		val.LowPassFilterFrequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ZoneConfiguration-Channel: %w", err)
	} else {
		val.Channel = EntertainmentChannelConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubInit2 struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	A *uint16
	B *uint16
}
func DecodeSonichubInit2(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubInit2
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubInit2-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubInit2-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-ProprietaryId: %w", err)
	} else {
		if v != 1 {
			return nil, fmt.Errorf("match failed for SonichubInit2-ProprietaryId: Expected %d != %d", 1, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit2-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubAmRadio struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item SonichubTuningConst
	Frequency *uint32
	NoiseLevel *uint8
	SignalLevel *uint8
	Text string
}
func DecodeSonichubAmRadio(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubAmRadio
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubAmRadio-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubAmRadio-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-ProprietaryId: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubAmRadio-ProprietaryId: Expected %d != %d", 4, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-Item: %w", err)
	} else {
		val.Item = SonichubTuningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-Frequency: %w", err)
	} else {
		val.Frequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-NoiseLevel: %w", err)
	} else {
		val.NoiseLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-SignalLevel: %w", err)
	} else {
		val.SignalLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAmRadio-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubZoneInfo struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Zone *uint8
}
func DecodeSonichubZoneInfo(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubZoneInfo
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZoneInfo-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubZoneInfo-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZoneInfo-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubZoneInfo-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZoneInfo-ProprietaryId: %w", err)
	} else {
		if v != 5 {
			return nil, fmt.Errorf("match failed for SonichubZoneInfo-ProprietaryId: Expected %d != %d", 5, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZoneInfo-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZoneInfo-Zone: %w", err)
	} else {
		val.Zone = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubSource struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Source SonichubSourceConst
}
func DecodeSonichubSource(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubSource
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSource-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubSource-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSource-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubSource-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSource-ProprietaryId: %w", err)
	} else {
		if v != 6 {
			return nil, fmt.Errorf("match failed for SonichubSource-ProprietaryId: Expected %d != %d", 6, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSource-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSource-Source: %w", err)
	} else {
		val.Source = SonichubSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubSourceList struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	SourceId *uint8
	A *uint8
	Text string
}
func DecodeSonichubSourceList(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubSourceList
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubSourceList-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubSourceList-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-ProprietaryId: %w", err)
	} else {
		if v != 8 {
			return nil, fmt.Errorf("match failed for SonichubSourceList-ProprietaryId: Expected %d != %d", 8, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubSourceList-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item FusionMuteCommandConst
}
func DecodeSonichubControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubControl-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubControl-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubControl-ProprietaryId: %w", err)
	} else {
		if v != 9 {
			return nil, fmt.Errorf("match failed for SonichubControl-ProprietaryId: Expected %d != %d", 9, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubControl-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubControl-Item: %w", err)
	} else {
		val.Item = FusionMuteCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubFmRadio struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item SonichubTuningConst
	Frequency *uint32
	NoiseLevel *uint8
	SignalLevel *uint8
	Text string
}
func DecodeSonichubFmRadio(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubFmRadio
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubFmRadio-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubFmRadio-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-ProprietaryId: %w", err)
	} else {
		if v != 12 {
			return nil, fmt.Errorf("match failed for SonichubFmRadio-ProprietaryId: Expected %d != %d", 12, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-Item: %w", err)
	} else {
		val.Item = SonichubTuningConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-Frequency: %w", err)
	} else {
		val.Frequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-NoiseLevel: %w", err)
	} else {
		val.NoiseLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-SignalLevel: %w", err)
	} else {
		val.SignalLevel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubFmRadio-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubPlaylist struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item SonichubPlaylistConst
	A *uint8
	CurrentTrack *uint32
	Tracks *uint32
	Length *float32
	PositionInTrack *float32
}
func DecodeSonichubPlaylist(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubPlaylist
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubPlaylist-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubPlaylist-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-ProprietaryId: %w", err)
	} else {
		if v != 13 {
			return nil, fmt.Errorf("match failed for SonichubPlaylist-ProprietaryId: Expected %d != %d", 13, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-Item: %w", err)
	} else {
		val.Item = SonichubPlaylistConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-CurrentTrack: %w", err)
	} else {
		val.CurrentTrack = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-Tracks: %w", err)
	} else {
		val.Tracks = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPlaylist-PositionInTrack: %w", err)
	} else {
		val.PositionInTrack = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubTrack struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item *uint32
	Text string
}
func DecodeSonichubTrack(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubTrack
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubTrack-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubTrack-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-ProprietaryId: %w", err)
	} else {
		if v != 14 {
			return nil, fmt.Errorf("match failed for SonichubTrack-ProprietaryId: Expected %d != %d", 14, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-Item: %w", err)
	} else {
		val.Item = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubTrack-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubArtist struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item *uint32
	Text string
}
func DecodeSonichubArtist(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubArtist
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubArtist-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubArtist-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-ProprietaryId: %w", err)
	} else {
		if v != 15 {
			return nil, fmt.Errorf("match failed for SonichubArtist-ProprietaryId: Expected %d != %d", 15, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-Item: %w", err)
	} else {
		val.Item = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubArtist-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubAlbum struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item *uint32
	Text string
}
func DecodeSonichubAlbum(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubAlbum
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubAlbum-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubAlbum-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-ProprietaryId: %w", err)
	} else {
		if v != 16 {
			return nil, fmt.Errorf("match failed for SonichubAlbum-ProprietaryId: Expected %d != %d", 16, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-Item: %w", err)
	} else {
		val.Item = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubAlbum-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubMenuItem struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Item *uint32
	C *uint8
	D *uint8
	E *uint8
	Text string
}
func DecodeSonichubMenuItem(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubMenuItem
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubMenuItem-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubMenuItem-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-ProprietaryId: %w", err)
	} else {
		if v != 19 {
			return nil, fmt.Errorf("match failed for SonichubMenuItem-ProprietaryId: Expected %d != %d", 19, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-Item: %w", err)
	} else {
		val.Item = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMenuItem-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubZones struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Zones *uint8
}
func DecodeSonichubZones(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubZones
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZones-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubZones-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZones-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubZones-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZones-ProprietaryId: %w", err)
	} else {
		if v != 20 {
			return nil, fmt.Errorf("match failed for SonichubZones-ProprietaryId: Expected %d != %d", 20, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZones-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubZones-Zones: %w", err)
	} else {
		val.Zones = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubMaxVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Zone *uint8
	Level *uint8
}
func DecodeSonichubMaxVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubMaxVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubMaxVolume-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubMaxVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-ProprietaryId: %w", err)
	} else {
		if v != 23 {
			return nil, fmt.Errorf("match failed for SonichubMaxVolume-ProprietaryId: Expected %d != %d", 23, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-Zone: %w", err)
	} else {
		val.Zone = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubMaxVolume-Level: %w", err)
	} else {
		val.Level = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Zone *uint8
	Level *uint8
}
func DecodeSonichubVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubVolume-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-ProprietaryId: %w", err)
	} else {
		if v != 24 {
			return nil, fmt.Errorf("match failed for SonichubVolume-ProprietaryId: Expected %d != %d", 24, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Zone: %w", err)
	} else {
		val.Zone = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Level: %w", err)
	} else {
		val.Level = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubInit1 struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
}
func DecodeSonichubInit1(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubInit1
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit1-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubInit1-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit1-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubInit1-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit1-ProprietaryId: %w", err)
	} else {
		if v != 25 {
			return nil, fmt.Errorf("match failed for SonichubInit1-ProprietaryId: Expected %d != %d", 25, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit1-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubPosition struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Position *float32
}
func DecodeSonichubPosition(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubPosition
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPosition-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubPosition-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPosition-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubPosition-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPosition-ProprietaryId: %w", err)
	} else {
		if v != 48 {
			return nil, fmt.Errorf("match failed for SonichubPosition-ProprietaryId: Expected %d != %d", 48, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPosition-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubPosition-Position: %w", err)
	} else {
		val.Position = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubInit3 struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	A *uint8
	B *uint8
}
func DecodeSonichubInit3(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SonichubInit3
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubInit3-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubInit3-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-ProprietaryId: %w", err)
	} else {
		if v != 50 {
			return nil, fmt.Errorf("match failed for SonichubInit3-ProprietaryId: Expected %d != %d", 50, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubInit3-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimradTextMessage struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SimradCommandConst
	A *uint8
	B *uint8
	C *uint8
	Sid *uint8
	Prio *uint8
	Text string
}
func DecodeSimradTextMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimradTextMessage
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimradTextMessage-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimradTextMessage-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-ProprietaryId: %w", err)
	} else {
		if v != 50 {
			return nil, fmt.Errorf("match failed for SimradTextMessage-ProprietaryId: Expected %d != %d", 50, v)
		}
		val.ProprietaryId = SimradCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-Prio: %w", err)
	} else {
		val.Prio = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for SimradTextMessage-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type NavicoProductInformation struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProductCode *uint16
	Model string
	A *uint8
	B *uint8
	C *uint8
	FirmwareVersion string
	FirmwareDate string
	FirmwareTime string
}
func DecodeNavicoProductInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val NavicoProductInformation
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for NavicoProductInformation-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for NavicoProductInformation-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-ProductCode: %w", err)
	} else {
		val.ProductCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-Model: %w", err)
	} else {
		val.Model = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(80); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-FirmwareVersion: %w", err)
	} else {
		val.FirmwareVersion = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-FirmwareDate: %w", err)
	} else {
		val.FirmwareDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for NavicoProductInformation-FirmwareTime: %w", err)
	} else {
		val.FirmwareTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LowranceProductInformation struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProductCode *uint16
	Model string
	A *uint8
	B *uint8
	C *uint8
	FirmwareVersion string
	FirmwareDate string
	FirmwareTime string
}
func DecodeLowranceProductInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LowranceProductInformation
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-ManufacturerCode: %w", err)
	} else {
		if v != 140 {
			return nil, fmt.Errorf("match failed for LowranceProductInformation-ManufacturerCode: Expected %d != %d", 140, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for LowranceProductInformation-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-ProductCode: %w", err)
	} else {
		val.ProductCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-Model: %w", err)
	} else {
		val.Model = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(80); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-FirmwareVersion: %w", err)
	} else {
		val.FirmwareVersion = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-FirmwareDate: %w", err)
	} else {
		val.FirmwareDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceProductInformation-FirmwareTime: %w", err)
	} else {
		val.FirmwareTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetReprogramData struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Version *uint16
	Sequence *uint16
	Data interface{}
}
func DecodeSimnetReprogramData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetReprogramData
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramData-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetReprogramData-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramData-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetReprogramData-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramData-Version: %w", err)
	} else {
		val.Version = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramData-Sequence: %w", err)
	} else {
		val.Sequence = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(1736); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramData-Data: %w", err)
	} else {
		val.Data = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetRequestReprogram struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetRequestReprogram(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetRequestReprogram
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetRequestReprogram-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetRequestReprogram-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetRequestReprogram-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetRequestReprogram-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetReprogramStatus struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Status *uint8
}
func DecodeSimnetReprogramStatus(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetReprogramStatus
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramStatus-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetReprogramStatus-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramStatus-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetReprogramStatus-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetReprogramStatus-Status: %w", err)
	} else {
		val.Status = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type FurunoUnknown130820 struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	A *uint8
	B *uint8
	C *uint8
	D *uint8
	E *uint8
}
func DecodeFurunoUnknown130820(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoUnknown130820
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoUnknown130820-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoUnknown130820-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130820-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSourceName struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	SourceId *uint8
	CurrentSourceId *uint8
	D *uint8
	E *uint8
	Source string
}
func DecodeFusionSourceName(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSourceName
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSourceName-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSourceName-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-MessageId: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for FusionSourceName-MessageId: Expected %d != %d", 2, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-SourceId: %w", err)
	} else {
		val.SourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-CurrentSourceId: %w", err)
	} else {
		val.CurrentSourceId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSourceName-Source: %w", err)
	} else {
		val.Source = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionTrackInfo struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint16
	Transport EntertainmentPlayStatusConst
	X *uint8
	B *uint8
	Track *uint16
	C *uint16
	TrackCount *uint16
	E *uint16
	Length *float32
	PositionInTrack *float32
	H *uint16
}
func DecodeFusionTrackInfo(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionTrackInfo
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionTrackInfo-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionTrackInfo-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-MessageId: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionTrackInfo-MessageId: Expected %d != %d", 4, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-Transport: %w", err)
	} else {
		val.Transport = EntertainmentPlayStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-X: %w", err)
	} else {
		val.X = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-Track: %w", err)
	} else {
		val.Track = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-TrackCount: %w", err)
	} else {
		val.TrackCount = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-PositionInTrack: %w", err)
	} else {
		val.PositionInTrack = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrackInfo-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionTrack struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint64
	Track string
}
func DecodeFusionTrack(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionTrack
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionTrack-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionTrack-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-MessageId: %w", err)
	} else {
		if v != 5 {
			return nil, fmt.Errorf("match failed for FusionTrack-MessageId: Expected %d != %d", 5, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(40); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTrack-Track: %w", err)
	} else {
		val.Track = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionArtist struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint64
	Artist string
}
func DecodeFusionArtist(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionArtist
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionArtist-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionArtist-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-MessageId: %w", err)
	} else {
		if v != 6 {
			return nil, fmt.Errorf("match failed for FusionArtist-MessageId: Expected %d != %d", 6, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(40); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionArtist-Artist: %w", err)
	} else {
		val.Artist = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionAlbum struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint64
	Album string
}
func DecodeFusionAlbum(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionAlbum
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionAlbum-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionAlbum-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-MessageId: %w", err)
	} else {
		if v != 7 {
			return nil, fmt.Errorf("match failed for FusionAlbum-MessageId: Expected %d != %d", 7, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(40); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAlbum-Album: %w", err)
	} else {
		val.Album = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionUnitName struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Name string
}
func DecodeFusionUnitName(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionUnitName
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionUnitName-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionUnitName-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionUnitName-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionUnitName-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionUnitName-MessageId: %w", err)
	} else {
		if v != 33 {
			return nil, fmt.Errorf("match failed for FusionUnitName-MessageId: Expected %d != %d", 33, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionUnitName-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionUnitName-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionZoneName struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Number *uint8
	Name string
}
func DecodeFusionZoneName(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionZoneName
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionZoneName-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionZoneName-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-MessageId: %w", err)
	} else {
		if v != 45 {
			return nil, fmt.Errorf("match failed for FusionZoneName-MessageId: Expected %d != %d", 45, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-Number: %w", err)
	} else {
		val.Number = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionZoneName-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionPlayProgress struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Progress *float32
}
func DecodeFusionPlayProgress(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionPlayProgress
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionPlayProgress-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionPlayProgress-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-MessageId: %w", err)
	} else {
		if v != 9 {
			return nil, fmt.Errorf("match failed for FusionPlayProgress-MessageId: Expected %d != %d", 9, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.001); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPlayProgress-Progress: %w", err)
	} else {
		val.Progress = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionAmFmStation struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	AmFm FusionRadioSourceConst
	B *uint8
	Frequency *uint32
	C *uint8
	Track string
}
func DecodeFusionAmFmStation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionAmFmStation
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionAmFmStation-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionAmFmStation-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-MessageId: %w", err)
	} else {
		if v != 11 {
			return nil, fmt.Errorf("match failed for FusionAmFmStation-MessageId: Expected %d != %d", 11, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-AmFm: %w", err)
	} else {
		val.AmFm = FusionRadioSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-Frequency: %w", err)
	} else {
		val.Frequency = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionAmFmStation-Track: %w", err)
	} else {
		val.Track = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionVhf struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Channel *uint8
	D *uint32
}
func DecodeFusionVhf(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionVhf
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionVhf-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionVhf-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-MessageId: %w", err)
	} else {
		if v != 12 {
			return nil, fmt.Errorf("match failed for FusionVhf-MessageId: Expected %d != %d", 12, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-Channel: %w", err)
	} else {
		val.Channel = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVhf-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSquelch struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Squelch *uint8
}
func DecodeFusionSquelch(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSquelch
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSquelch-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSquelch-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-MessageId: %w", err)
	} else {
		if v != 13 {
			return nil, fmt.Errorf("match failed for FusionSquelch-MessageId: Expected %d != %d", 13, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSquelch-Squelch: %w", err)
	} else {
		val.Squelch = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionScan struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Scan YesNoConst
	C *uint8
}
func DecodeFusionScan(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionScan
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionScan-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionScan-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-MessageId: %w", err)
	} else {
		if v != 14 {
			return nil, fmt.Errorf("match failed for FusionScan-MessageId: Expected %d != %d", 14, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-Scan: %w", err)
	} else {
		val.Scan = YesNoConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for FusionScan-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionMenuItem struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Line *uint8
	E *uint8
	F *uint8
	G *uint8
	H *uint8
	I *uint8
	Text string
}
func DecodeFusionMenuItem(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionMenuItem
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionMenuItem-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionMenuItem-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-MessageId: %w", err)
	} else {
		if v != 17 {
			return nil, fmt.Errorf("match failed for FusionMenuItem-MessageId: Expected %d != %d", 17, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-Line: %w", err)
	} else {
		val.Line = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMenuItem-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionReplay struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Mode FusionReplayModeConst
	C *uint32
	D *uint8
	E *uint8
	Status FusionReplayStatusConst
	H *uint8
	I *uint8
	J *uint8
}
func DecodeFusionReplay(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionReplay
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionReplay-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionReplay-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-MessageId: %w", err)
	} else {
		if v != 20 {
			return nil, fmt.Errorf("match failed for FusionReplay-MessageId: Expected %d != %d", 20, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-Mode: %w", err)
	} else {
		val.Mode = FusionReplayModeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-Status: %w", err)
	} else {
		val.Status = FusionReplayStatusConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionReplay-J: %w", err)
	} else {
		val.J = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionMute struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Mute FusionMuteCommandConst
}
func DecodeFusionMute(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionMute
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMute-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionMute-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMute-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionMute-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMute-MessageId: %w", err)
	} else {
		if v != 23 {
			return nil, fmt.Errorf("match failed for FusionMute-MessageId: Expected %d != %d", 23, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMute-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionMute-Mute: %w", err)
	} else {
		val.Mute = FusionMuteCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSubVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Zone1 *uint8
	Zone2 *uint8
	Zone3 *uint8
	Zone4 *uint8
}
func DecodeFusionSubVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSubVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSubVolume-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSubVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-MessageId: %w", err)
	} else {
		if v != 26 {
			return nil, fmt.Errorf("match failed for FusionSubVolume-MessageId: Expected %d != %d", 26, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-Zone1: %w", err)
	} else {
		val.Zone1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-Zone2: %w", err)
	} else {
		val.Zone2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-Zone3: %w", err)
	} else {
		val.Zone3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSubVolume-Zone4: %w", err)
	} else {
		val.Zone4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionTone struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	B *uint8
	Bass *int8
	Mid *int8
	Treble *int8
}
func DecodeFusionTone(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionTone
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionTone-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionTone-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-MessageId: %w", err)
	} else {
		if v != 27 {
			return nil, fmt.Errorf("match failed for FusionTone-MessageId: Expected %d != %d", 27, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-Bass: %w", err)
	} else {
		val.Bass = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-Mid: %w", err)
	} else {
		val.Mid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionTone-Treble: %w", err)
	} else {
		val.Treble = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	Zone1 *uint8
	Zone2 *uint8
	Zone3 *uint8
	Zone4 *uint8
}
func DecodeFusionVolume(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionVolume-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-MessageId: %w", err)
	} else {
		if v != 29 {
			return nil, fmt.Errorf("match failed for FusionVolume-MessageId: Expected %d != %d", 29, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-Zone1: %w", err)
	} else {
		val.Zone1 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-Zone2: %w", err)
	} else {
		val.Zone2 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-Zone3: %w", err)
	} else {
		val.Zone3 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionVolume-Zone4: %w", err)
	} else {
		val.Zone4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionPowerState struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint8
	State FusionPowerStateConst
}
func DecodeFusionPowerState(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionPowerState
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPowerState-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionPowerState-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPowerState-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionPowerState-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPowerState-MessageId: %w", err)
	} else {
		if v != 32 {
			return nil, fmt.Errorf("match failed for FusionPowerState-MessageId: Expected %d != %d", 32, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPowerState-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionPowerState-State: %w", err)
	} else {
		val.State = FusionPowerStateConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSiriusxmChannel struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint32
	Channel string
}
func DecodeFusionSiriusxmChannel(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSiriusxmChannel
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmChannel-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmChannel-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmChannel-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmChannel-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmChannel-MessageId: %w", err)
	} else {
		if v != 36 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmChannel-MessageId: Expected %d != %d", 36, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmChannel-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmChannel-Channel: %w", err)
	} else {
		val.Channel = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSiriusxmTitle struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint32
	Title string
}
func DecodeFusionSiriusxmTitle(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSiriusxmTitle
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmTitle-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmTitle-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmTitle-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmTitle-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmTitle-MessageId: %w", err)
	} else {
		if v != 37 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmTitle-MessageId: Expected %d != %d", 37, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmTitle-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmTitle-Title: %w", err)
	} else {
		val.Title = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSiriusxmArtist struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint32
	Artist string
}
func DecodeFusionSiriusxmArtist(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSiriusxmArtist
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmArtist-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmArtist-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmArtist-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmArtist-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmArtist-MessageId: %w", err)
	} else {
		if v != 38 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmArtist-MessageId: Expected %d != %d", 38, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmArtist-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmArtist-Artist: %w", err)
	} else {
		val.Artist = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FusionSiriusxmGenre struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId FusionMessageIdConst
	A *uint32
	Genre string
}
func DecodeFusionSiriusxmGenre(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FusionSiriusxmGenre
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmGenre-ManufacturerCode: %w", err)
	} else {
		if v != 419 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmGenre-ManufacturerCode: Expected %d != %d", 419, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmGenre-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmGenre-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmGenre-MessageId: %w", err)
	} else {
		if v != 40 {
			return nil, fmt.Errorf("match failed for FusionSiriusxmGenre-MessageId: Expected %d != %d", 40, v)
		}
		val.MessageId = FusionMessageIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmGenre-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLength(); err != nil {
		return nil, fmt.Errorf("parse failed for FusionSiriusxmGenre-Genre: %w", err)
	} else {
		val.Genre = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FurunoUnknown130821 struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	A *uint8
	B *uint8
	C *uint8
	D *uint8
	E *uint8
	F *uint8
	G *uint8
	H *uint8
	I *uint8
}
func DecodeFurunoUnknown130821(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoUnknown130821
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoUnknown130821-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoUnknown130821-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoUnknown130821-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronProprietaryTemperatureHighRange struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	ActualTemperature *float32
	SetTemperature *float32
}
func DecodeMaretronProprietaryTemperatureHighRange(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronProprietaryTemperatureHighRange
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Sid: %w", err)
	} else {
		val.Sid = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-SetTemperature: %w", err)
	} else {
		val.SetTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BGWindData struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Field4 *uint8
	Field5 *uint8
	Timestamp *uint32
}
func DecodeBGWindData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val BGWindData
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for BGWindData-ManufacturerCode: %w", err)
	} else {
		if v != 381 {
			return nil, fmt.Errorf("match failed for BGWindData-ManufacturerCode: Expected %d != %d", 381, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for BGWindData-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for BGWindData-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BGWindData-Field4: %w", err)
	} else {
		val.Field4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BGWindData-Field5: %w", err)
	} else {
		val.Field5 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for BGWindData-Timestamp: %w", err)
	} else {
		val.Timestamp = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronAnnunciator struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Field4 *uint8
	Field5 *uint8
	Field6 *uint16
	Field7 *uint8
	Field8 *uint16
}
func DecodeMaretronAnnunciator(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronAnnunciator
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronAnnunciator-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronAnnunciator-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-Field4: %w", err)
	} else {
		val.Field4 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-Field5: %w", err)
	} else {
		val.Field5 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-Field6: %w", err)
	} else {
		val.Field6 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-Field7: %w", err)
	} else {
		val.Field7 = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronAnnunciator-Field8: %w", err)
	} else {
		val.Field8 = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LowranceUnknown struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	A *uint8
	B *uint8
	C *uint8
	D *uint8
	E *uint16
	F *uint16
}
func DecodeLowranceUnknown(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val LowranceUnknown
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-ManufacturerCode: %w", err)
	} else {
		if v != 140 {
			return nil, fmt.Errorf("match failed for LowranceUnknown-ManufacturerCode: Expected %d != %d", 140, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for LowranceUnknown-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceUnknown-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetSetSerialNumber struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetSetSerialNumber(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetSetSerialNumber
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSetSerialNumber-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetSetSerialNumber-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSetSerialNumber-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetSetSerialNumber-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SuzukiEngineAndStorageDeviceConfig struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSuzukiEngineAndStorageDeviceConfig(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SuzukiEngineAndStorageDeviceConfig
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SuzukiEngineAndStorageDeviceConfig-ManufacturerCode: %w", err)
	} else {
		if v != 586 {
			return nil, fmt.Errorf("match failed for SuzukiEngineAndStorageDeviceConfig-ManufacturerCode: Expected %d != %d", 586, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SuzukiEngineAndStorageDeviceConfig-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SuzukiEngineAndStorageDeviceConfig-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetFuelUsedHighResolution struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetFuelUsedHighResolution(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetFuelUsedHighResolution
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFuelUsedHighResolution-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetFuelUsedHighResolution-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFuelUsedHighResolution-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetFuelUsedHighResolution-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetEngineAndTankConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetEngineAndTankConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetEngineAndTankConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEngineAndTankConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetEngineAndTankConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEngineAndTankConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetEngineAndTankConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetSetEngineAndTankConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetSetEngineAndTankConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetSetEngineAndTankConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSetEngineAndTankConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetSetEngineAndTankConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSetEngineAndTankConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetSetEngineAndTankConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetFluidLevelSensorConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	C *uint8
	Device *uint8
	Instance *uint8
	F *uint8
	TankType TankTypeConst
	Capacity *float32
	G *uint8
	H *int16
	I *int8
}
func DecodeSimnetFluidLevelSensorConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetFluidLevelSensorConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetFluidLevelSensorConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetFluidLevelSensorConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-Device: %w", err)
	} else {
		val.Device = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-TankType: %w", err)
	} else {
		val.TankType = TankTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-Capacity: %w", err)
	} else {
		val.Capacity = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelSensorConfiguration-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronSwitchStatusCounter struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Instance *uint8
	IndicatorNumber *uint8
	StartDate *uint16
	StartTime *float32
	OffCounter *uint8
	OnCounter *uint8
	ErrorCounter *uint8
	SwitchStatus OffOnConst
}
func DecodeMaretronSwitchStatusCounter(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronSwitchStatusCounter
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartDate: %w", err)
	} else {
		val.StartDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartTime: %w", err)
	} else {
		val.StartTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OffCounter: %w", err)
	} else {
		val.OffCounter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OnCounter: %w", err)
	} else {
		val.OnCounter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ErrorCounter: %w", err)
	} else {
		val.ErrorCounter = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-SwitchStatus: %w", err)
	} else {
		val.SwitchStatus = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetFuelFlowTurbineConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetFuelFlowTurbineConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetFuelFlowTurbineConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFuelFlowTurbineConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetFuelFlowTurbineConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFuelFlowTurbineConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetFuelFlowTurbineConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronSwitchStatusTimer struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Instance *uint8
	IndicatorNumber *uint8
	StartDate *uint16
	StartTime *float32
	AccumulatedOffPeriod *uint32
	AccumulatedOnPeriod *uint32
	AccumulatedErrorPeriod *uint32
	SwitchStatus OffOnConst
}
func DecodeMaretronSwitchStatusTimer(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val MaretronSwitchStatusTimer
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-Instance: %w", err)
	} else {
		val.Instance = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartDate: %w", err)
	} else {
		val.StartDate = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartTime: %w", err)
	} else {
		val.StartTime = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOffPeriod: %w", err)
	} else {
		val.AccumulatedOffPeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOnPeriod: %w", err)
	} else {
		val.AccumulatedOnPeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedErrorPeriod: %w", err)
	} else {
		val.AccumulatedErrorPeriod = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-SwitchStatus: %w", err)
	} else {
		val.SwitchStatus = OffOnConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetFluidLevelWarning struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetFluidLevelWarning(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetFluidLevelWarning
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelWarning-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetFluidLevelWarning-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetFluidLevelWarning-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetFluidLevelWarning-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetPressureSensorConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetPressureSensorConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetPressureSensorConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPressureSensorConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetPressureSensorConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPressureSensorConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetPressureSensorConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetDataUserGroupConfiguration struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetDataUserGroupConfiguration(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetDataUserGroupConfiguration
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDataUserGroupConfiguration-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetDataUserGroupConfiguration-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDataUserGroupConfiguration-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetDataUserGroupConfiguration-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetAisClassBStaticDataMsg24PartA struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	D *uint8
	E *uint8
	UserId *uint32
	Name string
}
func DecodeSimnetAisClassBStaticDataMsg24PartA(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetAisClassBStaticDataMsg24PartA
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartA-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartA-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-MessageId: %w", err)
	} else {
		if v != nil && *v != 0 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartA-MessageId: Expected %d != %d", 0, *v)
		}
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartA-Name: %w", err)
	} else {
		val.Name = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FurunoSixDegreesOfFreedomMovement struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	A *int32
	B *int32
	C *int32
	D *int8
	E *int32
	F *int32
	G *int16
	H *int16
	I *int16
}
func DecodeFurunoSixDegreesOfFreedomMovement(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoSixDegreesOfFreedomMovement
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoSixDegreesOfFreedomMovement-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoSixDegreesOfFreedomMovement-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoSixDegreesOfFreedomMovement-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetAisClassBStaticDataMsg24PartB struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	D *uint8
	E *uint8
	UserId *uint32
	TypeOfShip ShipTypeConst
	VendorId string
	Callsign string
	Length *float32
	Beam *float32
	PositionReferenceFromStarboard *float32
	PositionReferenceFromBow *float32
	MothershipUserId *uint32
}
func DecodeSimnetAisClassBStaticDataMsg24PartB(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetAisClassBStaticDataMsg24PartB
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartB-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartB-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-MessageId: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for SimnetAisClassBStaticDataMsg24PartB-MessageId: Expected %d != %d", 1, *v)
		}
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-E: %w", err)
	} else {
		val.E = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-UserId: %w", err)
	} else {
		val.UserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-VendorId: %w", err)
	} else {
		val.VendorId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-Callsign: %w", err)
	} else {
		val.Callsign = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-Length: %w", err)
	} else {
		val.Length = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-Beam: %w", err)
	} else {
		val.Beam = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAisClassBStaticDataMsg24PartB-MothershipUserId: %w", err)
	} else {
		val.MothershipUserId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type FurunoHeelAngleRollInformation struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	A *uint8
	B *uint8
	Yaw *float32
	Pitch *float32
	Roll *float32
}
func DecodeFurunoHeelAngleRollInformation(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoHeelAngleRollInformation
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoHeelAngleRollInformation-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoHeelAngleRollInformation-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-Yaw: %w", err)
	} else {
		val.Yaw = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-Pitch: %w", err)
	} else {
		val.Pitch = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoHeelAngleRollInformation-Roll: %w", err)
	} else {
		val.Roll = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetSonarStatusFrequencyAndDspVoltage struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeSimnetSonarStatusFrequencyAndDspVoltage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetSonarStatusFrequencyAndDspVoltage
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSonarStatusFrequencyAndDspVoltage-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetSonarStatusFrequencyAndDspVoltage-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetSonarStatusFrequencyAndDspVoltage-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetSonarStatusFrequencyAndDspVoltage-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetCompassHeadingOffset struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	Unused *uint32
	Type SimradTypeConst
	UnusedB *uint16
	Angle *float32
	UnusedC *uint16
}
func DecodeSimnetCompassHeadingOffset(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetCompassHeadingOffset
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetCompassHeadingOffset-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetCompassHeadingOffset-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-Unused: %w", err)
	} else {
		val.Unused = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-Type: %w", err)
	} else {
		if v != 0 {
			return nil, fmt.Errorf("match failed for SimnetCompassHeadingOffset-Type: Expected %d != %d", 0, v)
		}
		val.Type = SimradTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-UnusedB: %w", err)
	} else {
		val.UnusedB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-Angle: %w", err)
	} else {
		val.Angle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassHeadingOffset-UnusedC: %w", err)
	} else {
		val.UnusedC = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FurunoMultiSatsInViewExtended struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeFurunoMultiSatsInViewExtended(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoMultiSatsInViewExtended
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoMultiSatsInViewExtended-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoMultiSatsInViewExtended-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoMultiSatsInViewExtended-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoMultiSatsInViewExtended-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetCompassLocalField struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	Unused *uint32
	Type SimradTypeConst
	UnusedB *uint16
	LocalField *float32
	UnusedC *uint16
}
func DecodeSimnetCompassLocalField(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetCompassLocalField
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetCompassLocalField-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetCompassLocalField-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-Unused: %w", err)
	} else {
		val.Unused = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-Type: %w", err)
	} else {
		if v != 768 {
			return nil, fmt.Errorf("match failed for SimnetCompassLocalField-Type: Expected %d != %d", 768, v)
		}
		val.Type = SimradTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-UnusedB: %w", err)
	} else {
		val.UnusedB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.004); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-LocalField: %w", err)
	} else {
		val.LocalField = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassLocalField-UnusedC: %w", err)
	} else {
		val.UnusedC = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetCompassFieldAngle struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	Unused *uint32
	Type SimradTypeConst
	UnusedB *uint16
	FieldAngle *float32
	UnusedC *uint16
}
func DecodeSimnetCompassFieldAngle(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetCompassFieldAngle
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetCompassFieldAngle-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetCompassFieldAngle-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-Unused: %w", err)
	} else {
		val.Unused = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-Type: %w", err)
	} else {
		if v != 1024 {
			return nil, fmt.Errorf("match failed for SimnetCompassFieldAngle-Type: Expected %d != %d", 1024, v)
		}
		val.Type = SimradTypeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-UnusedB: %w", err)
	} else {
		val.UnusedB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-FieldAngle: %w", err)
	} else {
		val.FieldAngle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetCompassFieldAngle-UnusedC: %w", err)
	} else {
		val.UnusedC = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetParameterHandle struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint8
	RepeatIndicator RepeatIndicatorConst
	D *uint8
	Group *uint8
	F *uint8
	G *uint8
	H *uint8
	I *uint8
	J *uint8
	Backlight SimnetBacklightLevelConst
	L *uint16
}
func DecodeSimnetParameterHandle(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetParameterHandle
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetParameterHandle-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetParameterHandle-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(6); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-D: %w", err)
	} else {
		val.D = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-Group: %w", err)
	} else {
		val.Group = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-H: %w", err)
	} else {
		val.H = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-I: %w", err)
	} else {
		val.I = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-J: %w", err)
	} else {
		val.J = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-Backlight: %w", err)
	} else {
		val.Backlight = SimnetBacklightLevelConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetParameterHandle-L: %w", err)
	} else {
		val.L = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type FurunoMotionSensorStatusExtended struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func DecodeFurunoMotionSensorStatusExtended(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val FurunoMotionSensorStatusExtended
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoMotionSensorStatusExtended-ManufacturerCode: %w", err)
	} else {
		if v != 1855 {
			return nil, fmt.Errorf("match failed for FurunoMotionSensorStatusExtended-ManufacturerCode: Expected %d != %d", 1855, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for FurunoMotionSensorStatusExtended-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for FurunoMotionSensorStatusExtended-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SeatalkNodeStatistics struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProductCode *uint16
	Year *uint8
	Month *uint8
	DeviceNumber *uint16
	NodeVoltage *float32
}
func DecodeSeatalkNodeStatistics(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SeatalkNodeStatistics
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkNodeStatistics-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkNodeStatistics-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-ProductCode: %w", err)
	} else {
		val.ProductCode = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-Year: %w", err)
	} else {
		val.Year = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-Month: %w", err)
	} else {
		val.Month = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-DeviceNumber: %w", err)
	} else {
		val.DeviceNumber = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkNodeStatistics-NodeVoltage: %w", err)
	} else {
		val.NodeVoltage = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetEventCommandApCommand struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SimradEventCommandConst
	UnusedA *uint16
	ControllingDevice *uint8
	Event SimnetApEventsConst
	UnusedB *uint8
	Direction SimnetDirectionConst
	Angle *float32
	UnusedC *uint8
}
func DecodeSimnetEventCommandApCommand(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetEventCommandApCommand
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandApCommand-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandApCommand-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-ProprietaryId: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandApCommand-ProprietaryId: Expected %d != %d", 2, v)
		}
		val.ProprietaryId = SimradEventCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-UnusedA: %w", err)
	} else {
		val.UnusedA = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-ControllingDevice: %w", err)
	} else {
		val.ControllingDevice = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-Event: %w", err)
	} else {
		val.Event = SimnetApEventsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-UnusedB: %w", err)
	} else {
		val.UnusedB = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-Direction: %w", err)
	} else {
		val.Direction = SimnetDirectionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-Angle: %w", err)
	} else {
		val.Angle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandApCommand-UnusedC: %w", err)
	} else {
		val.UnusedC = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetEventCommandAlarm struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	A *uint16
	ProprietaryId SimradEventCommandConst
	C *uint8
	Alarm *uint16
	MessageId *uint16
	F *uint8
	G *uint8
}
func DecodeSimnetEventCommandAlarm(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetEventCommandAlarm
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandAlarm-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandAlarm-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-A: %w", err)
	} else {
		val.A = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-ProprietaryId: %w", err)
	} else {
		if v != 1 {
			return nil, fmt.Errorf("match failed for SimnetEventCommandAlarm-ProprietaryId: Expected %d != %d", 1, v)
		}
		val.ProprietaryId = SimradEventCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-Alarm: %w", err)
	} else {
		val.Alarm = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-F: %w", err)
	} else {
		val.F = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventCommandAlarm-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetEventReplyApCommand struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SimradEventCommandConst
	B *uint16
	ControllingDevice *uint8
	Event SimnetApEventsConst
	C *uint8
	Direction SimnetDirectionConst
	Angle *float32
	G *uint8
}
func DecodeSimnetEventReplyApCommand(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetEventReplyApCommand
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetEventReplyApCommand-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetEventReplyApCommand-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-ProprietaryId: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for SimnetEventReplyApCommand-ProprietaryId: Expected %d != %d", 2, v)
		}
		val.ProprietaryId = SimradEventCommandConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-ControllingDevice: %w", err)
	} else {
		val.ControllingDevice = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-Event: %w", err)
	} else {
		val.Event = SimnetApEventsConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-Direction: %w", err)
	} else {
		val.Direction = SimnetDirectionConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-Angle: %w", err)
	} else {
		val.Angle = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetEventReplyApCommand-G: %w", err)
	} else {
		val.G = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetAlarmMessage struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	MessageId *uint16
	B *uint8
	C *uint8
	Text string
}
func DecodeSimnetAlarmMessage(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val SimnetAlarmMessage
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetAlarmMessage-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetAlarmMessage-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-MessageId: %w", err)
	} else {
		val.MessageId = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-B: %w", err)
	} else {
		val.B = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(1784); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetAlarmMessage-Text: %w", err)
	} else {
		val.Text = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarAdditionalWeatherData struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	C *uint8
	ApparentWindchillTemperature *float32
	TrueWindchillTemperature *float32
	Dewpoint *float32
}
func DecodeAirmarAdditionalWeatherData(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarAdditionalWeatherData
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAdditionalWeatherData-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAdditionalWeatherData-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-ApparentWindchillTemperature: %w", err)
	} else {
		val.ApparentWindchillTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-TrueWindchillTemperature: %w", err)
	} else {
		val.TrueWindchillTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAdditionalWeatherData-Dewpoint: %w", err)
	} else {
		val.Dewpoint = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarHeaterControl struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	C *uint8
	PlateTemperature *float32
	AirTemperature *float32
	Dewpoint *float32
}
func DecodeAirmarHeaterControl(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarHeaterControl
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarHeaterControl-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarHeaterControl-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-C: %w", err)
	} else {
		val.C = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-PlateTemperature: %w", err)
	} else {
		val.PlateTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-AirTemperature: %w", err)
	} else {
		val.AirTemperature = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarHeaterControl-Dewpoint: %w", err)
	} else {
		val.Dewpoint = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarPost struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Control AirmarPostControlConst
	NumberOfIdTestResultPairsToFollow *uint8
	TestId AirmarPostIdConst
	TestResult *uint8
}
func DecodeAirmarPost(Info MessageInfo, stream *PGNDataStream) (interface{}, error) {
	var val AirmarPost
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarPost-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarPost-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-Control: %w", err)
	} else {
		val.Control = AirmarPostControlConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(7)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-NumberOfIdTestResultPairsToFollow: %w", err)
	} else {
		val.NumberOfIdTestResultPairsToFollow = v
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-TestId: %w", err)
	} else {
		val.TestId = AirmarPostIdConst(v)
		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarPost-TestResult: %w", err)
	} else {
		val.TestResult = v
		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
